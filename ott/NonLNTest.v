(* generated by Ott 0.32 from: NonLNTest.ott *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import Ott.ott_list_core.


Require Import TLC.LibTactics.
Require Import Coq.micromega.Lia.
Require Export Metalib.LibLNgen.
Require Import Coq.Program.Equality.
Require Import Metalib.MetatheoryAtom.
Require Import Cpdtlib.CpdtTactics.

Require Import Defs.HdmRewrites.

From Coq Require Import Init.Logic.

#[export] Hint Constructors Compare : core.
Set Warnings "-notation-overridden".

Open Scope program_scope.

Definition index : Set := nat.
Definition termvar : Set := atom. (*r term variable *)
Lemma eq_termvar: forall (x y : termvar), {x = y} + {x <> y}.
Proof.
apply eq_dec.
Defined.
#[export] Hint Resolve eq_termvar : ott_coq_equality.
(* Roger: added export locality to Ott src, see grammar_pp.ml *)
Definition dskvar : Set := atom. (*r skollem variable *)
Lemma eq_dskvar: forall (x y : dskvar), {x = y} + {x <> y}.
Proof.
apply eq_dec.
Defined.
#[export] Hint Resolve eq_dskvar : ott_coq_equality.
(* Roger: added export locality to Ott src, see grammar_pp.ml *)

Inductive DTy : Set :=  (*r Dec Types *)
 | DT_SkVar (dskA:dskvar) (*r Skolem variable *)
 | DT_Unit : DTy (*r Unit type *)
 | DT_Fun (DTy1:DTy) (DTy2:DTy) (*r Function type *).

Inductive DSch : Set :=  (*r Dec Type schemes *)
 | DS_Mono (DTy5:DTy) (*r Monotype *)
 | DS_Forall (dskA:dskvar) (DSch5:DSch) (*r Forall *).

Inductive DEnv : Set :=  (*r Dec Environment *)
 | DEnv_Empty : DEnv (*r Empty environment *)
 | DEnv_DSkol (DEnv5:DEnv) (dskA:dskvar) (*r Cons Sk *)
 | DEnv_DVar (DEnv5:DEnv) (x:termvar) (DSch5:DSch) (*r Cons Variable *).

Inductive e : Set :=  (*r Terms *)
 | e_Var (x:termvar) (*r Term variable *)
 | e_Unit : e (*r Term unit *)
 | e_App (e1:e) (e2:e) (*r Application *)
 | e_Lam (x:termvar) (e5:e) (*r Abstraction *)
 | e_Let (x:termvar) (e1:e) (e2:e) (*r Let binding *).
Lemma eq_DTy: forall (x y : DTy), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
#[export] Hint Resolve eq_DTy : ott_coq_equality.
(* Roger: added export locality to Ott src, see grammar_pp.ml *)
Lemma eq_DSch: forall (x y : DSch), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
#[export] Hint Resolve eq_DSch : ott_coq_equality.
(* Roger: added export locality to Ott src, see grammar_pp.ml *)
Lemma eq_e: forall (x y : e), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
#[export] Hint Resolve eq_e : ott_coq_equality.
(* Roger: added export locality to Ott src, see grammar_pp.ml *)
(** library functions *)
Fixpoint list_mem A (eq:forall a b:A,{a=b}+{a<>b}) (x:A) (l:list A) {struct l} : bool :=
  match l with
  | nil => false
  | cons h t => if eq h x then true else list_mem A eq x t
end.
Arguments list_mem [A] _ _ _.


(** substitutions *)
Fixpoint subst_dskvar_DTy (DTy_6:DTy) (dskA5:dskvar) (DTy__7:DTy) {struct DTy__7} : DTy :=
  match DTy__7 with
  | (DT_SkVar dskA) => (if eq_dskvar dskA dskA5 then DTy_6 else (DT_SkVar dskA))
  | DT_Unit => DT_Unit 
  | (DT_Fun DTy1 DTy2) => DT_Fun (subst_dskvar_DTy DTy_6 dskA5 DTy1) (subst_dskvar_DTy DTy_6 dskA5 DTy2)
end.

Fixpoint subst_dskvar_DSch (DTy_6:DTy) (dskA5:dskvar) (DSch_6:DSch) {struct DSch_6} : DSch :=
  match DSch_6 with
  | (DS_Mono DTy5) => DS_Mono (subst_dskvar_DTy DTy_6 dskA5 DTy5)
  | (DS_Forall dskA DSch5) => DS_Forall dskA (if list_mem eq_dskvar dskA5 (cons dskA nil) then DSch5 else (subst_dskvar_DSch DTy_6 dskA5 DSch5))
end.

Fixpoint subst_tm_e (e_6:e) (x5:termvar) (e__7:e) {struct e__7} : e :=
  match e__7 with
  | (e_Var x) => (if eq_termvar x x5 then e_6 else (e_Var x))
  | e_Unit => e_Unit 
  | (e_App e1 e2) => e_App (subst_tm_e e_6 x5 e1) (subst_tm_e e_6 x5 e2)
  | (e_Lam x e5) => e_Lam x (if list_mem eq_termvar x5 (cons x nil) then e5 else (subst_tm_e e_6 x5 e5))
  | (e_Let x e1 e2) => e_Let x (subst_tm_e e_6 x5 e1) (if list_mem eq_termvar x5 (cons x nil) then e2 else (subst_tm_e e_6 x5 e2))
end.

Fixpoint subst_dskvar_DEnv (DTy5:DTy) (dskA5:dskvar) (DEnv_6:DEnv) {struct DEnv_6} : DEnv :=
  match DEnv_6 with
  | DEnv_Empty => DEnv_Empty 
  | (DEnv_DSkol DEnv5 dskA) => DEnv_DSkol (subst_dskvar_DEnv DTy5 dskA5 DEnv5) dskA
  | (DEnv_DVar DEnv5 x DSch5) => DEnv_DVar (subst_dskvar_DEnv DTy5 dskA5 DEnv5) x (subst_dskvar_DSch DTy5 dskA5 DSch5)
end.

(** library functions *)
Fixpoint list_minus A (eq:forall a b:A,{a=b}+{a<>b}) (l1:list A) (l2:list A) {struct l1} : list A :=
  match l1 with
  | nil => nil
  | cons h t => if (list_mem (A:=A) eq h l2) then list_minus A eq t l2 else cons h (list_minus A eq t l2)
end.
Arguments list_minus [A] _ _ _.


(** free variables *)
Fixpoint free_dskvars_DTy (DTy_6:DTy) : list dskvar :=
  match DTy_6 with
  | (DT_SkVar dskA) => (cons dskA nil)
  | DT_Unit => nil
  | (DT_Fun DTy1 DTy2) => (app (free_dskvars_DTy DTy1) (free_dskvars_DTy DTy2))
end.

Fixpoint free_dskvars_DSch (DSch_6:DSch) : list dskvar :=
  match DSch_6 with
  | (DS_Mono DTy5) => ((free_dskvars_DTy DTy5))
  | (DS_Forall dskA DSch5) => ((list_minus eq_dskvar (free_dskvars_DSch DSch5) (cons dskA nil)))
end.

Fixpoint free_xs_e (e_6:e) : list termvar :=
  match e_6 with
  | (e_Var x) => (cons x nil)
  | e_Unit => nil
  | (e_App e1 e2) => (app (free_xs_e e1) (free_xs_e e2))
  | (e_Lam x e5) => ((list_minus eq_termvar (free_xs_e e5) (cons x nil)))
  | (e_Let x e1 e2) => (app (free_xs_e e1) (list_minus eq_termvar (free_xs_e e2) (cons x nil)))
end.

Fixpoint free_dskvars_DEnv (DEnv_6:DEnv) : list dskvar :=
  match DEnv_6 with
  | DEnv_Empty => nil
  | (DEnv_DSkol DEnv5 dskA) => ((free_dskvars_DEnv DEnv5))
  | (DEnv_DVar DEnv5 x DSch5) => (app (free_dskvars_DEnv DEnv5) (free_dskvars_DSch DSch5))
end.

(** definitions *)

(* defns DecHelpers *)
Inductive WfDTy : DEnv -> DSch -> Prop :=    (* defn WfDTy *)
 | WfDTyAbs : forall (DEnv5:DEnv) (dskA:dskvar) (DSch5:DSch)
     (WFDTY: WfDTy (DEnv_DSkol DEnv5 dskA) DSch5),
     WfDTy DEnv5 (DS_Forall dskA DSch5)
with SubSump : DEnv -> DSch -> DSch -> Prop :=    (* defn SubSump *)
 | SubSumpSkol : forall (DEnv5:DEnv) (DSch1:DSch) (dskA:dskvar) (DSch2:DSch)
     (SS: SubSump (DEnv_DSkol DEnv5 dskA) DSch1 DSch2),
     SubSump DEnv5 DSch1 (DS_Forall dskA DSch2).
(* Local Variables: *)
(* company-coq-local-symbols: (("|=" . ?⊨) ("=|" . ?⫤) ("->>" . ?↠) ("=~" . ?≈) ("<|" . ?⟨) ("|>" . ?⟩)); *)
(* End: *)



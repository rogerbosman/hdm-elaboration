(* generated by Ott 0.32, locally-nameless lngen from: /home/roger/hdm/ott/HdmDefs.ott *)
Require Import Metalib.Metatheory.
(** syntax *)
Definition index : Set := nat.
Definition tvar : Set := var. (*r term variable *)
Lemma eq_tvar: forall (x y : tvar), {x = y} + {x <> y}.
Proof.
apply eq_dec.
Defined.
#[export] Hint Resolve eq_tvar : ott_coq_equality.
(* Roger: added export locality to Ott src, see grammar_pp.ml *)
Definition skvar : Set := var. (*r skollem variable *)
Lemma eq_skvar: forall (x y : skvar), {x = y} + {x <> y}.
Proof.
apply eq_dec.
Defined.
#[export] Hint Resolve eq_skvar : ott_coq_equality.
(* Roger: added export locality to Ott src, see grammar_pp.ml *)

Inductive T : Set :=  (*r Types *)
 | T__Var_b (_:nat) (*r Type variable *)
 | T__Var_f (alpha:skvar) (*r Type variable *)
 | T__Unit : T (*r Unit *)
 | T__Bool : T (*r Bool *)
 | T__Fun (tau1:T) (tau2:T) (*r Function *).

Inductive Sc : Set :=  (*r Type schemes *)
 | S__T (tau:T) (*r Monotype *)
 | S__Forall (sigma:Sc) (*r Forall *).

Definition A : Set := list skvar.

Inductive Tm : Set :=  (*r Elaborated terms *)
 | t__Var_b (_:nat) (*r Term variable *)
 | t__Var_f (tx:tvar) (*r Term variable *)
 | t__Unit : Tm (*r Unit *)
 | t__True : Tm (*r True *)
 | t__False : Tm (*r False *)
 | t__App (t1:Tm) (t2:Tm) (*r Term Application *)
 | t__TApp (t:Tm) (tau:T) (*r Type Application *)
 | t__Lam (tau:T) (t:Tm) (*r Term Abstraction *)
 | t__TLam (t:Tm) (*r Type Abstraction *).

Inductive E : Set :=  (*r Environment *)
 | E__Nil : E (*r Empty environment *)
 | E__A (psi:E) (a:A) (*r Cons Existential environment *)
 | E__Var (psi:E) (x:var) (sigma:Sc) (*r Cons Variable *)
 | E__O (psi:E) (t:Tm) (a:A) (sigma:Sc) (*r Cons Object *).

Inductive Ex : Set :=  (*r Terms *)
 | e__Var_b (_:nat) (*r Term variable *)
 | e__Var_f (x:var) (*r Term variable *)
 | e__Unit : Ex (*r Unit *)
 | e__App (e1:Ex) (e2:Ex) (*r Term Application *)
 | e__Lam (e:Ex) (*r Term Abstraction *)
 | e__Let (e1:Ex) (e2:Ex) (*r Let *).

Definition Sub : Set := list (T * skvar).

Definition E_and_Eqs : Set := (E * list (T * T)).

Definition Eqs : Set := list (T * T).

Definition vars : Set := atoms.
Lemma eq_T: forall (x y : T), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
#[export] Hint Resolve eq_T : ott_coq_equality.
(* Roger: added export locality to Ott src, see grammar_pp.ml *)
Lemma eq_Sc: forall (x y : Sc), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
#[export] Hint Resolve eq_Sc : ott_coq_equality.
(* Roger: added export locality to Ott src, see grammar_pp.ml *)
Lemma eq_Tm: forall (x y : Tm), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
#[export] Hint Resolve eq_Tm : ott_coq_equality.
(* Roger: added export locality to Ott src, see grammar_pp.ml *)
Lemma eq_Ex: forall (x y : Ex), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
#[export] Hint Resolve eq_Ex : ott_coq_equality.
(* Roger: added export locality to Ott src, see grammar_pp.ml *)

(* EXPERIMENTAL *)
(** auxiliary functions on the new list types *)
(** library functions *)
(** subrules *)
(** arities *)
(** opening up abstractions *)
Fixpoint open_T_wrt_T_rec (k:nat) (tau_5:T) (tau__6:T) {struct tau__6}: T :=
  match tau__6 with
  | (T__Var_b nat) => 
      match lt_eq_lt_dec nat k with
        | inleft (left _) => T__Var_b nat
        | inleft (right _) => tau_5
        | inright _ => T__Var_b (nat - 1)
      end
  | (T__Var_f alpha) => T__Var_f alpha
  | T__Unit => T__Unit 
  | T__Bool => T__Bool 
  | (T__Fun tau1 tau2) => T__Fun (open_T_wrt_T_rec k tau_5 tau1) (open_T_wrt_T_rec k tau_5 tau2)
end.

Fixpoint open_Tm_wrt_T_rec (k:nat) (tau5:T) (t_5:Tm) {struct t_5}: Tm :=
  match t_5 with
  | (t__Var_b nat) => t__Var_b nat
  | (t__Var_f tx) => t__Var_f tx
  | t__Unit => t__Unit 
  | t__True => t__True 
  | t__False => t__False 
  | (t__App t1 t2) => t__App (open_Tm_wrt_T_rec k tau5 t1) (open_Tm_wrt_T_rec k tau5 t2)
  | (t__TApp t tau) => t__TApp (open_Tm_wrt_T_rec k tau5 t) (open_T_wrt_T_rec k tau5 tau)
  | (t__Lam tau t) => t__Lam (open_T_wrt_T_rec k tau5 tau) (open_Tm_wrt_T_rec k tau5 t)
  | (t__TLam t) => t__TLam (open_Tm_wrt_T_rec (S k) tau5 t)
end.

Fixpoint open_Sc_wrt_T_rec (k:nat) (tau5:T) (sigma5:Sc) {struct sigma5}: Sc :=
  match sigma5 with
  | (S__T tau) => S__T (open_T_wrt_T_rec k tau5 tau)
  | (S__Forall sigma) => S__Forall (open_Sc_wrt_T_rec (S k) tau5 sigma)
end.

Fixpoint open_Tm_wrt_Tm_rec (k:nat) (t_5:Tm) (t__6:Tm) {struct t__6}: Tm :=
  match t__6 with
  | (t__Var_b nat) => 
      match lt_eq_lt_dec nat k with
        | inleft (left _) => t__Var_b nat
        | inleft (right _) => t_5
        | inright _ => t__Var_b (nat - 1)
      end
  | (t__Var_f tx) => t__Var_f tx
  | t__Unit => t__Unit 
  | t__True => t__True 
  | t__False => t__False 
  | (t__App t1 t2) => t__App (open_Tm_wrt_Tm_rec k t_5 t1) (open_Tm_wrt_Tm_rec k t_5 t2)
  | (t__TApp t tau) => t__TApp (open_Tm_wrt_Tm_rec k t_5 t) tau
  | (t__Lam tau t) => t__Lam tau (open_Tm_wrt_Tm_rec (S k) t_5 t)
  | (t__TLam t) => t__TLam (open_Tm_wrt_Tm_rec k t_5 t)
end.

Fixpoint open_E_wrt_T_rec (k:nat) (tau5:T) (psi_5:E) {struct psi_5}: E :=
  match psi_5 with
  | E__Nil => E__Nil 
  | (E__A psi a) => E__A (open_E_wrt_T_rec k tau5 psi) a
  | (E__Var psi x sigma) => E__Var (open_E_wrt_T_rec k tau5 psi) x (open_Sc_wrt_T_rec k tau5 sigma)
  | (E__O psi t a sigma) => E__O (open_E_wrt_T_rec k tau5 psi) (open_Tm_wrt_T_rec k tau5 t) a (open_Sc_wrt_T_rec k tau5 sigma)
end.

Fixpoint open_E_wrt_Tm_rec (k:nat) (t5:Tm) (psi_5:E) {struct psi_5}: E :=
  match psi_5 with
  | E__Nil => E__Nil 
  | (E__A psi a) => E__A (open_E_wrt_Tm_rec k t5 psi) a
  | (E__Var psi x sigma) => E__Var (open_E_wrt_Tm_rec k t5 psi) x sigma
  | (E__O psi t a sigma) => E__O (open_E_wrt_Tm_rec k t5 psi) (open_Tm_wrt_Tm_rec k t5 t) a sigma
end.

Fixpoint open_Ex_wrt_Ex_rec (k:nat) (e_5:Ex) (e__6:Ex) {struct e__6}: Ex :=
  match e__6 with
  | (e__Var_b nat) => 
      match lt_eq_lt_dec nat k with
        | inleft (left _) => e__Var_b nat
        | inleft (right _) => e_5
        | inright _ => e__Var_b (nat - 1)
      end
  | (e__Var_f x) => e__Var_f x
  | e__Unit => e__Unit 
  | (e__App e1 e2) => e__App (open_Ex_wrt_Ex_rec k e_5 e1) (open_Ex_wrt_Ex_rec k e_5 e2)
  | (e__Lam e) => e__Lam (open_Ex_wrt_Ex_rec (S k) e_5 e)
  | (e__Let e1 e2) => e__Let (open_Ex_wrt_Ex_rec k e_5 e1) (open_Ex_wrt_Ex_rec (S k) e_5 e2)
end.

Definition open_Tm_wrt_Tm t_5 t__6 := open_Tm_wrt_Tm_rec 0 t__6 t_5.

Definition open_Sc_wrt_T tau5 sigma5 := open_Sc_wrt_T_rec 0 sigma5 tau5.

Definition open_E_wrt_T tau5 psi_5 := open_E_wrt_T_rec 0 psi_5 tau5.

Definition open_Tm_wrt_T tau5 t_5 := open_Tm_wrt_T_rec 0 t_5 tau5.

Definition open_E_wrt_Tm t5 psi_5 := open_E_wrt_Tm_rec 0 psi_5 t5.

Definition open_T_wrt_T tau_5 tau__6 := open_T_wrt_T_rec 0 tau__6 tau_5.

Definition open_Ex_wrt_Ex e_5 e__6 := open_Ex_wrt_Ex_rec 0 e__6 e_5.

(** closing up abstractions *)
Fixpoint close_T_wrt_T_rec (k:nat) (tau_5:var) (tau__6:T) {struct tau__6}: T :=
  match tau__6 with
  | (T__Var_b nat) => 
       if (lt_dec nat k) 
         then T__Var_b nat
         else T__Var_b (S nat)
  | (T__Var_f alpha) => if (tau_5 === alpha) then (T__Var_b k) else (T__Var_f alpha)
  | T__Unit => T__Unit 
  | T__Bool => T__Bool 
  | (T__Fun tau1 tau2) => T__Fun (close_T_wrt_T_rec k tau_5 tau1) (close_T_wrt_T_rec k tau_5 tau2)
end.

Fixpoint close_Tm_wrt_T_rec (k:nat) (tau5:var) (t_5:Tm) {struct t_5}: Tm :=
  match t_5 with
  | (t__Var_b nat) => t__Var_b nat
  | (t__Var_f tx) => t__Var_f tx
  | t__Unit => t__Unit 
  | t__True => t__True 
  | t__False => t__False 
  | (t__App t1 t2) => t__App (close_Tm_wrt_T_rec k tau5 t1) (close_Tm_wrt_T_rec k tau5 t2)
  | (t__TApp t tau) => t__TApp (close_Tm_wrt_T_rec k tau5 t) (close_T_wrt_T_rec k tau5 tau)
  | (t__Lam tau t) => t__Lam (close_T_wrt_T_rec k tau5 tau) (close_Tm_wrt_T_rec k tau5 t)
  | (t__TLam t) => t__TLam (close_Tm_wrt_T_rec (S k) tau5 t)
end.

Fixpoint close_Sc_wrt_T_rec (k:nat) (tau5:var) (sigma5:Sc) {struct sigma5}: Sc :=
  match sigma5 with
  | (S__T tau) => S__T (close_T_wrt_T_rec k tau5 tau)
  | (S__Forall sigma) => S__Forall (close_Sc_wrt_T_rec (S k) tau5 sigma)
end.

Fixpoint close_Tm_wrt_Tm_rec (k:nat) (t_5:var) (t__6:Tm) {struct t__6}: Tm :=
  match t__6 with
  | (t__Var_b nat) => 
       if (lt_dec nat k) 
         then t__Var_b nat
         else t__Var_b (S nat)
  | (t__Var_f tx) => if (t_5 === tx) then (t__Var_b k) else (t__Var_f tx)
  | t__Unit => t__Unit 
  | t__True => t__True 
  | t__False => t__False 
  | (t__App t1 t2) => t__App (close_Tm_wrt_Tm_rec k t_5 t1) (close_Tm_wrt_Tm_rec k t_5 t2)
  | (t__TApp t tau) => t__TApp (close_Tm_wrt_Tm_rec k t_5 t) tau
  | (t__Lam tau t) => t__Lam tau (close_Tm_wrt_Tm_rec (S k) t_5 t)
  | (t__TLam t) => t__TLam (close_Tm_wrt_Tm_rec k t_5 t)
end.

Fixpoint close_E_wrt_T_rec (k:nat) (tau5:var) (psi_5:E) {struct psi_5}: E :=
  match psi_5 with
  | E__Nil => E__Nil 
  | (E__A psi a) => E__A (close_E_wrt_T_rec k tau5 psi) a
  | (E__Var psi x sigma) => E__Var (close_E_wrt_T_rec k tau5 psi) x (close_Sc_wrt_T_rec k tau5 sigma)
  | (E__O psi t a sigma) => E__O (close_E_wrt_T_rec k tau5 psi) (close_Tm_wrt_T_rec k tau5 t) a (close_Sc_wrt_T_rec k tau5 sigma)
end.

Fixpoint close_E_wrt_Tm_rec (k:nat) (t5:var) (psi_5:E) {struct psi_5}: E :=
  match psi_5 with
  | E__Nil => E__Nil 
  | (E__A psi a) => E__A (close_E_wrt_Tm_rec k t5 psi) a
  | (E__Var psi x sigma) => E__Var (close_E_wrt_Tm_rec k t5 psi) x sigma
  | (E__O psi t a sigma) => E__O (close_E_wrt_Tm_rec k t5 psi) (close_Tm_wrt_Tm_rec k t5 t) a sigma
end.

Fixpoint close_Ex_wrt_Ex_rec (k:nat) (e_5:var) (e__6:Ex) {struct e__6}: Ex :=
  match e__6 with
  | (e__Var_b nat) => 
       if (lt_dec nat k) 
         then e__Var_b nat
         else e__Var_b (S nat)
  | (e__Var_f x) => if (e_5 === x) then (e__Var_b k) else (e__Var_f x)
  | e__Unit => e__Unit 
  | (e__App e1 e2) => e__App (close_Ex_wrt_Ex_rec k e_5 e1) (close_Ex_wrt_Ex_rec k e_5 e2)
  | (e__Lam e) => e__Lam (close_Ex_wrt_Ex_rec (S k) e_5 e)
  | (e__Let e1 e2) => e__Let (close_Ex_wrt_Ex_rec k e_5 e1) (close_Ex_wrt_Ex_rec (S k) e_5 e2)
end.

Definition close_Tm_wrt_Tm t__6 t_5 := close_Tm_wrt_Tm_rec 0 t__6 t_5.

Definition close_Sc_wrt_T sigma5 tau5 := close_Sc_wrt_T_rec 0 sigma5 tau5.

Definition close_E_wrt_T psi_5 tau5 := close_E_wrt_T_rec 0 psi_5 tau5.

Definition close_Tm_wrt_T t_5 tau5 := close_Tm_wrt_T_rec 0 t_5 tau5.

Definition close_E_wrt_Tm psi_5 t5 := close_E_wrt_Tm_rec 0 psi_5 t5.

Definition close_T_wrt_T tau__6 tau_5 := close_T_wrt_T_rec 0 tau__6 tau_5.

Definition close_Ex_wrt_Ex e__6 e_5 := close_Ex_wrt_Ex_rec 0 e__6 e_5.

(** terms are locally-closed pre-terms *)
(** definitions *)

(* defns LC_T *)
Inductive lc_T : T -> Prop :=    (* defn lc_T *)
 | lc_T__Var_f : forall (alpha:skvar),
     (lc_T (T__Var_f alpha))
 | lc_T__Unit : 
     (lc_T T__Unit)
 | lc_T__Bool : 
     (lc_T T__Bool)
 | lc_T__Fun : forall (tau1 tau2:T),
     (lc_T tau1) ->
     (lc_T tau2) ->
     (lc_T (T__Fun tau1 tau2)).

(* defns LC_Sc *)
Inductive lc_Sc : Sc -> Prop :=    (* defn lc_Sc *)
 | lc_S__T : forall (tau:T),
     (lc_T tau) ->
     (lc_Sc (S__T tau))
 | lc_S__Forall : forall (sigma:Sc),
      ( forall alpha , lc_Sc  ( open_Sc_wrt_T sigma (T__Var_f alpha) )  )  ->
     (lc_Sc (S__Forall sigma)).

(* defns LC_Tm *)
Inductive lc_Tm : Tm -> Prop :=    (* defn lc_Tm *)
 | lc_t__Var_f : forall (tx:tvar),
     (lc_Tm (t__Var_f tx))
 | lc_t__Unit : 
     (lc_Tm t__Unit)
 | lc_t__True : 
     (lc_Tm t__True)
 | lc_t__False : 
     (lc_Tm t__False)
 | lc_t__App : forall (t1 t2:Tm),
     (lc_Tm t1) ->
     (lc_Tm t2) ->
     (lc_Tm (t__App t1 t2))
 | lc_t__TApp : forall (t:Tm) (tau:T),
     (lc_Tm t) ->
     (lc_T tau) ->
     (lc_Tm (t__TApp t tau))
 | lc_t__Lam : forall (tau:T) (t:Tm),
     (lc_T tau) ->
      ( forall tx , lc_Tm  ( open_Tm_wrt_Tm t (t__Var_f tx) )  )  ->
     (lc_Tm (t__Lam tau t))
 | lc_t__TLam : forall (t:Tm),
      ( forall alpha , lc_Tm  ( open_Tm_wrt_T t (T__Var_f alpha) )  )  ->
     (lc_Tm (t__TLam t)).

(* defns LC_E *)
Inductive lc_E : E -> Prop :=    (* defn lc_E *)
 | lc_E__Nil : 
     (lc_E E__Nil)
 | lc_E__A : forall (psi:E) (a:A),
     (lc_E psi) ->
     (lc_E (E__A psi a))
 | lc_E__Var : forall (psi:E) (x:var) (sigma:Sc),
     (lc_E psi) ->
     (lc_Sc sigma) ->
     (lc_E (E__Var psi x sigma))
 | lc_E__O : forall (psi:E) (t:Tm) (a:A) (sigma:Sc),
     (lc_E psi) ->
     (lc_Tm t) ->
     (lc_Sc sigma) ->
     (lc_E (E__O psi t a sigma)).

(* defns LC_Ex *)
Inductive lc_Ex : Ex -> Prop :=    (* defn lc_Ex *)
 | lc_e__Var_f : forall (x:var),
     (lc_Ex (e__Var_f x))
 | lc_e__Unit : 
     (lc_Ex e__Unit)
 | lc_e__App : forall (e1 e2:Ex),
     (lc_Ex e1) ->
     (lc_Ex e2) ->
     (lc_Ex (e__App e1 e2))
 | lc_e__Lam : forall (e:Ex),
      ( forall x , lc_Ex  ( open_Ex_wrt_Ex e (e__Var_f x) )  )  ->
     (lc_Ex (e__Lam e))
 | lc_e__Let : forall (e1 e2:Ex),
     (lc_Ex e1) ->
      ( forall x , lc_Ex  ( open_Ex_wrt_Ex e2 (e__Var_f x) )  )  ->
     (lc_Ex (e__Let e1 e2)).
(** free variables *)
Fixpoint fsk_T (tau_5:T) : vars :=
  match tau_5 with
  | (T__Var_b nat) => {}
  | (T__Var_f alpha) => {{alpha}}
  | T__Unit => {}
  | T__Bool => {}
  | (T__Fun tau1 tau2) => (fsk_T tau1) \u (fsk_T tau2)
end.

Fixpoint ftv_Tm (t_5:Tm) : vars :=
  match t_5 with
  | (t__Var_b nat) => {}
  | (t__Var_f tx) => {{tx}}
  | t__Unit => {}
  | t__True => {}
  | t__False => {}
  | (t__App t1 t2) => (ftv_Tm t1) \u (ftv_Tm t2)
  | (t__TApp t tau) => (ftv_Tm t)
  | (t__Lam tau t) => (ftv_Tm t)
  | (t__TLam t) => (ftv_Tm t)
end.

Fixpoint fsk_Sc (sigma5:Sc) : vars :=
  match sigma5 with
  | (S__T tau) => (fsk_T tau)
  | (S__Forall sigma) => (fsk_Sc sigma)
end.

Fixpoint fsk_Tm (t_5:Tm) : vars :=
  match t_5 with
  | (t__Var_b nat) => {}
  | (t__Var_f tx) => {}
  | t__Unit => {}
  | t__True => {}
  | t__False => {}
  | (t__App t1 t2) => (fsk_Tm t1) \u (fsk_Tm t2)
  | (t__TApp t tau) => (fsk_Tm t) \u (fsk_T tau)
  | (t__Lam tau t) => (fsk_T tau) \u (fsk_Tm t)
  | (t__TLam t) => (fsk_Tm t)
end.

Fixpoint fv_Ex (e_5:Ex) : vars :=
  match e_5 with
  | (e__Var_b nat) => {}
  | (e__Var_f x) => {{x}}
  | e__Unit => {}
  | (e__App e1 e2) => (fv_Ex e1) \u (fv_Ex e2)
  | (e__Lam e) => (fv_Ex e)
  | (e__Let e1 e2) => (fv_Ex e1) \u (fv_Ex e2)
end.

Fixpoint ftv_E (psi_5:E) : vars :=
  match psi_5 with
  | E__Nil => {}
  | (E__A psi a) => (ftv_E psi)
  | (E__Var psi x sigma) => (ftv_E psi)
  | (E__O psi t a sigma) => (ftv_E psi) \u (ftv_Tm t)
end.

Fixpoint fsk_E (psi_5:E) : vars :=
  match psi_5 with
  | E__Nil => {}
  | (E__A psi a) => (fsk_E psi)
  | (E__Var psi x sigma) => (fsk_E psi) \u (fsk_Sc sigma)
  | (E__O psi t a sigma) => (fsk_E psi) \u (fsk_Tm t) \u (fsk_Sc sigma)
end.

(** substitutions *)
Fixpoint subst_skvar_T (tau_5:T) (alpha5:skvar) (tau__6:T) {struct tau__6} : T :=
  match tau__6 with
  | (T__Var_b nat) => T__Var_b nat
  | (T__Var_f alpha) => (if eq_var alpha alpha5 then tau_5 else (T__Var_f alpha))
  | T__Unit => T__Unit 
  | T__Bool => T__Bool 
  | (T__Fun tau1 tau2) => T__Fun (subst_skvar_T tau_5 alpha5 tau1) (subst_skvar_T tau_5 alpha5 tau2)
end.

Fixpoint subst_tvar_Tm (t_5:Tm) (tx5:tvar) (t__6:Tm) {struct t__6} : Tm :=
  match t__6 with
  | (t__Var_b nat) => t__Var_b nat
  | (t__Var_f tx) => (if eq_var tx tx5 then t_5 else (t__Var_f tx))
  | t__Unit => t__Unit 
  | t__True => t__True 
  | t__False => t__False 
  | (t__App t1 t2) => t__App (subst_tvar_Tm t_5 tx5 t1) (subst_tvar_Tm t_5 tx5 t2)
  | (t__TApp t tau) => t__TApp (subst_tvar_Tm t_5 tx5 t) tau
  | (t__Lam tau t) => t__Lam tau (subst_tvar_Tm t_5 tx5 t)
  | (t__TLam t) => t__TLam (subst_tvar_Tm t_5 tx5 t)
end.

Fixpoint subst_skvar_Sc (tau5:T) (alpha5:skvar) (sigma5:Sc) {struct sigma5} : Sc :=
  match sigma5 with
  | (S__T tau) => S__T (subst_skvar_T tau5 alpha5 tau)
  | (S__Forall sigma) => S__Forall (subst_skvar_Sc tau5 alpha5 sigma)
end.

Fixpoint subst_skvar_Tm (tau5:T) (alpha5:skvar) (t_5:Tm) {struct t_5} : Tm :=
  match t_5 with
  | (t__Var_b nat) => t__Var_b nat
  | (t__Var_f tx) => t__Var_f tx
  | t__Unit => t__Unit 
  | t__True => t__True 
  | t__False => t__False 
  | (t__App t1 t2) => t__App (subst_skvar_Tm tau5 alpha5 t1) (subst_skvar_Tm tau5 alpha5 t2)
  | (t__TApp t tau) => t__TApp (subst_skvar_Tm tau5 alpha5 t) (subst_skvar_T tau5 alpha5 tau)
  | (t__Lam tau t) => t__Lam (subst_skvar_T tau5 alpha5 tau) (subst_skvar_Tm tau5 alpha5 t)
  | (t__TLam t) => t__TLam (subst_skvar_Tm tau5 alpha5 t)
end.

Fixpoint subst_var_Ex (e_5:Ex) (x5:var) (e__6:Ex) {struct e__6} : Ex :=
  match e__6 with
  | (e__Var_b nat) => e__Var_b nat
  | (e__Var_f x) => (if eq_var x x5 then e_5 else (e__Var_f x))
  | e__Unit => e__Unit 
  | (e__App e1 e2) => e__App (subst_var_Ex e_5 x5 e1) (subst_var_Ex e_5 x5 e2)
  | (e__Lam e) => e__Lam (subst_var_Ex e_5 x5 e)
  | (e__Let e1 e2) => e__Let (subst_var_Ex e_5 x5 e1) (subst_var_Ex e_5 x5 e2)
end.

Fixpoint subst_tvar_E (t5:Tm) (tx5:tvar) (psi_5:E) {struct psi_5} : E :=
  match psi_5 with
  | E__Nil => E__Nil 
  | (E__A psi a) => E__A (subst_tvar_E t5 tx5 psi) a
  | (E__Var psi x sigma) => E__Var (subst_tvar_E t5 tx5 psi) x sigma
  | (E__O psi t a sigma) => E__O (subst_tvar_E t5 tx5 psi) (subst_tvar_Tm t5 tx5 t) a sigma
end.

Fixpoint subst_skvar_E (tau5:T) (alpha5:skvar) (psi_5:E) {struct psi_5} : E :=
  match psi_5 with
  | E__Nil => E__Nil 
  | (E__A psi a) => E__A (subst_skvar_E tau5 alpha5 psi) a
  | (E__Var psi x sigma) => E__Var (subst_skvar_E tau5 alpha5 psi) x (subst_skvar_Sc tau5 alpha5 sigma)
  | (E__O psi t a sigma) => E__O (subst_skvar_E tau5 alpha5 psi) (subst_skvar_Tm tau5 alpha5 t) a (subst_skvar_Sc tau5 alpha5 sigma)
end.


(*** Beginning of embedded section *)

Axiom SubSumpC : E -> Sc -> T -> Prop.

Fixpoint E_lookup (ψ:E) (x:var) : option Sc :=
  match ψ with
  | E__Nil => None
  | (E__Var ψ' y σ) => (if eq_var x y then Some σ else E_lookup ψ' x)
  | (E__A ψ' _ | E__O ψ' _ _ _ ) => E_lookup ψ' x
end.

(** never simpls *)
Arguments open_Tm_wrt_Tm _ _ : simpl never.
Arguments open_Sc_wrt_T _ _ : simpl never.
Arguments open_E_wrt_T _ _ : simpl never.
Arguments open_Tm_wrt_T _ _ : simpl never.
Arguments open_E_wrt_Tm _ _ : simpl never.
Arguments open_T_wrt_T _ _ : simpl never.
Arguments open_Ex_wrt_Ex _ _ : simpl never.

Definition Subx : Set := list (Tm * var).

(*** Substitution classes *)
(** substable *)
Class substable_name (X : Type) (In : Type) (Var : Type) := subst__x : In -> Var -> X -> X.

#[export] Instance substable_var_Ex : substable_name Ex Ex var := { subst__x := subst_var_Ex }.
#[export] Instance substable_var_Tm : substable_name Tm Tm var := { subst__x := subst_tvar_Tm }.
(*#[export] Instance substable_var_FTm : substable_name FTm FTm fvar := { subst__x := subst_fvar_FTm }.*)

Class substable (X : Type) (In : Type) (Var : Type) := subst : In -> Var -> X -> X.
#[export] Instance substable_skvar_Sc  : substable Sc  T skvar := { subst := subst_skvar_Sc  }.
#[export] Instance substable_skvar_T   : substable T   T skvar := { subst := subst_skvar_T   }.
(*#[export] Instance substable_skvar_FT  : substable FT  FT fskvar := { subst := subst_fskvar_FT   }.*)
#[export] Instance substable_skvar_Tm  : substable Tm  T skvar := { subst := subst_skvar_Tm  }.
(*#[export] Instance substable_skvar_FTm : substable FTm  FT fskvar := { subst := subst_fskvar_FTm  }.*)
#[export] Instance substable_skvar_E   : substable E   T skvar := { subst := subst_skvar_E   }.

Definition subst_skvar_Eqs (τ:T) (α:skvar) : Eqs -> Eqs := Lists.List.map (fun p => (subst τ α (fst p), subst τ α (snd p))).
#[export] Instance substable_skvar_Eqs : substable Eqs T skvar := { subst := subst_skvar_Eqs }.

Class lcable (X : Type) :=  lc : X -> Prop .
#[export] Instance lcable_Sc  : lcable Sc  := { lc := lc_Sc  }.
#[export] Instance lcable_T   : lcable T   := { lc := lc_T   }.
#[export] Instance lcable_Tm  : lcable Tm  := { lc := lc_Tm  }.
#[export] Instance lcable_Ex  : lcable Ex  := { lc := lc_Ex  }.


(** Sub_appable *)
Class Sub_appable (X : Type) := Sub_app : X -> Sub -> X.
Notation  "⟦ θ ▹ x ⟧"  := (Sub_app x θ) (at level 05, format "⟦ θ  ▹  x ⟧") : type_scope.

(** free vars *)
(* fsk *)
Class fskable (X : Type) := fsk : X -> vars.
Notation  "fv__α( x )"  := (fsk x) (at level 50, format "fv__α( x )") : type_scope.

#[export] Instance fskable_Sc : fskable Sc := { fsk := fsk_Sc }.
#[export] Instance fskable_T  : fskable T  := { fsk := fsk_T  }.
#[export] Instance fskable_Tm : fskable Tm := { fsk := fsk_Tm }.

(* fv *)
Class fvable (X : Type) := fv : X -> vars.
Notation  "fv__x( x )"  := (fv x) (at level 50, format "fv__x( x )") : type_scope.

#[export] Instance fvable_Ex : fvable Ex := { fv := fv_Ex }.
#[export] Instance fvable_Tm : fvable Tm := { fv := ftv_Tm }.

(** Other *)
Definition Sub_app_Tm : Tm -> Sub -> Tm := fold_right (uncurry subst).
Definition Sub_app_T : T -> Sub -> T := fold_right (uncurry subst).
Arguments Sub_app_T _ _ : simpl never.

#[export] Instance Sub_appable_T  : Sub_appable T  := { Sub_app := Sub_app_T  }.
#[export] Instance Sub_appable_Tm : Sub_appable Tm := { Sub_app := Sub_app_Tm }.

Fixpoint Sub_app_Sc (σ:Sc) (θ:Sub) : Sc :=
  match σ with
  | S__T      τ => S__T      ⟦θ ▹ τ⟧
  | S__Forall σ' => S__Forall (Sub_app_Sc σ' θ)
end.

#[export] Instance Sub_appable_Sc : Sub_appable Sc := { Sub_app := Sub_app_Sc }.

Set Warnings "-notation-overridden,-intuition-auto-with-star".

Open Scope program_scope.

Require Import Metalib.Metatheory.
Require Import Cpdtlib.CpdtTactics.
Require Import Coq.Relations.Relation_Operators.
Require Import Preamble.Buildins.
Require Import Preamble.WSfun.

(*** Judgment notation *)
Notation "•" := E__Nil (at level 1).

Notation "ψ ::a a" := (E__A ψ a) (at level 65).
Notation "ψ ::x x ':-' σ" := (E__Var ψ x σ) (at level 65).

Notation "ψ ::o ⦇ σ ⦈" := (E__O ψ t__Unit (nil:A) σ) (at level 65, format "ψ  ::o  ⦇ σ ⦈").
Notation "ψ ::o ⦇ t ▸ σ ⦈" := (E__O ψ t (nil:A) σ) (at level 65, format "ψ  ::o  ⦇ t  ▸  σ ⦈").
Notation "ψ ::o ⦇ t ▸ ⟨ a ⟩ σ ⦈" := (E__O ψ t a σ) (at level 65, format "ψ  ::o  ⦇ t  ▸  ⟨ a ⟩  σ ⦈").

Definition oneA (a:A) := E__A E__Nil a.
Definition oneX (x:var) (σ:Sc) := E__Var E__Nil x σ.
Definition oneO (t:Tm) (a:A) (σ:Sc) := E__O E__Nil t a σ.

Notation "< a >a" := (oneA a) (at level 1, format "< a >a").
Notation "< x :- σ >x" := (oneX x σ) (at level 1, format "< x  :-  σ >x").
Notation "< ⦇ t ▸ ⟨ a ⟩ σ ⦈ >o" := (oneO t a σ) (at level 1, format "< ⦇ t  ▸  ⟨ a ⟩  σ ⦈ >o").

Definition E_append_A_in_A (ψ:E) (a:A) : E :=
  match ψ with
  | • => oneA a
  | (ψ' ::a a') =>
      ψ' ::a (a ++ a')
  | (_ ::x _ :- _ | _ ::o ⦇_ ▸ ⟨_⟩ _⦈) =>
      ψ ::a a
end.

(*** Set modules *)
(** DecT *)
Module DecT <: Coq.Structures.DecidableType.DecidableType.
  Definition t := T.
  Definition eq : t -> t -> Prop := @Logic.eq t.

  Definition eq_refl  := @Logic.eq_refl  T.
  Definition eq_sym   := @Logic.eq_sym   T.
  Definition eq_trans := @Logic.eq_trans T.

  Definition eq_dec    := eq_T.
End DecT.

Module Export TSetI : WSfunPlus DecT := MakePlus DecT.
Notation TSet := TSetI.t.
Module Import TSetD := WDecide_fun DecT TSetI.

(** Sc *)
Module DecSc <: Coq.Structures.DecidableType.DecidableType.
  Definition t := Sc.
  Definition eq : t -> t -> Prop := @Logic.eq t.

  Definition eq_refl  := @Logic.eq_refl  Sc.
  Definition eq_sym   := @Logic.eq_sym   Sc.
  Definition eq_trans := @Logic.eq_trans Sc.

  Definition eq_dec    := eq_Sc.
End DecSc.

Module Export ScSetI : WSfunPlus DecSc := MakePlus DecSc.
Notation ScSet := ScSetI.t.
Module Import ScSetD := WDecide_fun DecSc ScSetI.

(** DecTm *)
Module DecTm <: Coq.Structures.DecidableType.DecidableType.
  Definition t := Tm.
  Definition eq : t -> t -> Prop := @Logic.eq t.

  Definition eq_refl  := @Logic.eq_refl  Tm.
  Definition eq_sym   := @Logic.eq_sym   Tm.
  Definition eq_trans := @Logic.eq_trans Tm.

  Definition eq_dec    := eq_Tm.
End DecTm.

Module Export TmSetI : WSfunPlus DecTm := MakePlus DecTm.
Notation TmSet := TmSetI.t.
Module Import TmSetD := WDecide_fun DecTm TmSetI.


(** Pair with T *)
Definition PairT := (T * atom)%type.
Definition eq_dec_PairT : forall (x y : PairT), {x = y} + {x <> y}.
Proof.
  intros. destruct x, y.
  destruct (TaggedAtom.eq_dec a a0). 2:right; congruence.
  destruct (eq_T t0 t1). 2:right; congruence.
  crush.
Qed.

Module DecPairT <: Coq.Structures.DecidableType.DecidableType.
  Definition t := PairT.
  Definition eq : t -> t -> Prop := @Logic.eq t.

  Definition eq_refl  := @Logic.eq_refl  t.
  Definition eq_sym   := @Logic.eq_sym   t.
  Definition eq_trans := @Logic.eq_trans t.

  Definition eq_dec    := eq_dec_PairT.
End DecPairT.

Module Export PairTSetI : WSfunPlus DecPairT := MakePlus DecPairT.
Notation PairTSet := PairTSetI.t.
Module Import PairTSetD := WDecide_fun DecPairT PairTSetI.

(** Pair with Sc *)
Definition PairSc := (Sc * atom)%type.
Definition eq_dec_PairSc : forall (x y : PairSc), {x = y} + {x <> y}.
Proof.
  intros. destruct x, y.
  destruct (TaggedAtom.eq_dec a a0). 2:right; congruence.
  destruct (eq_Sc s s0). 2:right; congruence.
  crush.
Qed.

Module DecPairSc <: Coq.Structures.DecidableType.DecidableType.
  Definition t := PairSc.
  Definition eq : t -> t -> Prop := @Logic.eq t.

  Definition eq_refl  := @Logic.eq_refl  t.
  Definition eq_sym   := @Logic.eq_sym   t.
  Definition eq_trans := @Logic.eq_trans t.

  Definition eq_dec    := eq_dec_PairSc.
End DecPairSc.

Module Export PairScSetI : WSfunPlus DecPairSc := MakePlus DecPairSc.
Notation PairScSet := PairScSetI.t.
Module Import PairScSetD := WDecide_fun DecPairSc PairScSetI.

(** Atoms *)
Module Export AtomSetProps := Preamble.WSfun.SetInterface TaggedAtom AtomSetImpl.

(** Notations *)
Notation remove   := AtomSetImpl.remove.
Notation remove__τ  := TSetI.remove.
Notation remove__σ  := ScSetI.remove.
Notation remove__t  := TmSetI.remove.
Notation remove__τx := PairTSetI.remove.
Notation remove__σx := PairScSetI.remove.

Notation empty   := AtomSetImpl.empty.
Notation empty__τ  := TSetI.empty.
Notation empty__σ  := ScSetI.empty.
Notation empty__t  := TmSetI.empty.
Notation empty__τx := PairTSetI.empty.
Notation empty__σx := PairScSetI.empty.
Notation "∅"   := empty   (at level 99, no associativity).
Notation "∅τ"  := empty__τ  (at level 99, no associativity).
Notation "∅σ"  := empty__σ  (at level 99, no associativity).
Notation "∅t"  := empty__t  (at level 99, no associativity).
Notation "∅τx" := empty__τx (at level 99, no associativity).
Notation "∅σx" := empty__σx (at level 99, no associativity).

Notation union   := AtomSetImpl.union.
Notation union__τ  := TSetI.union.
Notation union__σ  := ScSetI.union.
Notation union__t  := TmSetI.union.
Notation union__τx := PairTSetI.union.
Notation union__σx := PairScSetI.union.
Notation "L1 ∪ L2"   := (union   L1 L2) (at level 65, no associativity).
Notation "L1 ∪τ L2"  := (union__τ  L1 L2) (at level 65, no associativity).
Notation "L1 ∪σ L2"  := (union__σ  L1 L2) (at level 65, no associativity).
Notation "L1 ∪t L2"  := (union__t  L1 L2) (at level 65, no associativity).
Notation "L1 ∪τx L2" := (union__τx L1 L2) (at level 65, no associativity).
Notation "L1 ∪σx L2" := (union__σx L1 L2) (at level 65, no associativity).

Notation inter   := AtomSetImpl.inter.
Notation inter__τ  := TSetI.inter.
Notation inter__σ  := ScSetI.inter.
Notation inter__t  := TmSetI.inter.
Notation inter__τx := PairTSetI.inter.
Notation inter__σx := PairScSetI.inter.
Notation "L1 ∩ L2"   := (inter   L1 L2) (at level 65, no associativity).
Notation "L1 ∩τ L2"  := (inter__τ  L1 L2) (at level 65, no associativity).
Notation "L1 ∩σ L2"  := (inter__σ  L1 L2) (at level 65, no associativity).
Notation "L1 ∩t L2"  := (inter__t  L1 L2) (at level 65, no associativity).
Notation "L1 ∩τx L2" := (inter__τx L1 L2) (at level 65, no associativity).
Notation "L1 ∩σx L2" := (inter__σx L1 L2) (at level 65, no associativity).

Notation diff   := AtomSetImpl.diff.
Notation diff__τ  := TSetI.diff.
Notation diff__σ  := ScSetI.diff.
Notation diff__t  := TmSetI.diff.
Notation diff__τx := PairTSetI.diff.
Notation diff__σx := PairScSetI.diff.
Notation "L1 ∖ L2"   := (diff   L1 L2) (at level 65, no associativity).
Notation "L1 ∖τ L2"  := (diff__τ  L1 L2) (at level 65, no associativity).
Notation "L1 ∖σ L2"  := (diff__σ  L1 L2) (at level 65, no associativity).
Notation "L1 ∖t L2"  := (diff__t  L1 L2) (at level 65, no associativity).
Notation "L1 ∖τx L2" := (diff__τx L1 L2) (at level 65, no associativity).
Notation "L1 ∖σx L2" := (diff__σx L1 L2) (at level 65, no associativity).

Notation Equal   := AtomSetImpl.Equal.
Notation Equal__τ  := TSetI.Equal.
Notation Equal__σ  := ScSetI.Equal.
Notation Equal__t  := TmSetI.Equal.
Notation Equal__τx := PairTSetI.Equal.
Notation Equal__σx := PairScSetI.Equal.
Notation "L1 ≡ L2"   := (Equal   L1 L2) (at level 70, no associativity).
Notation "L1 ≡τ L2"  := (Equal__τ  L1 L2) (at level 70, no associativity).
Notation "L1 ≡σ L2"  := (Equal__σ  L1 L2) (at level 70, no associativity).
Notation "L1 ≡t L2"  := (Equal__t  L1 L2) (at level 70, no associativity).
Notation "L1 ≡τx L2" := (Equal__τx L1 L2) (at level 70, no associativity).
Notation "L1 ≡σx L2" := (Equal__σx L1 L2) (at level 70, no associativity).

Notation Subset   := AtomSetImpl.Subset.
Notation Subset__τ  := TSetI.Subset.
Notation Subset__σ  := ScSetI.Subset.
Notation Subset__t  := TmSetI.Subset.
Notation Subset__τx := PairTSetI.Subset.
Notation Subset__σx := PairScSetI.Subset.
Notation "L1 ⊆ L2"   := (Subset   L1 L2) (at level 70, no associativity).
Notation "L1 ⊆τ L2"  := (Subset__τ  L1 L2) (at level 70, no associativity).
Notation "L1 ⊆σ L2"  := (Subset__σ  L1 L2) (at level 70, no associativity).
Notation "L1 ⊆t L2"  := (Subset__t  L1 L2) (at level 70, no associativity).
Notation "L1 ⊆τx L2" := (Subset__τx L1 L2) (at level 70, no associativity).
Notation "L1 ⊆σx L2" := (Subset__σx L1 L2) (at level 70, no associativity).

Notation disjoint   := AtomSetImpl.disjoint.
Notation disjoint__τ  := TSetI.disjoint.
Notation disjoint__σ  := ScSetI.disjoint.
Notation disjoint__t  := TmSetI.disjoint.
Notation disjoint__τx := PairTSetI.disjoint.
Notation disjoint__σx := PairScSetI.disjoint.
Notation "L1 ∐ L2"   := (disjoint   L1 L2) (at level 70, no associativity).
Notation "L1 ∐τ L2"  := (disjoint__τ  L1 L2) (at level 70, no associativity).
Notation "L1 ∐σ L2"  := (disjoint__σ  L1 L2) (at level 70, no associativity).
Notation "L1 ∐t L2"  := (disjoint__t  L1 L2) (at level 70, no associativity).
Notation "L1 ∐τx L2" := (disjoint__τx L1 L2) (at level 70, no associativity).
Notation "L1 ∐σx L2" := (disjoint__σx L1 L2) (at level 70, no associativity).

Notation In   := AtomSetImpl.In.
Notation In__τ  := TSetI.In.
Notation In__σ  := ScSetI.In.
Notation In__t  := TmSetI.In.
Notation In__τx := PairTSetI.In.
Notation In__σx := PairScSetI.In.
Notation "x ∈ L"   := (In   x L) (at level 70, no associativity).
Notation "x ∈τ L"  := (In__τ  x L) (at level 70, no associativity).
Notation "x ∈σ L"  := (In__σ  x L) (at level 70, no associativity).
Notation "x ∈t L"  := (In__t  x L) (at level 70, no associativity).
Notation "x ∈τx L" := (In__τx x L) (at level 70, no associativity).
Notation "x ∈σx L" := (In__σx x L) (at level 70, no associativity).

Notation "x ∉ L"     := (~ AtomSetImpl.In x L)     (at level 70, no associativity).
Notation "x ∉τ L"    := (~ TSetI.In x L)           (at level 70, no associativity).
Notation "x ∉σ L"    := (~ ScSetI.In x L)          (at level 70, no associativity).
Notation "x ∉t L"    := (~ TmSetI.In x L)           (at level 70, no associativity).
Notation "x ∉τx L"   := (~ PairTSetI.In x L)       (at level 70, no associativity).
Notation "x ∉σx L"   := (~ PairScSetI.In x L)      (at level 70, no associativity).


(*** List_to_Set *)
Module Type List_to_Set_alg (E : DecidableType) (M : WSfun E).
  Parameter elt : Type.
  Parameter f : elt -> M.t.
End List_to_Set_alg.

(** Def *)
Module List_to_Set (E : DecidableType) (Import M : WSfun E) (Import Alg : List_to_Set_alg E M).
  Module Import Dec := WDecide_fun E M.
  Section List_to_Set.
    Definition List_to_Set : list elt -> M.t :=
      fold_right (M.union ∘ f) M.empty.

    Theorem List_to_Set_app : forall (l1 l2 : list elt),
        List_to_Set (l1 ++ l2) [=] union (List_to_Set l1) (List_to_Set l2).
    Proof. intros. induction l1. fsetdec. simpl. autorewrite with core. fsetdec. Qed.

    Theorem List_to_Set_singleton : forall (x : elt),
        List_to_Set [x] [=] f x.
    Proof. intros. simpl. autorewrite with core. fsetdec. Qed.

  End List_to_Set.
  #[export] Hint Rewrite List_to_Set_app       : List_to_Set.
  #[export] Hint Rewrite List_to_Set_singleton : List_to_Set.
End List_to_Set.

(** Using List_to_Set *)
Module Varl_alg <: List_to_Set_alg TaggedAtom AtomSetImpl.
  Definition elt := atom.
  Definition f : elt -> atoms := AtomSetImpl.singleton.
End Varl_alg.
#[export] Hint Unfold Varl_alg.elt Varl_alg.f : algs.

Module Export Varl := List_to_Set TaggedAtom AtomSetImpl Varl_alg.
Notation varl := Varl.List_to_Set.

Module bindings_Sub_alg <: List_to_Set_alg DecPairT PairTSetI.
  Definition elt := PairT.
  Definition f : PairT -> PairTSet := PairTSetI.singleton.
End bindings_Sub_alg.
#[export] Hint Unfold bindings_Sub_alg.elt bindings_Sub_alg.f : algs.
(* Fact bindings_Sub_alg_f_unfold : bindings_Sub_alg.f = PairTSetI.singleton. reflexivity. Qed. *)
(* #[export] Hint Rewrite bindings_Sub_alg_f_unfold : List_to_Set. *)

Module Export Bindings_Sub := List_to_Set DecPairT PairTSetI bindings_Sub_alg.
Notation bindings_Sub := Bindings_Sub.List_to_Set.


Module codom_Sub_alg <: List_to_Set_alg DecT TSetI.
  Definition elt := PairT.
  Definition f : elt -> TSet := (TSetI.singleton ∘ fst).
End codom_Sub_alg.
#[export] Hint Unfold codom_Sub_alg.elt codom_Sub_alg.f : algs.
(* Fact codom_Sub_alg_f_unfold : codom_Sub_alg.f = (Ssingleton ∘ fst). reflexivity. Qed. *)
(* #[export] Hint Rewrite codom_Sub_alg_f_unfold : List_to_Set. *)

Module Export Codom_Sub := List_to_Set DecT TSetI codom_Sub_alg.
Notation codom_Sub := Codom_Sub.List_to_Set.


Module skvars_codom_Sub_alg <: List_to_Set_alg TaggedAtom AtomSetImpl.
  Definition elt := PairT.
  Definition f : elt -> atoms := (fsk ∘ fst).
End skvars_codom_Sub_alg.
#[export] Hint Unfold skvars_codom_Sub_alg.elt skvars_codom_Sub_alg.f : algs.
(* Fact skvars_codom_Sub_alg_f_unfold : skvars_codom_Sub_alg.f = (fsk_T ∘ fst). reflexivity. Qed. *)
(* #[export] Hint Rewrite skvars_codom_Sub_alg_f_unfold : List_to_Set. *)

Module Export Skvars_codom_Sub := List_to_Set TaggedAtom AtomSetImpl skvars_codom_Sub_alg.
Notation skvars_codom_Sub := Skvars_codom_Sub.List_to_Set.


Module dom_Sub_alg <: List_to_Set_alg TaggedAtom AtomSetImpl.
  Definition elt := PairT.
  Definition f : elt -> atoms := (AtomSetImpl.singleton ∘ snd).
End dom_Sub_alg.
#[export] Hint Unfold dom_Sub_alg.elt dom_Sub_alg.f : algs.
(* Fact dom_Sub_alg_f_unfold : dom_Sub_alg.f = (Ssingleton ∘ snd). reflexivity. Qed. *)
(* #[export] Hint Rewrite dom_Sub_alg_f_unfold : List_to_Set. *)

Module Export dom_Sub := List_to_Set TaggedAtom AtomSetImpl dom_Sub_alg.
Notation dom_Sub := dom_Sub.List_to_Set.


Module codom_Subx_alg <: List_to_Set_alg DecTm TmSetI.
  Definition elt := (Tm * atom)%type.
  Definition f : elt -> TmSet := (TmSetI.singleton ∘ fst).
End codom_Subx_alg.
#[export] Hint Unfold codom_Subx_alg.elt codom_Subx_alg.f : algs.

Module Export Codom_Subx := List_to_Set DecTm TmSetI codom_Subx_alg.
Notation codom_Subx := Codom_Subx.List_to_Set.


Module dom_Subx_alg <: List_to_Set_alg TaggedAtom AtomSetImpl.
  Definition elt := (Tm * atom)%type.
  Definition f : elt -> atoms := (AtomSetImpl.singleton ∘ snd).
End dom_Subx_alg.
#[export] Hint Unfold dom_Subx_alg.elt dom_Subx_alg.f : algs.

Module Export dom_Subx := List_to_Set TaggedAtom AtomSetImpl dom_Subx_alg.
Notation dom_Subx := dom_Subx.List_to_Set.


(*** E_fold *)
(** Def *)
Section Sec_E_fold.
  Context {S : Type}.
  Variable s__nil :                   S.
  Variable f__a   : S -> A           -> S.
  Variable f__var : S -> var -> Sc    -> S.
  Variable f__obj : S -> Tm -> A -> Sc -> S.

  Fixpoint E_fold (ψ:E) : S :=
    match ψ with
      | E__Nil          => s__nil
      | E__A   ψ' a     => f__a   (E_fold ψ') a
      | E__Var ψ' x σ   => f__var (E_fold ψ') x σ
      | E__O ψ' τ a σ => f__obj (E_fold ψ') τ a σ
    end.
End Sec_E_fold.

(** Using E_fold*)
Definition const2 {A B C} (a : A) := fun (_ : B) (_ : C) => a.
Definition const3 {A B C D} (a : A) := fun (_ : B) (_ : C) (_ : D) => a.

Definition E__app : E -> E -> E := fun ψ1 =>
  E_fold ψ1 E__A E__Var E__O.
Notation "A +++ B" := (E__app A B) (at level 61, left associativity).

Fact E_norm_a : forall ψ a,
    ψ ::a a = ψ +++ < a >a.
Proof. reflexivity. Qed.
Fact E_norm_x : forall ψ x σ,
    ψ ::x x :- σ = ψ +++ < x :- σ >x.
Proof. reflexivity. Qed.
Fact E_norm_o : forall ψ t a σ,
    ψ ::o ⦇ t ▸ ⟨ a ⟩ σ ⦈ = ψ +++ < ⦇ t ▸ ⟨ a ⟩ σ ⦈ >o.
Proof. reflexivity. Qed.
#[export] Hint Rewrite E_norm_a E_norm_x E_norm_o : norm.

Tactic Notation "norm" :=
  autorewrite with norm.
Tactic Notation "norm" "in" hyp(H) :=
  autorewrite with norm in H.
Tactic Notation "norm" "in" "*" :=
  autorewrite with norm in *.

#[export] Hint Unfold Proper respectful impl flip : core.

(*** E to Set *)
(** Def *)
Module Type E_to_Set_alg (E : DecidableType) (M : WSfun E).
  Parameter f__a : A             -> M.t.
  Parameter f__x : var -> Sc      -> M.t.
  Parameter f__o : Tm -> A -> Sc    -> M.t.
End E_to_Set_alg.

Module E_to_Set (D : DecidableType) (Import M : WSfun D) (Import Alg : E_to_Set_alg D M).
  Module Import Dec := WDecide_fun D M.
  Definition E_to_Set : E -> t :=
    E_fold empty (flip (union ∘ f__a)) (fun L x σ => union L (f__x x σ)) (fun L τ a σ => union L (f__o τ a σ)).
  Fact E_to_Set_app : forall ψ1 ψ2,
      E_to_Set (ψ1 +++ ψ2) [=] union (E_to_Set ψ1) (E_to_Set ψ2).
  Proof. induction ψ2; simpl; autorewrite with core buildins; crush; fsetdec. Qed.
  #[export] Hint Rewrite E_to_Set_app : E_to_Set.

  (** Sub rel *)
  (* Def *)
  Definition R__sub (ψ1 ψ2:E) : Prop := E_to_Set ψ1 [<=] E_to_Set ψ2.
  #[local] Hint Unfold R__sub : core.

  (* Rewriting *)
  Fact sub_refl  : forall (ψ:E),
      R__sub ψ ψ.
    crush. Qed.
  Fact sub_trans : forall (ψ1 ψ2 ψ3:E),
      R__sub ψ1 ψ2
    -> R__sub ψ2 ψ3
    -> R__sub ψ1 ψ3.
    autounfold. fsetdec. Qed.
  #[local] Hint Resolve sub_refl : core.
  #[local] Hint Resolve sub_trans : slow.
  #[export] Instance sub_app_PreOrder : PreOrder R__sub. constructor; autounfold; crush. Qed.

  Fact sub_app : forall (ψ1 ψ2 ψ3 ψ4:E),
      R__sub  ψ1          ψ3
    -> R__sub         ψ2          ψ4
    -> R__sub (ψ1 +++ ψ2) (ψ3 +++ ψ4).
  Proof. autounfold. intros. autorewrite with E_to_Set. fsetdec. Qed.
  #[local] Hint Resolve sub_app : core.
  #[export] Instance sub_proper : Proper (R__sub ==> R__sub ==> R__sub) E__app. crush. Qed.

  (** Equivalence rel *)
  (* Def *)
  Definition R__eq  (ψ1 ψ2:E) : Prop := E_to_Set ψ1 [=] E_to_Set ψ2.
  #[local] Hint Unfold R__eq : core.

  (* Rewriting *)
  Fact eq_sub : forall (ψ1 ψ2:E),
      R__eq ψ1 ψ2
    -> R__sub ψ1 ψ2.
  Proof. autounfold. crush. Qed.
  #[export] Hint Resolve eq_sub : core.

  Fact eq_refl  : forall (ψ:E),
      R__eq ψ ψ.
    crush. Qed.
  Fact eq_trans : forall (ψ1 ψ2 ψ3:E),
      R__eq ψ1 ψ2
    -> R__eq ψ2 ψ3
    -> R__eq ψ1 ψ3.
    autounfold. fsetdec. Qed.
  Fact eq_symm : forall (ψ1 ψ2:E),
      R__eq ψ1 ψ2
    -> R__eq ψ2 ψ1.
    autounfold. fsetdec. Qed.
  #[local] Hint Resolve eq_refl eq_symm : core.
  #[local] Hint Resolve eq_trans : slow.
  #[export] Instance eq_app_PreOrder : Equivalence R__eq. constructor; autounfold; crush. Qed.

  Fact eq_app : forall (ψ1 ψ2 ψ3 ψ4:E),
      R__eq  ψ1          ψ3
    -> R__eq         ψ2          ψ4
    -> R__eq (ψ1 +++ ψ2) (ψ3 +++ ψ4).
  Proof. autounfold. intros. autorewrite with E_to_Set. fsetdec. Qed.
  #[export] Hint Resolve eq_app : core.
  #[export] Instance eq_proper : Proper (R__eq ==> R__eq ==> R__eq) E__app. crush. Qed.
End E_to_Set.

(** Using E to Set *)
Module E_A_skvars_alg <: E_to_Set_alg TaggedAtom AtomSetImpl.
  Definition f__a : A -> atoms
    := varl.
  Definition f__x : var -> Sc -> atoms
    := (const ∘ const) AtomSetImpl.empty.
  Definition f__o : Tm -> A -> Sc -> atoms
    := (const ∘ const ∘ const) AtomSetImpl.empty.
End E_A_skvars_alg.
#[export] Hint Unfold E_A_skvars_alg.f__a  E_A_skvars_alg.f__x E_A_skvars_alg.f__o : algs.

Module Export M_E_A_skvars := E_to_Set TaggedAtom AtomSetImpl E_A_skvars_alg.
Notation E_A_skvars := M_E_A_skvars.E_to_Set.

Module E_A_O_skvars_alg <: E_to_Set_alg TaggedAtom AtomSetImpl.
  Definition f__a : A -> atoms
    := varl.
  Definition f__x : var -> Sc -> atoms
    := (const ∘ const) AtomSetImpl.empty.
  Definition f__o : Tm -> A -> Sc -> atoms
    := fun _ a _ => varl a.
End E_A_O_skvars_alg.
#[export] Hint Unfold E_A_O_skvars_alg.f__a  E_A_O_skvars_alg.f__x E_A_O_skvars_alg.f__o : algs.

Module Export M_E_A_O_skvars := E_to_Set TaggedAtom AtomSetImpl E_A_O_skvars_alg.
Notation E_A_O_skvars := M_E_A_O_skvars.E_to_Set.

Module E_skvars_alg <: E_to_Set_alg TaggedAtom AtomSetImpl.
  Definition f__a : A -> atoms
    := varl.
  Definition f__x : var -> Sc -> atoms
    := fun _ σ => fv__α(σ).
  Definition f__o : Tm -> A -> Sc -> atoms
    := fun t a σ => fv__α(t) ∪ varl a ∪ fv__α(σ).
End E_skvars_alg.
#[export] Hint Unfold E_skvars_alg.f__a  E_skvars_alg.f__x E_skvars_alg.f__o : algs.

Module Export M_E_skvars := E_to_Set TaggedAtom AtomSetImpl E_skvars_alg.
Notation E_skvars := M_E_skvars.E_to_Set.

Module E_bindings_alg <: E_to_Set_alg DecPairSc PairScSetI.
  Definition f__a : A -> PairScSet
    := const PairScSetI.empty.
  Definition f__x : var -> Sc -> PairScSet
    := fun x sc => PairScSetI.singleton (sc, x).
  Definition f__o : Tm -> A -> Sc -> PairScSet
    := (const ∘ const ∘ const) PairScSetI.empty.
End E_bindings_alg.
#[export] Hint Unfold E_bindings_alg.f__a  E_bindings_alg.f__x E_bindings_alg.f__o : algs.

Module Export M_E_bindings := E_to_Set DecPairSc PairScSetI E_bindings_alg.
Notation E_bindings := M_E_bindings.E_to_Set.

Module E_schemes_alg <: E_to_Set_alg DecSc ScSetI.
  Definition f__a : A -> ScSet
    := const ScSetI.empty.
  Definition f__x : var -> Sc -> ScSet
    := fun _ sc => ScSetI.singleton sc.
  Definition f__o : Tm -> A -> Sc -> ScSet
    := (const ∘ const ∘ const) ScSetI.empty.
End E_schemes_alg.
#[export] Hint Unfold E_schemes_alg.f__a  E_schemes_alg.f__x E_schemes_alg.f__o : algs.

Module Export M_E_schemes := E_to_Set DecSc ScSetI E_schemes_alg.
Notation E_schemes := M_E_schemes.E_to_Set.

Module E_names_alg <: E_to_Set_alg TaggedAtom AtomSetImpl.
  Definition f__a : A -> atoms
    := const empty.
  Definition f__x : var -> Sc -> atoms
    := fun x sc => AtomSetImpl.singleton x.
  Definition f__o : Tm -> A -> Sc -> atoms
    := (const ∘ const ∘ const) empty.
End E_names_alg.
#[export] Hint Unfold E_names_alg.f__a  E_names_alg.f__x E_names_alg.f__o : algs.

Module Export M_E_names := E_to_Set TaggedAtom AtomSetImpl E_names_alg.
Notation E_names := M_E_names.E_to_Set.

Module E_O_names_alg <: E_to_Set_alg TaggedAtom AtomSetImpl.
  Definition f__a : A -> atoms
    := const empty.
  Definition f__x : var -> Sc -> atoms
    := fun x _ => AtomSetImpl.singleton x.
  Definition f__o : Tm -> A -> Sc -> atoms
    := fun t _ _ => fv(t).
End E_O_names_alg.
#[export] Hint Unfold E_O_names_alg.f__a  E_O_names_alg.f__x E_O_names_alg.f__o : algs.

Module Export M_E_O_names := E_to_Set TaggedAtom AtomSetImpl E_O_names_alg.
Notation E_O_names := M_E_O_names.E_to_Set.

Module E_t_names_alg <: E_to_Set_alg TaggedAtom AtomSetImpl.
  Definition f__a : A -> atoms
    := const empty.
  Definition f__x : var -> Sc -> atoms
    := const2 empty.
  Definition f__o : Tm -> A -> Sc -> atoms
    := fun t _ _ => fv__x(t).
End E_t_names_alg.
#[export] Hint Unfold E_t_names_alg.f__a  E_t_names_alg.f__x E_t_names_alg.f__o : algs.

Module Export M_E_t_names := E_to_Set TaggedAtom AtomSetImpl E_t_names_alg.
Notation E_t_names := M_E_t_names.E_to_Set.

(*** Defs *)
Definition close_Sc_wrt_A : Sc -> A -> Sc := fold_right (fun α σ => S__Forall (close_Sc_wrt_T α σ)).
Definition close_Tm_wrt_A : Tm -> A -> Tm := fold_right (fun α σ => t__TLam (close_Tm_wrt_T α σ)).

Require Import Metalib.Metatheory.

Fact if_refl_skvar : forall (α:skvar) (T:Type) (x y:T),
    (if eq_dec α α then x else y) = x.
Proof. intros. destruct (α == α); crush. Qed.
#[export] Hint Rewrite if_refl_skvar : if_simpl.

Definition FrA (a:A) (L:vars) : Prop :=
  NoDup a /\ varl a ∐ L.

Definition WfT (ψ:E) (τ:T) : Prop :=
    lc(τ) /\ fv__α(τ) ⊆ E_A_skvars ψ.
Definition WfS (ψ:E) (σ:Sc) : Prop :=
    lc(σ) /\ fv__α(σ) ⊆ E_A_skvars ψ.
Definition Wft (ψ:E) (t:Tm) : Prop :=
    lc(t) /\ fv__α( t ) ⊆ E_A_skvars ψ /\ fv__x( t ) ⊆ E_names ψ.

Notation  "e ⊢wfσ σ"  := (WfS e σ) (at level 50) : type_scope.
Notation  "e ⊢wfτ τ"  := (WfT e τ) (at level 50) : type_scope.
Notation  "e ⊢wft τ"  := (Wft e τ) (at level 50) : type_scope.

Inductive SubSump : E -> Sc -> T -> Prop :=    (* defn SubSump *)
 | SS__M : forall (ψ:E) (τ:T),
     SubSump ψ (S__T τ) τ
 | SS__L : forall (ψ:E) (σ:Sc) (τ1 τ2:T)
     (WFT: WfT ψ τ1)
     (SS:  SubSump ψ (open_Sc_wrt_T σ τ1) τ2),
     SubSump ψ (S__Forall σ) τ2.
#[export] Hint Constructors SubSump : core.

Inductive SubSumpTm : E -> Tm -> Sc -> Tm -> T -> Prop :=    (* defn SubSumpTm *)
 | SST__M : forall (ψ:E) (t:Tm) (τ:T),
     SubSumpTm ψ t (S__T τ) t τ
 | SST__L : forall (ψ:E) (t:Tm) (σ:Sc) (t':Tm) (τ1 τ2:T)
     (WFT: WfT ψ τ1)
     (SS:  SubSumpTm ψ (t__TApp t τ1)  (open_Sc_wrt_T σ τ1) t' τ2),
     SubSumpTm ψ t (S__Forall σ) t' τ2.
#[export] Hint Constructors SubSumpTm : core.

Inductive SubSumpTmA : E -> Tm -> Sc -> Tm -> A -> T -> Prop :=    (* defn SubSumpTm *)
 | SSTA__M : forall (ψ:E) (t:Tm) (τ:T) (a:A)
     (FR : FrA a (E_skvars ψ)),
     SubSumpTmA ψ t (S__T τ) t a τ
 | SSTA__L : forall (a1 a2:A) (ψ:E) (t:Tm) (σ:Sc) (t':Tm) (τ1 τ2:T)
     (FR: FrA a1 (E_skvars ψ))
     (WFT: WfT (ψ ::a a1) τ1)
     (SS:  SubSumpTmA (ψ ::a a1) (t__TApp t τ1)  (open_Sc_wrt_T σ τ1) t' a2 τ2),
     SubSumpTmA ψ t (S__Forall σ) t' (a1 ++ a2) τ2.
#[export] Hint Constructors SubSumpTmA : core.

Inductive SubSump' : E -> Sc -> Sc -> Prop :=    (* defn SubSumpTm *)
 | SS'__M : forall (ψ:E) (σ:Sc) (τ:T)
     (SS: SubSump ψ σ τ),
     SubSump' ψ σ (S__T τ)
 | SS'__R : forall (L:atoms) (ψ:E) (σ1:Sc) (σ2:Sc)
     (SS: (forall α, α ∉ L -> SubSump' (ψ ::a [α]) σ1 (open_Sc_wrt_T σ2 (T__Var_f α)))),
     SubSump' ψ σ1 (S__Forall σ2).
#[export] Hint Constructors SubSump' : core.

Inductive SubSumpTm' : E -> Tm -> Sc -> Tm -> Sc -> Prop :=    (* defn SubSumpTm *)
 | SST'__M : forall (ψ:E) (t__in:Tm) (σ:Sc) (t__out:Tm) (τ:T)
     (SS: SubSumpTm ψ t__in σ t__out τ),
     SubSumpTm' ψ t__in σ t__out (S__T τ)
 | SST'__R : forall (L:atoms) (ψ:E) (t1:Tm) (σ1:Sc) (t2:Tm) (σ2:Sc)
     (SS: (forall α, α ∉ L -> SubSumpTm' (ψ ::a [α]) t1 σ1 (open_Tm_wrt_T t2 (T__Var_f α)) (open_Sc_wrt_T σ2 (T__Var_f α)))),
     SubSumpTm' ψ t1 σ1 (t__TLam t2) (S__Forall σ2).
#[export] Hint Constructors SubSumpTm' : core.


Notation tag_of := TaggedAtom.tag_of.
Definition alg (x:var) := is_true (tag_of x).
Definition dec (x:var) := ~ is_true (tag_of x).

Definition alg_L (L:vars) := forall α, α ∈ L -> alg α.
Definition dec_L (L:vars) := forall α, α ∈ L -> dec α.

Definition alg_A (a:A) := alg_L (varl a).
Definition dec_A (a:A) := dec_L (varl a).

Definition alg_E (ψ:E) := alg_L (E_skvars ψ).
Definition dec_E (ψ:E) := dec_L (E_skvars ψ).

Inductive Inst : Tm -> Sc -> Tm -> A -> T -> vars -> Prop :=    (* defn Inst *)
 | InstM : forall (t:Tm) (τ:T) (L:vars),
     Inst t (S__T τ) t nil τ L
 | InstP : forall (α:skvar) (t1:Tm) (σ:Sc) (t2:Tm) (a:A) (τ:T) (L:vars)
     (NIL: α ∉ L)
     (ALG: alg alpha)
     (INST:  Inst (t__TApp t1 (T__Var_f α))  ( open_Sc_wrt_T σ (T__Var_f α) )  t2 a τ (L \u singleton α) ),
     Inst t1 (S__Forall σ) t2 (α :: a) τ L.
#[export] Hint Constructors Inst : core.


(*** End of embedded section *)


(** definitions *)

(* defns TermTyping *)
Inductive TmTy : E -> Tm -> Sc -> Prop :=    (* defn TmTy *)
 | TmTy__Var : forall (psi:E) (tx:tvar) (sigma:Sc)
     (IN:  (E_lookup  psi   tx  = Some  sigma  ) ),
     TmTy psi (t__Var_f tx) sigma
 | TmTy__Unit : forall (psi:E),
      True  ->
     TmTy psi t__Unit (S__T T__Unit)
 | TmTy__True : forall (psi:E),
      True  ->
     TmTy psi t__True (S__T T__Bool)
 | TmTy__False : forall (psi:E),
      True  ->
     TmTy psi t__False (S__T T__Bool)
 | TmTy__Abs : forall (L:vars) (psi:E) (tau1:T) (t:Tm) (tau2:T)
     (WFT:  ( psi  ⊢wfτ  tau1 ) )
     (TMTY:  ( forall tx , tx \notin  L  -> TmTy  (E__Var  psi   tx   (S__T tau1) )   ( open_Tm_wrt_Tm t (t__Var_f tx) )  (S__T tau2) ) ),
     TmTy psi (t__Lam tau1 t) (S__T (T__Fun tau1 tau2))
 | TmTy__App : forall (psi:E) (t1 t2:Tm) (tau2 tau1:T)
     (TMTY1: TmTy psi t1 (S__T (T__Fun tau1 tau2)))
     (TMTY2: TmTy psi t2 (S__T tau1)),
     TmTy psi (t__App t1 t2) (S__T tau2)
 | TmTy__TAbs : forall (L:vars) (psi:E) (t:Tm) (sigma:Sc)
     (TMTY:  ( forall alpha , alpha \notin  L  -> TmTy (E__A psi  (  alpha  :: nil ) )  ( open_Tm_wrt_T t (T__Var_f alpha) )   ( open_Sc_wrt_T sigma (T__Var_f alpha) )  ) ),
     TmTy psi (t__TLam t) (S__Forall sigma)
 | TmTy__TApp : forall (psi:E) (t:Tm) (tau:T) (sigma:Sc)
     (WFT:  ( psi  ⊢wfτ  tau ) )
     (TMTY: TmTy psi t (S__Forall sigma)),
     TmTy psi (t__TApp t tau)  ( open_Sc_wrt_T  sigma   tau  ) .

(* defns WellFormedness *)
Inductive WfE : E -> Prop :=    (* defn WfE *)
 | WfE__Nil : 
     WfE E__Nil
 | WfE__A : forall (psi:E) (A5:A)
     (WFE: WfE psi)
     (FR:  (FrA  A5    (E_skvars  psi )  ) ),
     WfE (E__A psi A5)
 | WfE__S : forall (psi:E) (x:var) (sigma:Sc)
     (WFE: WfE psi)
     (WFS:  ( psi  ⊢wfσ   sigma ) ),
      ( x  ∉ E_names  psi  )  ->
     WfE (E__Var psi x sigma)
 | WfE__O : forall (psi:E) (t:Tm) (a:A) (sigma:Sc)
     (WFE: WfE psi)
     (FR:  (FrA  a    (E_skvars  psi )  ) )
     (WFS:  ( (E__A psi a)  ⊢wfσ   sigma ) )
     (WFt:  ( (E__A psi a)  ⊢wft  t ) ),
     WfE (E__O psi t a sigma).

(* defns Unification *)
Inductive U : E -> T -> T -> E -> Prop :=    (* defn U *)
 | U__U : forall (psi1:E) (tau1 tau2:T) (psi2:E),
      ( (clos_refl_trans_1n (E * Eqs) Uss)   (  psi1  ,   ( ( tau1 , tau2 ) :: nil )   )     (  psi2  ,   nil   )   )  ->
     U psi1 tau1 tau2 psi2
with Uss : E_and_Eqs -> E_and_Eqs -> Prop :=    (* defn Uss *)
 | Uss__Unit : forall (psi:E) (eqs:Eqs),
      True  ->
     Uss  (  psi  ,   ( ( T__Unit , T__Unit ) ::  eqs  )   )   (  psi  ,  eqs  ) 
 | Uss__Ex : forall (psi:E) (alpha:skvar) (eqs:Eqs),
      True  ->
     Uss  (  psi  ,   ( ( (T__Var_f alpha) , (T__Var_f alpha) ) ::  eqs  )   )   (  psi  ,  eqs  ) 
 | Uss__Arr : forall (psi:E) (tau1 tau2 tau3 tau4:T) (eqs:Eqs),
      True  ->
      True  ->
      True  ->
      True  ->
      True  ->
     Uss  (  psi  ,   ( (  (T__Fun tau1 tau2)  ,  (T__Fun tau3 tau4)  ) ::  eqs  )   )   (  psi  ,   ( ( tau1 , tau3 ) ::   ( ( tau2 , tau4 ) ::  eqs  )   )   ) 
 | Uss__Split : forall (psi1:E) (a1:A) (alpha:skvar) (a2:A) (psi2:E) (tau1 tau2:T) (eqs:Eqs) (alpha1 alpha2:skvar) (tau3 tau4:T)
     (FR:  (FrA   ( cons  alpha2  ( alpha1  :: nil) )     (E_skvars   (E__app  (E__A psi1   (  a2  ++   ( cons  alpha   a1  )   )  )   psi2 )  )  ) ),
      ( alpha  ∉ fsk  (T__Fun tau3 tau4)  )  ->
      (alg  alpha1 )  ->
      (alg  alpha2 )  ->
      ( ( (T__Var_f alpha)  =  tau1  /\   (T__Fun tau3 tau4)   =  tau2 ) \/ ( (T__Var_f alpha)  =  tau2  /\   (T__Fun tau3 tau4)   =  tau1 ) )  ->
     Uss  (   (E__app  (E__A psi1   (  a2  ++   ( cons  alpha   a1  )   )  )   psi2 )   ,   ( ( tau1 , tau2 ) ::  eqs  )   )   (   (E__app  (E__A psi1   (  a2  ++   ( cons  alpha2    ( cons  alpha1   a1  )   )   )  )    ( subst  (T__Fun (T__Var_f alpha1) (T__Var_f alpha2))   alpha   psi2  )  )   ,   ( (  (T__Fun (T__Var_f alpha1) (T__Var_f alpha2))  ,  (T__Fun tau3 tau4)  ) ::   ( subst  (T__Fun (T__Var_f alpha1) (T__Var_f alpha2))   alpha   eqs  )   )   ) 
 | Uss__SubEx : forall (psi1:E) (a1:A) (beta:skvar) (a2:A) (psi2:E) (tau1 tau2:T) (eqs:Eqs) (alpha:skvar),
      True  ->
      ( alpha  ∈ (E_A_skvars  (E__A psi1 a1) ) )  ->
      ( ( (T__Var_f alpha)  =  tau1  /\  (T__Var_f beta)  =  tau2 ) \/ ( (T__Var_f alpha)  =  tau2  /\  (T__Var_f beta)  =  tau1 ) )  ->
     Uss  (   (E__app  (E__A psi1   (  a2  ++   ( cons  beta   a1  )   )  )   psi2 )   ,   ( ( tau1 , tau2 ) ::  eqs  )   )   (   (E__app  (E__A psi1   (  a2  ++  a1  )  )    ( subst  (T__Var_f alpha)   beta   psi2  )  )   ,   ( subst  (T__Var_f alpha)   beta   eqs  )   ) 
 | Uss__SubUnit : forall (psi1:E) (a1:A) (alpha:skvar) (a2:A) (psi2:E) (tau1 tau2:T) (eqs:Eqs),
      True  ->
      True  ->
      ( ( T__Unit  =  tau1  /\  (T__Var_f alpha)  =  tau2 ) \/ ( T__Unit  =  tau2  /\  (T__Var_f alpha)  =  tau1 ) )  ->
     Uss  (   (E__app  (E__A psi1   (  a2  ++   ( cons  alpha   a1  )   )  )   psi2 )   ,   ( ( tau1 , tau2 ) ::  eqs  )   )   (   (E__app  (E__A psi1   (  a2  ++  a1  )  )    ( subst  T__Unit   alpha   psi2  )  )   ,   ( subst  T__Unit   alpha   eqs  )   ) .

(* defns DeclarativeSystem *)
Inductive Dec : E -> Ex -> T -> Tm -> Prop :=    (* defn Dec *)
 | Dec__Var : forall (psi:E) (x:var) (tau:T) (t:Tm) (sigma:Sc)
     (IN:  (E_lookup  psi   x  = Some  sigma  ) )
     (SS:  (SubSumpTm  psi    (t__Var_f  x )    sigma   t   tau  ) ),
     Dec psi (e__Var_f x) tau t
 | Dec__Unit : forall (psi:E),
      True  ->
     Dec psi e__Unit T__Unit t__Unit
 | Dec__Abs : forall (L:vars) (psi:E) (e:Ex) (tau1 tau2:T) (t:Tm)
     (WFT:  ( psi  ⊢wfτ  tau1 ) )
     (DEC:  ( forall x , x \notin  L  -> Dec (E__Var psi x (S__T tau1))  ( open_Ex_wrt_Ex e (e__Var_f x) )  tau2  (open_Tm_wrt_Tm  t  (t__Var_f  x ))  ) ),
     Dec psi (e__Lam e) (T__Fun tau1 tau2)  (t__Lam  tau1   t ) 
 | Dec__App : forall (psi:E) (e1 e2:Ex) (tau2:T) (t1 t2:Tm) (tau1:T)
     (DEC1: Dec psi e1 (T__Fun tau1 tau2) t1)
     (DEC2: Dec psi e2 tau1 t2),
     Dec psi (e__App e1 e2) tau2 (t__App t1 t2)
 | Dec__Let : forall (L:vars) (psi:E) (e1 e2:Ex) (tau:T) (t2:Tm) (a:A) (t1:Tm) (tau1:T)
     (DEC1: Dec (E__A psi a) e1 tau1 t1)
     (DEC2:  ( forall x , x \notin  L  -> Dec (E__Var psi x  (close_Sc_wrt_A ( S__T  tau1  )  a ) )  ( open_Ex_wrt_Ex e2 (e__Var_f x) )  tau  (open_Tm_wrt_Tm  t2  (t__Var_f  x ))  ) ),
      (FrA  a    (E_skvars  psi )  )  ->
     Dec psi (e__Let e1 e2) tau  (open_Tm_wrt_Tm  t2     (close_Tm_wrt_A  t1   a )   ) 
with SS : E -> Tm -> Sc -> Tm -> A -> T -> Prop :=    (* defn SS *)
 | SubSumpASpec__M : forall (psi:E) (t:Tm) (tau:T),
     lc_E psi ->
     lc_Tm t ->
     lc_T tau ->
     SS psi t (S__T tau) t  nil  tau
 | SubSumpASpec__S : forall (psi:E) (t1:Tm) (sigma:Sc) (t2:Tm) (A1 A2:A) (tau:T) (a1:A)
     (WFT:  ( (E__A psi a1)  ⊢wfτ  tau ) ),
     SS (E__A psi a1) (t__TApp t1 tau)  ( open_Sc_wrt_T  sigma   tau  )  t2 A2 tau ->
     SS psi t1 (S__Forall sigma) t2  (  A2  ++  A1  )  tau
with DecA : E -> Ex -> A -> T -> Tm -> Prop :=    (* defn DecA *)
 | DecA__Var : forall (psi:E) (x:var) (a:A) (tau:T) (t:Tm) (sigma:Sc)
     (IN:  (E_lookup  psi   x  = Some  sigma  ) )
     (SS:  (SubSumpTmA  psi    (t__Var_f  x )    sigma   t   a   tau  ) ),
     DecA psi (e__Var_f x) a tau t
 | DecA__Unit : forall (psi:E) (a:A),
      (FrA  a    (E_skvars  psi )  )  ->
     DecA psi e__Unit a T__Unit t__Unit
 | DecA__Abs : forall (L:vars) (psi:E) (e:Ex) (a1 a2:A) (tau1 tau2:T) (t:Tm)
     (WFT:  ( (E__A psi a1)  ⊢wfτ  tau1 ) )
     (DEC:  ( forall x , x \notin  L  -> DecA (E__Var (E__A psi a1) x (S__T tau1))  ( open_Ex_wrt_Ex e (e__Var_f x) )  a2 tau2  (open_Tm_wrt_Tm  t  (t__Var_f  x ))  ) ),
      (FrA  a1    (E_skvars  psi )  )  ->
     DecA psi (e__Lam e)  (  a2  ++  a1  )  (T__Fun tau1 tau2)  (t__Lam  tau1   t ) 
 | DecA__App : forall (psi:E) (e1 e2:Ex) (a1 a2:A) (tau2:T) (t1 t2:Tm) (tau1:T)
     (DEC1: DecA psi e1 a1 (T__Fun tau1 tau2) t1)
     (DEC2: DecA (E__A psi a1) e2 a2 tau1 t2),
     DecA psi (e__App e1 e2)  (  a2  ++  a1  )  tau2 (t__App t1 t2)
 | DecA__Let : forall (L:vars) (psi:E) (e1 e2:Ex) (a2:A) (tau:T) (t2:Tm) (a1:A) (t1:Tm) (tau1:T)
     (DEC1: DecA psi e1 a1 tau1 t1)
     (DEC2:  ( forall x , x \notin  L  -> DecA  (E__O  (E__Var psi x  (close_Sc_wrt_A ( S__T  tau1  )  a1 ) )  t__Unit  a1  (S__T T__Unit))   ( open_Ex_wrt_Ex e2 (e__Var_f x) )  a2 tau  (open_Tm_wrt_Tm  t2  (t__Var_f  x ))  ) ),
     DecA psi (e__Let e1 e2) a2 tau  (open_Tm_wrt_Tm  t2     (close_Tm_wrt_A  t1   a1 )   ) .

(* defns AlgorithmicSystem *)
Inductive Inf : E -> Ex -> A -> T -> Tm -> E -> Prop :=    (* defn Inf *)
 | Inf__Var : forall (psi:E) (x:var) (a:A) (tau:T) (t:Tm) (sigma:Sc)
     (IN:  (E_lookup  psi   x  = Some  sigma  ) )
     (INST:  (Inst   (t__Var_f  x )    sigma   t   a   tau  (E_skvars  psi ) ) ),
     Inf psi (e__Var_f x) a tau t psi
 | Inf__Unit : forall (psi:E),
      True  ->
     Inf psi e__Unit  nil  T__Unit t__Unit psi
 | Inf__Abs : forall (L:vars) (psi__in:E) (e:Ex) (a1 a2:A) (tau1 tau2:T) (t:Tm) (psi__out:E) (alpha:skvar)
     (FR:  ( alpha  ∉ (E_skvars  psi__in )) )
     (ALG:  (alg  alpha ) )
     (INF:  ( forall x , x \notin  L  -> Inf (E__Var (E__A psi__in  (  alpha  :: nil ) ) x (S__T (T__Var_f alpha)))  ( open_Ex_wrt_Ex e (e__Var_f x) )  a2 tau2  (open_Tm_wrt_Tm  t  (t__Var_f  x ))  (E__Var (E__A psi__out a1) x (S__T tau1)) ) ),
     Inf psi__in (e__Lam e)  (  a2  ++  a1  )  (T__Fun tau1 tau2)  (t__Lam  tau1   t )  psi__out
 | Inf__App : forall (psi__in:E) (e1 e2:Ex) (a__out:A) (tau__out:T) (t__out:Tm) (psi__out:E) (a1:A) (tau:T) (t1:Tm) (psi1:E) (a2:A) (tau1:T) (t2:Tm) (psi2:E) (t1':Tm) (a1':A) (tau':T) (alpha:skvar)
     (INF1: Inf psi__in e1 a1 tau t1 psi1)
     (INF2: Inf (E__O psi1 t1 a1 (S__T tau)) e2 a2 tau1 t2 (E__O psi2 t1' a1' (S__T tau')))
     (FR:  ( alpha  ∉ (E_skvars  (E__A psi2   (  a2  ++  a1'  )  ) )) )
     (ALG:  (alg  alpha ) )
     (UNI: U  (E__O  (E__A psi2   (   ( cons  alpha   a2  )   ++  a1'  )  )   (t__App t1' t2)  (nil:A)  (S__T (T__Var_f alpha)) )  tau' (T__Fun tau1 (T__Var_f alpha))  (E__O  (E__A psi__out a__out)   t__out  (nil:A)  (S__T tau__out) ) ),
     Inf psi__in (e__App e1 e2) a__out tau__out t__out psi__out
 | Inf__Let : forall (L:vars) (psi__in:E) (e1 e2:Ex) (a2:A) (tau2:T) (t2 t1':Tm) (psiout:E) (a1:A) (tau:T) (t1:Tm) (psi1:E) (sigma__out:Sc) (a1':A)
     (INF1: Inf psi__in e1 a1 tau t1 psi1)
     (INF2:  ( forall x , x \notin  L  -> Inf  (E__O   (E__O  (E__Var psi1 x  (close_Sc_wrt_A ( S__T  tau  )  a1 ) )    (close_Tm_wrt_A  t1   a1 )   (nil:A) (S__T T__Unit))   t__Unit  a1  (S__T T__Unit))   ( open_Ex_wrt_Ex e2 (e__Var_f x) )  a2 tau2  (open_Tm_wrt_Tm  t2  (t__Var_f  x ))   (E__O   (E__O  (E__Var psiout x sigma__out)   t1'  (nil:A) (S__T T__Unit))   t__Unit  a1'  (S__T T__Unit))  ) ),
     Inf psi__in (e__Let e1 e2) a2 tau2  (open_Tm_wrt_Tm  t2   t1' )  psiout.

(* defns EironmentInstantiation *)
Inductive AInst : E -> A -> Sub -> Prop :=    (* defn AInst *)
 | AInst__Nil : forall (psi:E),
      True  ->
     AInst psi  nil   nil 
 | AInst__C : forall (psi:E) (a:A) (alpha:skvar) (tau:T) (theta2:Sub)
     (AINST: AInst psi a theta2)
     (WFT:  ( psi  ⊢wfτ  tau ) ),
     AInst psi  ( cons  alpha   a  )   ( (  tau ,  alpha  ) ::  theta2  ) 
with EInst : E -> Sub -> E -> E -> Sub -> Prop :=    (* defn EInst *)
 | EInst__Nil : forall (psi:E) (theta:Sub),
      True  ->
     EInst psi theta E__Nil E__Nil  nil 
 | EInst__A : forall (psi:E) (theta1:Sub) (psi__alg:E) (a__alg:A) (psi__dec:E) (a__dec:A) (theta3 theta2:Sub)
     (EINST: EInst psi theta1 psi__alg psi__dec theta2)
     (FR:  (FrA  a__dec    (E_skvars  psi__dec )  ) )
     (AINST: AInst  (E__app  psi   (E__A psi__dec a__dec) )  a__alg theta3),
     EInst psi theta1 (E__A psi__alg a__alg) (E__A psi__dec a__dec)  ( theta3  ++  theta2 ) 
 | EInst__S : forall (psi:E) (theta1:Sub) (psi__alg:E) (x:var) (sigma__alg:Sc) (psi__dec:E) (theta2:Sub)
     (EINST: EInst psi theta1 psi__alg psi__dec theta2),
      True  ->
     EInst psi theta1 (E__Var psi__alg x sigma__alg) (E__Var psi__dec x  ( ⟦    ( theta2  ++  theta1 )    ▹  sigma__alg  ⟧ ) ) theta2
 | EInst__O : forall (psi:E) (theta1:Sub) (psi__alg:E) (t__alg:Tm) (a__alg:A) (sigma__alg:Sc) (psi__dec:E) (theta3 theta2:Sub) (a__dec:A)
     (EINST: EInst psi theta1 psi__alg psi__dec theta2)
     (FR:  (FrA  a__dec    (E_skvars  psi__dec )  ) )
     (AINST: AInst  (E__app  psi   (E__A psi__dec a__dec) )  a__alg theta3),
      True  ->
      True  ->
     EInst psi theta1 (E__O psi__alg t__alg a__alg sigma__alg) (E__O psi__dec  ( ⟦    ( theta3  ++   ( theta2  ++  theta1 )  )    ▹  t__alg  ⟧ )  a__dec  ( ⟦    ( theta3  ++   ( theta2  ++  theta1 )  )    ▹  sigma__alg  ⟧ ) ) theta2
with EInstD : E -> Sub -> E -> E -> Sub -> Prop :=    (* defn EInstD *)
 | EInstD__Nil : forall (psi:E) (theta:Sub),
      True  ->
     EInstD psi theta E__Nil E__Nil  nil 
 | EInstD__A : forall (psi:E) (theta1:Sub) (psi__alg:E) (a__alg:A) (psi__dec:E) (a__dec:A) (theta3 theta2:Sub)
     (EINST: EInstD psi theta1 psi__alg psi__dec theta2)
     (FR:  (FrA  a__dec    (E_skvars  psi__dec )  ) )
     (DEC:  (dec_A  a__dec ) )
     (AINST: AInst  (E__app  psi   (E__A psi__dec a__dec) )  a__alg theta3),
     EInstD psi theta1 (E__A psi__alg a__alg) (E__A psi__dec a__dec)  ( theta3  ++  theta2 ) 
 | EInstD__S : forall (psi:E) (theta1:Sub) (psi__alg:E) (x:var) (sigma__alg:Sc) (psi__dec:E) (theta2:Sub)
     (EINST: EInstD psi theta1 psi__alg psi__dec theta2),
      True  ->
     EInstD psi theta1 (E__Var psi__alg x sigma__alg) (E__Var psi__dec x  ( ⟦    ( theta2  ++  theta1 )    ▹  sigma__alg  ⟧ ) ) theta2
 | EInstD__O : forall (psi:E) (theta1:Sub) (psi__alg:E) (t__alg:Tm) (a__alg:A) (sigma__alg:Sc) (psi__dec:E) (theta3 theta2:Sub) (a__dec:A)
     (EINST: EInstD psi theta1 psi__alg psi__dec theta2)
     (FR:  (FrA  a__dec    (E_skvars  psi__dec )  ) )
     (DEC:  (dec_A  a__dec ) )
     (AINST: AInst  (E__app  psi   (E__A psi__dec a__dec) )  a__alg theta3),
      True  ->
      True  ->
     EInstD psi theta1 (E__O psi__alg t__alg a__alg sigma__alg) (E__O psi__dec  ( ⟦    ( theta3  ++   ( theta2  ++  theta1 )  )    ▹  t__alg  ⟧ )  a__dec  ( ⟦    ( theta3  ++   ( theta2  ++  theta1 )  )    ▹  sigma__alg  ⟧ ) ) theta2.


(** infrastructure *)
#[export] Hint Constructors TmTy WfE U Uss Dec SS DecA Inf AInst EInst EInstD lc_T lc_Sc lc_Tm lc_E lc_Ex : core.



Require Import Coq.Arith.Wf_nat.
Require Import Coq.Logic.FunctionalExtensionality.
Require Import Coq.Program.Equality.

(** Roger: changed CoqLNOutput.hs to include -notation-overridden
 and put before HdmDefs import *)

Local Set Warnings "-non-recursive,-notation-overridden". 

Require Export Metalib.Metatheory.
Require Export Metalib.LibLNgen.

Require Export Defs.HdmLemsDeps.

(** NOTE: Auxiliary theorems are hidden in generated documentation.
    In general, there is a [_rec] version of every lemma involving
    [open] and [close]. *)


(* *********************************************************************** *)
(*defs removed*)
(** * Theorems about [size] *)

Ltac default_auto ::= auto with arith lngen; tauto.
Ltac default_autorewrite ::= fail.

(*hidden lems removed*)

Lemma size_Ex_min :
forall e1, 1 <= size_Ex e1.
Proof.
pose proof size_Ex_min_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve size_Ex_min : lngen.

(*hidden lems removed*)

Lemma size_T_min :
forall T1, 1 <= size_T T1.
Proof.
pose proof size_T_min_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve size_T_min : lngen.

(*hidden lems removed*)

Lemma size_Sc_min :
forall Sc1, 1 <= size_Sc Sc1.
Proof.
pose proof size_Sc_min_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve size_Sc_min : lngen.

(*hidden lems removed*)

Lemma size_Tm_min :
forall t1, 1 <= size_Tm t1.
Proof.
pose proof size_Tm_min_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve size_Tm_min : lngen.

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

Lemma size_Ex_close_Ex_wrt_Ex :
forall e1 x1,
  size_Ex (close_Ex_wrt_Ex x1 e1) = size_Ex e1.
Proof.
unfold close_Ex_wrt_Ex; default_simp.
Qed.

#[export] Hint Resolve size_Ex_close_Ex_wrt_Ex : lngen.
#[export] Hint Rewrite size_Ex_close_Ex_wrt_Ex using solve [auto] : lngen.

Lemma size_T_close_T_wrt_T :
forall T1 β1,
  size_T (close_T_wrt_T β1 T1) = size_T T1.
Proof.
unfold close_T_wrt_T; default_simp.
Qed.

#[export] Hint Resolve size_T_close_T_wrt_T : lngen.
#[export] Hint Rewrite size_T_close_T_wrt_T using solve [auto] : lngen.

Lemma size_Sc_close_Sc_wrt_T :
forall Sc1 β1,
  size_Sc (close_Sc_wrt_T β1 Sc1) = size_Sc Sc1.
Proof.
unfold close_Sc_wrt_T; default_simp.
Qed.

#[export] Hint Resolve size_Sc_close_Sc_wrt_T : lngen.
#[export] Hint Rewrite size_Sc_close_Sc_wrt_T using solve [auto] : lngen.

Lemma size_Tm_close_Tm_wrt_T :
forall t1 β1,
  size_Tm (close_Tm_wrt_T β1 t1) = size_Tm t1.
Proof.
unfold close_Tm_wrt_T; default_simp.
Qed.

#[export] Hint Resolve size_Tm_close_Tm_wrt_T : lngen.
#[export] Hint Rewrite size_Tm_close_Tm_wrt_T using solve [auto] : lngen.

Lemma size_Tm_close_Tm_wrt_Tm :
forall t1 tx1,
  size_Tm (close_Tm_wrt_Tm tx1 t1) = size_Tm t1.
Proof.
unfold close_Tm_wrt_Tm; default_simp.
Qed.

#[export] Hint Resolve size_Tm_close_Tm_wrt_Tm : lngen.
#[export] Hint Rewrite size_Tm_close_Tm_wrt_Tm using solve [auto] : lngen.

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

Lemma size_Ex_open_Ex_wrt_Ex :
forall e1 e2,
  size_Ex e1 <= size_Ex (open_Ex_wrt_Ex e1 e2).
Proof.
unfold open_Ex_wrt_Ex; default_simp.
Qed.

#[export] Hint Resolve size_Ex_open_Ex_wrt_Ex : lngen.

Lemma size_T_open_T_wrt_T :
forall T1 T2,
  size_T T1 <= size_T (open_T_wrt_T T1 T2).
Proof.
unfold open_T_wrt_T; default_simp.
Qed.

#[export] Hint Resolve size_T_open_T_wrt_T : lngen.

Lemma size_Sc_open_Sc_wrt_T :
forall Sc1 T1,
  size_Sc Sc1 <= size_Sc (open_Sc_wrt_T Sc1 T1).
Proof.
unfold open_Sc_wrt_T; default_simp.
Qed.

#[export] Hint Resolve size_Sc_open_Sc_wrt_T : lngen.

Lemma size_Tm_open_Tm_wrt_T :
forall t1 T1,
  size_Tm t1 <= size_Tm (open_Tm_wrt_T t1 T1).
Proof.
unfold open_Tm_wrt_T; default_simp.
Qed.

#[export] Hint Resolve size_Tm_open_Tm_wrt_T : lngen.

Lemma size_Tm_open_Tm_wrt_Tm :
forall t1 t2,
  size_Tm t1 <= size_Tm (open_Tm_wrt_Tm t1 t2).
Proof.
unfold open_Tm_wrt_Tm; default_simp.
Qed.

#[export] Hint Resolve size_Tm_open_Tm_wrt_Tm : lngen.

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

Lemma size_Ex_open_Ex_wrt_Ex_var :
forall e1 x1,
  size_Ex (open_Ex_wrt_Ex e1 (e__Var_f x1)) = size_Ex e1.
Proof.
unfold open_Ex_wrt_Ex; default_simp.
Qed.

#[export] Hint Resolve size_Ex_open_Ex_wrt_Ex_var : lngen.
#[export] Hint Rewrite size_Ex_open_Ex_wrt_Ex_var using solve [auto] : lngen.

Lemma size_T_open_T_wrt_T_var :
forall T1 β1,
  size_T (open_T_wrt_T T1 (T__Skvar_f β1)) = size_T T1.
Proof.
unfold open_T_wrt_T; default_simp.
Qed.

#[export] Hint Resolve size_T_open_T_wrt_T_var : lngen.
#[export] Hint Rewrite size_T_open_T_wrt_T_var using solve [auto] : lngen.

Lemma size_Sc_open_Sc_wrt_T_var :
forall Sc1 β1,
  size_Sc (open_Sc_wrt_T Sc1 (T__Skvar_f β1)) = size_Sc Sc1.
Proof.
unfold open_Sc_wrt_T; default_simp.
Qed.

#[export] Hint Resolve size_Sc_open_Sc_wrt_T_var : lngen.
#[export] Hint Rewrite size_Sc_open_Sc_wrt_T_var using solve [auto] : lngen.

Lemma size_Tm_open_Tm_wrt_T_var :
forall t1 β1,
  size_Tm (open_Tm_wrt_T t1 (T__Skvar_f β1)) = size_Tm t1.
Proof.
unfold open_Tm_wrt_T; default_simp.
Qed.

#[export] Hint Resolve size_Tm_open_Tm_wrt_T_var : lngen.
#[export] Hint Rewrite size_Tm_open_Tm_wrt_T_var using solve [auto] : lngen.

Lemma size_Tm_open_Tm_wrt_Tm_var :
forall t1 tx1,
  size_Tm (open_Tm_wrt_Tm t1 (t__Tvar_f tx1)) = size_Tm t1.
Proof.
unfold open_Tm_wrt_Tm; default_simp.
Qed.

#[export] Hint Resolve size_Tm_open_Tm_wrt_Tm_var : lngen.
#[export] Hint Rewrite size_Tm_open_Tm_wrt_Tm_var using solve [auto] : lngen.


(* *********************************************************************** *)
(** * Theorems about [degree] *)

Ltac default_auto ::= auto with lngen; tauto.
Ltac default_autorewrite ::= fail.

(*hidden lems removed*)

Lemma degree_Ex_wrt_Ex_S :
forall n1 e1,
  degree_Ex_wrt_Ex n1 e1 ->
  degree_Ex_wrt_Ex (S n1) e1.
Proof.
pose proof degree_Ex_wrt_Ex_S_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve degree_Ex_wrt_Ex_S : lngen.

(*hidden lems removed*)

Lemma degree_T_wrt_T_S :
forall n1 T1,
  degree_T_wrt_T n1 T1 ->
  degree_T_wrt_T (S n1) T1.
Proof.
pose proof degree_T_wrt_T_S_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve degree_T_wrt_T_S : lngen.

(*hidden lems removed*)

Lemma degree_Sc_wrt_T_S :
forall n1 Sc1,
  degree_Sc_wrt_T n1 Sc1 ->
  degree_Sc_wrt_T (S n1) Sc1.
Proof.
pose proof degree_Sc_wrt_T_S_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve degree_Sc_wrt_T_S : lngen.

(*hidden lems removed*)

Lemma degree_Tm_wrt_T_S :
forall n1 t1,
  degree_Tm_wrt_T n1 t1 ->
  degree_Tm_wrt_T (S n1) t1.
Proof.
pose proof degree_Tm_wrt_T_S_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve degree_Tm_wrt_T_S : lngen.

(*hidden lems removed*)

Lemma degree_Tm_wrt_Tm_S :
forall n1 t1,
  degree_Tm_wrt_Tm n1 t1 ->
  degree_Tm_wrt_Tm (S n1) t1.
Proof.
pose proof degree_Tm_wrt_Tm_S_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve degree_Tm_wrt_Tm_S : lngen.

Lemma degree_Ex_wrt_Ex_O :
forall n1 e1,
  degree_Ex_wrt_Ex O e1 ->
  degree_Ex_wrt_Ex n1 e1.
Proof.
induction n1; default_simp.
Qed.

#[export] Hint Resolve degree_Ex_wrt_Ex_O : lngen.

Lemma degree_T_wrt_T_O :
forall n1 T1,
  degree_T_wrt_T O T1 ->
  degree_T_wrt_T n1 T1.
Proof.
induction n1; default_simp.
Qed.

#[export] Hint Resolve degree_T_wrt_T_O : lngen.

Lemma degree_Sc_wrt_T_O :
forall n1 Sc1,
  degree_Sc_wrt_T O Sc1 ->
  degree_Sc_wrt_T n1 Sc1.
Proof.
induction n1; default_simp.
Qed.

#[export] Hint Resolve degree_Sc_wrt_T_O : lngen.

Lemma degree_Tm_wrt_T_O :
forall n1 t1,
  degree_Tm_wrt_T O t1 ->
  degree_Tm_wrt_T n1 t1.
Proof.
induction n1; default_simp.
Qed.

#[export] Hint Resolve degree_Tm_wrt_T_O : lngen.

Lemma degree_Tm_wrt_Tm_O :
forall n1 t1,
  degree_Tm_wrt_Tm O t1 ->
  degree_Tm_wrt_Tm n1 t1.
Proof.
induction n1; default_simp.
Qed.

#[export] Hint Resolve degree_Tm_wrt_Tm_O : lngen.

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

Lemma degree_Ex_wrt_Ex_close_Ex_wrt_Ex :
forall e1 x1,
  degree_Ex_wrt_Ex 0 e1 ->
  degree_Ex_wrt_Ex 1 (close_Ex_wrt_Ex x1 e1).
Proof.
unfold close_Ex_wrt_Ex; default_simp.
Qed.

#[export] Hint Resolve degree_Ex_wrt_Ex_close_Ex_wrt_Ex : lngen.

Lemma degree_T_wrt_T_close_T_wrt_T :
forall T1 β1,
  degree_T_wrt_T 0 T1 ->
  degree_T_wrt_T 1 (close_T_wrt_T β1 T1).
Proof.
unfold close_T_wrt_T; default_simp.
Qed.

#[export] Hint Resolve degree_T_wrt_T_close_T_wrt_T : lngen.

Lemma degree_Sc_wrt_T_close_Sc_wrt_T :
forall Sc1 β1,
  degree_Sc_wrt_T 0 Sc1 ->
  degree_Sc_wrt_T 1 (close_Sc_wrt_T β1 Sc1).
Proof.
unfold close_Sc_wrt_T; default_simp.
Qed.

#[export] Hint Resolve degree_Sc_wrt_T_close_Sc_wrt_T : lngen.

Lemma degree_Tm_wrt_T_close_Tm_wrt_T :
forall t1 β1,
  degree_Tm_wrt_T 0 t1 ->
  degree_Tm_wrt_T 1 (close_Tm_wrt_T β1 t1).
Proof.
unfold close_Tm_wrt_T; default_simp.
Qed.

#[export] Hint Resolve degree_Tm_wrt_T_close_Tm_wrt_T : lngen.

Lemma degree_Tm_wrt_T_close_Tm_wrt_Tm :
forall t1 tx1 n1,
  degree_Tm_wrt_T n1 t1 ->
  degree_Tm_wrt_T n1 (close_Tm_wrt_Tm tx1 t1).
Proof.
unfold close_Tm_wrt_Tm; default_simp.
Qed.

#[export] Hint Resolve degree_Tm_wrt_T_close_Tm_wrt_Tm : lngen.

Lemma degree_Tm_wrt_Tm_close_Tm_wrt_T :
forall t1 β1 n1,
  degree_Tm_wrt_Tm n1 t1 ->
  degree_Tm_wrt_Tm n1 (close_Tm_wrt_T β1 t1).
Proof.
unfold close_Tm_wrt_T; default_simp.
Qed.

#[export] Hint Resolve degree_Tm_wrt_Tm_close_Tm_wrt_T : lngen.

Lemma degree_Tm_wrt_Tm_close_Tm_wrt_Tm :
forall t1 tx1,
  degree_Tm_wrt_Tm 0 t1 ->
  degree_Tm_wrt_Tm 1 (close_Tm_wrt_Tm tx1 t1).
Proof.
unfold close_Tm_wrt_Tm; default_simp.
Qed.

#[export] Hint Resolve degree_Tm_wrt_Tm_close_Tm_wrt_Tm : lngen.

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

Lemma degree_Ex_wrt_Ex_close_Ex_wrt_Ex_inv :
forall e1 x1,
  degree_Ex_wrt_Ex 1 (close_Ex_wrt_Ex x1 e1) ->
  degree_Ex_wrt_Ex 0 e1.
Proof.
unfold close_Ex_wrt_Ex; eauto with lngen.
Qed.

#[export] Hint Immediate degree_Ex_wrt_Ex_close_Ex_wrt_Ex_inv : lngen.

Lemma degree_T_wrt_T_close_T_wrt_T_inv :
forall T1 β1,
  degree_T_wrt_T 1 (close_T_wrt_T β1 T1) ->
  degree_T_wrt_T 0 T1.
Proof.
unfold close_T_wrt_T; eauto with lngen.
Qed.

#[export] Hint Immediate degree_T_wrt_T_close_T_wrt_T_inv : lngen.

Lemma degree_Sc_wrt_T_close_Sc_wrt_T_inv :
forall Sc1 β1,
  degree_Sc_wrt_T 1 (close_Sc_wrt_T β1 Sc1) ->
  degree_Sc_wrt_T 0 Sc1.
Proof.
unfold close_Sc_wrt_T; eauto with lngen.
Qed.

#[export] Hint Immediate degree_Sc_wrt_T_close_Sc_wrt_T_inv : lngen.

Lemma degree_Tm_wrt_T_close_Tm_wrt_T_inv :
forall t1 β1,
  degree_Tm_wrt_T 1 (close_Tm_wrt_T β1 t1) ->
  degree_Tm_wrt_T 0 t1.
Proof.
unfold close_Tm_wrt_T; eauto with lngen.
Qed.

#[export] Hint Immediate degree_Tm_wrt_T_close_Tm_wrt_T_inv : lngen.

Lemma degree_Tm_wrt_T_close_Tm_wrt_Tm_inv :
forall t1 tx1 n1,
  degree_Tm_wrt_T n1 (close_Tm_wrt_Tm tx1 t1) ->
  degree_Tm_wrt_T n1 t1.
Proof.
unfold close_Tm_wrt_Tm; eauto with lngen.
Qed.

#[export] Hint Immediate degree_Tm_wrt_T_close_Tm_wrt_Tm_inv : lngen.

Lemma degree_Tm_wrt_Tm_close_Tm_wrt_T_inv :
forall t1 β1 n1,
  degree_Tm_wrt_Tm n1 (close_Tm_wrt_T β1 t1) ->
  degree_Tm_wrt_Tm n1 t1.
Proof.
unfold close_Tm_wrt_T; eauto with lngen.
Qed.

#[export] Hint Immediate degree_Tm_wrt_Tm_close_Tm_wrt_T_inv : lngen.

Lemma degree_Tm_wrt_Tm_close_Tm_wrt_Tm_inv :
forall t1 tx1,
  degree_Tm_wrt_Tm 1 (close_Tm_wrt_Tm tx1 t1) ->
  degree_Tm_wrt_Tm 0 t1.
Proof.
unfold close_Tm_wrt_Tm; eauto with lngen.
Qed.

#[export] Hint Immediate degree_Tm_wrt_Tm_close_Tm_wrt_Tm_inv : lngen.

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

Lemma degree_Ex_wrt_Ex_open_Ex_wrt_Ex :
forall e1 e2,
  degree_Ex_wrt_Ex 1 e1 ->
  degree_Ex_wrt_Ex 0 e2 ->
  degree_Ex_wrt_Ex 0 (open_Ex_wrt_Ex e1 e2).
Proof.
unfold open_Ex_wrt_Ex; default_simp.
Qed.

#[export] Hint Resolve degree_Ex_wrt_Ex_open_Ex_wrt_Ex : lngen.

Lemma degree_T_wrt_T_open_T_wrt_T :
forall T1 T2,
  degree_T_wrt_T 1 T1 ->
  degree_T_wrt_T 0 T2 ->
  degree_T_wrt_T 0 (open_T_wrt_T T1 T2).
Proof.
unfold open_T_wrt_T; default_simp.
Qed.

#[export] Hint Resolve degree_T_wrt_T_open_T_wrt_T : lngen.

Lemma degree_Sc_wrt_T_open_Sc_wrt_T :
forall Sc1 T1,
  degree_Sc_wrt_T 1 Sc1 ->
  degree_T_wrt_T 0 T1 ->
  degree_Sc_wrt_T 0 (open_Sc_wrt_T Sc1 T1).
Proof.
unfold open_Sc_wrt_T; default_simp.
Qed.

#[export] Hint Resolve degree_Sc_wrt_T_open_Sc_wrt_T : lngen.

Lemma degree_Tm_wrt_T_open_Tm_wrt_T :
forall t1 T1,
  degree_Tm_wrt_T 1 t1 ->
  degree_T_wrt_T 0 T1 ->
  degree_Tm_wrt_T 0 (open_Tm_wrt_T t1 T1).
Proof.
unfold open_Tm_wrt_T; default_simp.
Qed.

#[export] Hint Resolve degree_Tm_wrt_T_open_Tm_wrt_T : lngen.

Lemma degree_Tm_wrt_T_open_Tm_wrt_Tm :
forall t1 t2 n1,
  degree_Tm_wrt_T n1 t1 ->
  degree_Tm_wrt_T n1 t2 ->
  degree_Tm_wrt_T n1 (open_Tm_wrt_Tm t1 t2).
Proof.
unfold open_Tm_wrt_Tm; default_simp.
Qed.

#[export] Hint Resolve degree_Tm_wrt_T_open_Tm_wrt_Tm : lngen.

Lemma degree_Tm_wrt_Tm_open_Tm_wrt_T :
forall t1 T1 n1,
  degree_Tm_wrt_Tm n1 t1 ->
  degree_Tm_wrt_Tm n1 (open_Tm_wrt_T t1 T1).
Proof.
unfold open_Tm_wrt_T; default_simp.
Qed.

#[export] Hint Resolve degree_Tm_wrt_Tm_open_Tm_wrt_T : lngen.

Lemma degree_Tm_wrt_Tm_open_Tm_wrt_Tm :
forall t1 t2,
  degree_Tm_wrt_Tm 1 t1 ->
  degree_Tm_wrt_Tm 0 t2 ->
  degree_Tm_wrt_Tm 0 (open_Tm_wrt_Tm t1 t2).
Proof.
unfold open_Tm_wrt_Tm; default_simp.
Qed.

#[export] Hint Resolve degree_Tm_wrt_Tm_open_Tm_wrt_Tm : lngen.

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

Lemma degree_Ex_wrt_Ex_open_Ex_wrt_Ex_inv :
forall e1 e2,
  degree_Ex_wrt_Ex 0 (open_Ex_wrt_Ex e1 e2) ->
  degree_Ex_wrt_Ex 1 e1.
Proof.
unfold open_Ex_wrt_Ex; eauto with lngen.
Qed.

#[export] Hint Immediate degree_Ex_wrt_Ex_open_Ex_wrt_Ex_inv : lngen.

Lemma degree_T_wrt_T_open_T_wrt_T_inv :
forall T1 T2,
  degree_T_wrt_T 0 (open_T_wrt_T T1 T2) ->
  degree_T_wrt_T 1 T1.
Proof.
unfold open_T_wrt_T; eauto with lngen.
Qed.

#[export] Hint Immediate degree_T_wrt_T_open_T_wrt_T_inv : lngen.

Lemma degree_Sc_wrt_T_open_Sc_wrt_T_inv :
forall Sc1 T1,
  degree_Sc_wrt_T 0 (open_Sc_wrt_T Sc1 T1) ->
  degree_Sc_wrt_T 1 Sc1.
Proof.
unfold open_Sc_wrt_T; eauto with lngen.
Qed.

#[export] Hint Immediate degree_Sc_wrt_T_open_Sc_wrt_T_inv : lngen.

Lemma degree_Tm_wrt_T_open_Tm_wrt_T_inv :
forall t1 T1,
  degree_Tm_wrt_T 0 (open_Tm_wrt_T t1 T1) ->
  degree_Tm_wrt_T 1 t1.
Proof.
unfold open_Tm_wrt_T; eauto with lngen.
Qed.

#[export] Hint Immediate degree_Tm_wrt_T_open_Tm_wrt_T_inv : lngen.

Lemma degree_Tm_wrt_T_open_Tm_wrt_Tm_inv :
forall t1 t2 n1,
  degree_Tm_wrt_T n1 (open_Tm_wrt_Tm t1 t2) ->
  degree_Tm_wrt_T n1 t1.
Proof.
unfold open_Tm_wrt_Tm; eauto with lngen.
Qed.

#[export] Hint Immediate degree_Tm_wrt_T_open_Tm_wrt_Tm_inv : lngen.

Lemma degree_Tm_wrt_Tm_open_Tm_wrt_T_inv :
forall t1 T1 n1,
  degree_Tm_wrt_Tm n1 (open_Tm_wrt_T t1 T1) ->
  degree_Tm_wrt_Tm n1 t1.
Proof.
unfold open_Tm_wrt_T; eauto with lngen.
Qed.

#[export] Hint Immediate degree_Tm_wrt_Tm_open_Tm_wrt_T_inv : lngen.

Lemma degree_Tm_wrt_Tm_open_Tm_wrt_Tm_inv :
forall t1 t2,
  degree_Tm_wrt_Tm 0 (open_Tm_wrt_Tm t1 t2) ->
  degree_Tm_wrt_Tm 1 t1.
Proof.
unfold open_Tm_wrt_Tm; eauto with lngen.
Qed.

#[export] Hint Immediate degree_Tm_wrt_Tm_open_Tm_wrt_Tm_inv : lngen.


(* *********************************************************************** *)
(** * Theorems about [open] and [close] *)

Ltac default_auto ::= auto with lngen brute_force; tauto.
Ltac default_autorewrite ::= fail.

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

Lemma close_Ex_wrt_Ex_inj :
forall e1 e2 x1,
  close_Ex_wrt_Ex x1 e1 = close_Ex_wrt_Ex x1 e2 ->
  e1 = e2.
Proof.
unfold close_Ex_wrt_Ex; eauto with lngen.
Qed.

#[export] Hint Immediate close_Ex_wrt_Ex_inj : lngen.

Lemma close_T_wrt_T_inj :
forall T1 T2 β1,
  close_T_wrt_T β1 T1 = close_T_wrt_T β1 T2 ->
  T1 = T2.
Proof.
unfold close_T_wrt_T; eauto with lngen.
Qed.

#[export] Hint Immediate close_T_wrt_T_inj : lngen.

Lemma close_Sc_wrt_T_inj :
forall Sc1 Sc2 β1,
  close_Sc_wrt_T β1 Sc1 = close_Sc_wrt_T β1 Sc2 ->
  Sc1 = Sc2.
Proof.
unfold close_Sc_wrt_T; eauto with lngen.
Qed.

#[export] Hint Immediate close_Sc_wrt_T_inj : lngen.

Lemma close_Tm_wrt_T_inj :
forall t1 t2 β1,
  close_Tm_wrt_T β1 t1 = close_Tm_wrt_T β1 t2 ->
  t1 = t2.
Proof.
unfold close_Tm_wrt_T; eauto with lngen.
Qed.

#[export] Hint Immediate close_Tm_wrt_T_inj : lngen.

Lemma close_Tm_wrt_Tm_inj :
forall t1 t2 tx1,
  close_Tm_wrt_Tm tx1 t1 = close_Tm_wrt_Tm tx1 t2 ->
  t1 = t2.
Proof.
unfold close_Tm_wrt_Tm; eauto with lngen.
Qed.

#[export] Hint Immediate close_Tm_wrt_Tm_inj : lngen.

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

Lemma close_Ex_wrt_Ex_open_Ex_wrt_Ex :
forall e1 x1,
  x1 ∉ fv_Ex e1 ->
  close_Ex_wrt_Ex x1 (open_Ex_wrt_Ex e1 (e__Var_f x1)) = e1.
Proof.
unfold close_Ex_wrt_Ex; unfold open_Ex_wrt_Ex; default_simp.
Qed.

#[export] Hint Resolve close_Ex_wrt_Ex_open_Ex_wrt_Ex : lngen.
#[export] Hint Rewrite close_Ex_wrt_Ex_open_Ex_wrt_Ex using solve [auto] : lngen.

Lemma close_T_wrt_T_open_T_wrt_T :
forall T1 β1,
  β1 ∉ fsk T1 ->
  close_T_wrt_T β1 (open_T_wrt_T T1 (T__Skvar_f β1)) = T1.
Proof.
unfold close_T_wrt_T; unfold open_T_wrt_T; default_simp.
Qed.

#[export] Hint Resolve close_T_wrt_T_open_T_wrt_T : lngen.
#[export] Hint Rewrite close_T_wrt_T_open_T_wrt_T using solve [auto] : lngen.

Lemma close_Sc_wrt_T_open_Sc_wrt_T :
forall Sc1 β1,
  β1 ∉ fsk Sc1 ->
  close_Sc_wrt_T β1 (open_Sc_wrt_T Sc1 (T__Skvar_f β1)) = Sc1.
Proof.
unfold close_Sc_wrt_T; unfold open_Sc_wrt_T; default_simp.
Qed.

#[export] Hint Resolve close_Sc_wrt_T_open_Sc_wrt_T : lngen.
#[export] Hint Rewrite close_Sc_wrt_T_open_Sc_wrt_T using solve [auto] : lngen.

Lemma close_Tm_wrt_T_open_Tm_wrt_T :
forall t1 β1,
  β1 ∉ fsk t1 ->
  close_Tm_wrt_T β1 (open_Tm_wrt_T t1 (T__Skvar_f β1)) = t1.
Proof.
unfold close_Tm_wrt_T; unfold open_Tm_wrt_T; default_simp.
Qed.

#[export] Hint Resolve close_Tm_wrt_T_open_Tm_wrt_T : lngen.
#[export] Hint Rewrite close_Tm_wrt_T_open_Tm_wrt_T using solve [auto] : lngen.

Lemma close_Tm_wrt_Tm_open_Tm_wrt_Tm :
forall t1 tx1,
  tx1 ∉ fv t1 ->
  close_Tm_wrt_Tm tx1 (open_Tm_wrt_Tm t1 (t__Tvar_f tx1)) = t1.
Proof.
unfold close_Tm_wrt_Tm; unfold open_Tm_wrt_Tm; default_simp.
Qed.

#[export] Hint Resolve close_Tm_wrt_Tm_open_Tm_wrt_Tm : lngen.
#[export] Hint Rewrite close_Tm_wrt_Tm_open_Tm_wrt_Tm using solve [auto] : lngen.

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

Lemma open_Ex_wrt_Ex_close_Ex_wrt_Ex :
forall e1 x1,
  open_Ex_wrt_Ex (close_Ex_wrt_Ex x1 e1) (e__Var_f x1) = e1.
Proof.
unfold close_Ex_wrt_Ex; unfold open_Ex_wrt_Ex; default_simp.
Qed.

#[export] Hint Resolve open_Ex_wrt_Ex_close_Ex_wrt_Ex : lngen.
#[export] Hint Rewrite open_Ex_wrt_Ex_close_Ex_wrt_Ex using solve [auto] : lngen.

Lemma open_T_wrt_T_close_T_wrt_T :
forall T1 β1,
  open_T_wrt_T (close_T_wrt_T β1 T1) (T__Skvar_f β1) = T1.
Proof.
unfold close_T_wrt_T; unfold open_T_wrt_T; default_simp.
Qed.

#[export] Hint Resolve open_T_wrt_T_close_T_wrt_T : lngen.
#[export] Hint Rewrite open_T_wrt_T_close_T_wrt_T using solve [auto] : lngen.

Lemma open_Sc_wrt_T_close_Sc_wrt_T :
forall Sc1 β1,
  open_Sc_wrt_T (close_Sc_wrt_T β1 Sc1) (T__Skvar_f β1) = Sc1.
Proof.
unfold close_Sc_wrt_T; unfold open_Sc_wrt_T; default_simp.
Qed.

#[export] Hint Resolve open_Sc_wrt_T_close_Sc_wrt_T : lngen.
#[export] Hint Rewrite open_Sc_wrt_T_close_Sc_wrt_T using solve [auto] : lngen.

Lemma open_Tm_wrt_T_close_Tm_wrt_T :
forall t1 β1,
  open_Tm_wrt_T (close_Tm_wrt_T β1 t1) (T__Skvar_f β1) = t1.
Proof.
unfold close_Tm_wrt_T; unfold open_Tm_wrt_T; default_simp.
Qed.

#[export] Hint Resolve open_Tm_wrt_T_close_Tm_wrt_T : lngen.
#[export] Hint Rewrite open_Tm_wrt_T_close_Tm_wrt_T using solve [auto] : lngen.

Lemma open_Tm_wrt_Tm_close_Tm_wrt_Tm :
forall t1 tx1,
  open_Tm_wrt_Tm (close_Tm_wrt_Tm tx1 t1) (t__Tvar_f tx1) = t1.
Proof.
unfold close_Tm_wrt_Tm; unfold open_Tm_wrt_Tm; default_simp.
Qed.

#[export] Hint Resolve open_Tm_wrt_Tm_close_Tm_wrt_Tm : lngen.
#[export] Hint Rewrite open_Tm_wrt_Tm_close_Tm_wrt_Tm using solve [auto] : lngen.

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

Lemma open_Ex_wrt_Ex_inj :
forall e2 e1 x1,
  x1 ∉ fv_Ex e2 ->
  x1 ∉ fv_Ex e1 ->
  open_Ex_wrt_Ex e2 (e__Var_f x1) = open_Ex_wrt_Ex e1 (e__Var_f x1) ->
  e2 = e1.
Proof.
unfold open_Ex_wrt_Ex; eauto with lngen.
Qed.

#[export] Hint Immediate open_Ex_wrt_Ex_inj : lngen.

Lemma open_T_wrt_T_inj :
forall T2 T1 β1,
  β1 ∉ fsk T2 ->
  β1 ∉ fsk T1 ->
  open_T_wrt_T T2 (T__Skvar_f β1) = open_T_wrt_T T1 (T__Skvar_f β1) ->
  T2 = T1.
Proof.
unfold open_T_wrt_T; eauto with lngen.
Qed.

#[export] Hint Immediate open_T_wrt_T_inj : lngen.

Lemma open_Sc_wrt_T_inj :
forall Sc2 Sc1 β1,
  β1 ∉ fsk Sc2 ->
  β1 ∉ fsk Sc1 ->
  open_Sc_wrt_T Sc2 (T__Skvar_f β1) = open_Sc_wrt_T Sc1 (T__Skvar_f β1) ->
  Sc2 = Sc1.
Proof.
unfold open_Sc_wrt_T; eauto with lngen.
Qed.

#[export] Hint Immediate open_Sc_wrt_T_inj : lngen.

Lemma open_Tm_wrt_T_inj :
forall t2 t1 β1,
  β1 ∉ fsk t2 ->
  β1 ∉ fsk t1 ->
  open_Tm_wrt_T t2 (T__Skvar_f β1) = open_Tm_wrt_T t1 (T__Skvar_f β1) ->
  t2 = t1.
Proof.
unfold open_Tm_wrt_T; eauto with lngen.
Qed.

#[export] Hint Immediate open_Tm_wrt_T_inj : lngen.

Lemma open_Tm_wrt_Tm_inj :
forall t2 t1 tx1,
  tx1 ∉ fv t2 ->
  tx1 ∉ fv t1 ->
  open_Tm_wrt_Tm t2 (t__Tvar_f tx1) = open_Tm_wrt_Tm t1 (t__Tvar_f tx1) ->
  t2 = t1.
Proof.
unfold open_Tm_wrt_Tm; eauto with lngen.
Qed.

#[export] Hint Immediate open_Tm_wrt_Tm_inj : lngen.


(* *********************************************************************** *)
(** * Theorems about [lc] *)

Ltac default_auto ::= auto with lngen brute_force; tauto.
Ltac default_autorewrite ::= autorewrite with lngen.

(*hidden lems removed*)

Lemma degree_Ex_wrt_Ex_of_lc_Ex :
forall e1,
  lc_Ex e1 ->
  degree_Ex_wrt_Ex 0 e1.
Proof.
pose proof degree_Ex_wrt_Ex_of_lc_Ex_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve degree_Ex_wrt_Ex_of_lc_Ex : lngen.

(*hidden lems removed*)

Lemma degree_T_wrt_T_of_lc_T :
forall T1,
  lc_T T1 ->
  degree_T_wrt_T 0 T1.
Proof.
pose proof degree_T_wrt_T_of_lc_T_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve degree_T_wrt_T_of_lc_T : lngen.

(*hidden lems removed*)

Lemma degree_Sc_wrt_T_of_lc_Sc :
forall Sc1,
  lc_Sc Sc1 ->
  degree_Sc_wrt_T 0 Sc1.
Proof.
pose proof degree_Sc_wrt_T_of_lc_Sc_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve degree_Sc_wrt_T_of_lc_Sc : lngen.

(*hidden lems removed*)

Lemma degree_Tm_wrt_T_of_lc_Tm :
forall t1,
  lc_Tm t1 ->
  degree_Tm_wrt_T 0 t1.
Proof.
pose proof degree_Tm_wrt_T_of_lc_Tm_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve degree_Tm_wrt_T_of_lc_Tm : lngen.

(*hidden lems removed*)

Lemma degree_Tm_wrt_Tm_of_lc_Tm :
forall t1,
  lc_Tm t1 ->
  degree_Tm_wrt_Tm 0 t1.
Proof.
pose proof degree_Tm_wrt_Tm_of_lc_Tm_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve degree_Tm_wrt_Tm_of_lc_Tm : lngen.

(*hidden lems removed*)

Lemma lc_Ex_of_degree :
forall e1,
  degree_Ex_wrt_Ex 0 e1 ->
  lc_Ex e1.
Proof.
intros e1; intros;
pose proof (lc_Ex_of_degree_size_mutual (size_Ex e1));
intuition eauto.
Qed.

#[export] Hint Resolve lc_Ex_of_degree : lngen.

(*hidden lems removed*)

Lemma lc_T_of_degree :
forall T1,
  degree_T_wrt_T 0 T1 ->
  lc_T T1.
Proof.
intros T1; intros;
pose proof (lc_T_of_degree_size_mutual (size_T T1));
intuition eauto.
Qed.

#[export] Hint Resolve lc_T_of_degree : lngen.

(*hidden lems removed*)

Lemma lc_Sc_of_degree :
forall Sc1,
  degree_Sc_wrt_T 0 Sc1 ->
  lc_Sc Sc1.
Proof.
intros Sc1; intros;
pose proof (lc_Sc_of_degree_size_mutual (size_Sc Sc1));
intuition eauto.
Qed.

#[export] Hint Resolve lc_Sc_of_degree : lngen.

(*hidden lems removed*)

Lemma lc_Tm_of_degree :
forall t1,
  degree_Tm_wrt_T 0 t1 ->
  degree_Tm_wrt_Tm 0 t1 ->
  lc_Tm t1.
Proof.
intros t1; intros;
pose proof (lc_Tm_of_degree_size_mutual (size_Tm t1));
intuition eauto.
Qed.

#[export] Hint Resolve lc_Tm_of_degree : lngen.

Ltac Ex_lc_exists_tac :=
  repeat (match goal with
            | H : _ |- _ =>
              let J1 := fresh in pose proof H as J1; apply degree_Ex_wrt_Ex_of_lc_Ex in J1; clear H
          end).

Ltac T_lc_exists_tac :=
  repeat (match goal with
            | H : _ |- _ =>
              let J1 := fresh in pose proof H as J1; apply degree_T_wrt_T_of_lc_T in J1; clear H
          end).

Ltac Sc_lc_exists_tac :=
  repeat (match goal with
            | H : _ |- _ =>
              let J1 := fresh in pose proof H as J1; apply degree_Sc_wrt_T_of_lc_Sc in J1; clear H
          end).

Ltac Tm_lc_exists_tac :=
  repeat (match goal with
            | H : _ |- _ =>
              let J1 := fresh in pose proof H as J1; apply degree_Tm_wrt_T_of_lc_Tm in J1;
              let J2 := fresh in pose proof H as J2; apply degree_Tm_wrt_Tm_of_lc_Tm in J2; clear H
          end).

Lemma lc_e__Lam_exists :
forall x1 e1,
  lc_Ex (open_Ex_wrt_Ex e1 (e__Var_f x1)) ->
  lc_Ex (e__Lam e1).
Proof.
intros; Ex_lc_exists_tac; eauto 6 with lngen.
Qed.

Lemma lc_e__Let_exists :
forall x1 e1 e2,
  lc_Ex e1 ->
  lc_Ex (open_Ex_wrt_Ex e2 (e__Var_f x1)) ->
  lc_Ex (e__Let e1 e2).
Proof.
intros; Ex_lc_exists_tac; eauto 6 with lngen.
Qed.

Lemma lc_S__Forall_exists :
forall α1 σ1,
  lc_Sc (open_Sc_wrt_T σ1 (T__Skvar_f α1)) ->
  lc_Sc (S__Forall σ1).
Proof.
intros; Sc_lc_exists_tac; eauto 6 with lngen.
Qed.

Lemma lc_t__Lam_exists :
forall tx1 σ1 t1,
  lc_Sc σ1 ->
  lc_Tm (open_Tm_wrt_Tm t1 (t__Tvar_f tx1)) ->
  lc_Tm (t__Lam σ1 t1).
Proof.
intros; Tm_lc_exists_tac; eauto 6 with lngen.
Qed.

Lemma lc_t__Tlam_exists :
forall α1 t1,
  lc_Tm (open_Tm_wrt_T t1 (T__Skvar_f α1)) ->
  lc_Tm (t__Tlam t1).
Proof.
intros; Tm_lc_exists_tac; eauto 6 with lngen.
Qed.

Lemma lc_t__Let_exists :
forall tx1 σ1 t1 t2,
  lc_Sc σ1 ->
  lc_Tm t1 ->
  lc_Tm (open_Tm_wrt_Tm t2 (t__Tvar_f tx1)) ->
  lc_Tm (t__Let σ1 t1 t2).
Proof.
intros; Tm_lc_exists_tac; eauto 6 with lngen.
Qed.

#[export] Hint Extern 1 (lc_Ex (e__Lam _)) =>
  let x1 := fresh in
  pick_fresh x1;
  apply (lc_e__Lam_exists x1) : core.

#[export] Hint Extern 1 (lc_Ex (e__Let _ _)) =>
  let x1 := fresh in
  pick_fresh x1;
  apply (lc_e__Let_exists x1) : core.

#[export] Hint Extern 1 (lc_Sc (S__Forall _)) =>
  let α1 := fresh in
  pick_fresh α1;
  apply (lc_S__Forall_exists α1) : core.

#[export] Hint Extern 1 (lc_Tm (t__Lam _ _)) =>
  let tx1 := fresh in
  pick_fresh tx1;
  apply (lc_t__Lam_exists tx1) : core.

#[export] Hint Extern 1 (lc_Tm (t__Tlam _)) =>
  let α1 := fresh in
  pick_fresh α1;
  apply (lc_t__Tlam_exists α1) : core.

#[export] Hint Extern 1 (lc_Tm (t__Let _ _ _)) =>
  let tx1 := fresh in
  pick_fresh tx1;
  apply (lc_t__Let_exists tx1) : core.

Lemma lc_body_Ex_wrt_Ex :
forall e1 e2,
  body_Ex_wrt_Ex e1 ->
  lc_Ex e2 ->
  lc_Ex (open_Ex_wrt_Ex e1 e2).
Proof.
unfold body_Ex_wrt_Ex;
default_simp;
let x1 := fresh "x" in
pick_fresh x1;
specialize_all x1;
Ex_lc_exists_tac;
eauto 7 with lngen.
Qed.

#[export] Hint Resolve lc_body_Ex_wrt_Ex : lngen.

Lemma lc_body_T_wrt_T :
forall T1 T2,
  body_T_wrt_T T1 ->
  lc_T T2 ->
  lc_T (open_T_wrt_T T1 T2).
Proof.
unfold body_T_wrt_T;
default_simp;
let β1 := fresh "x" in
pick_fresh β1;
specialize_all β1;
T_lc_exists_tac;
eauto 7 with lngen.
Qed.

#[export] Hint Resolve lc_body_T_wrt_T : lngen.

Lemma lc_body_Sc_wrt_T :
forall Sc1 T1,
  body_Sc_wrt_T Sc1 ->
  lc_T T1 ->
  lc_Sc (open_Sc_wrt_T Sc1 T1).
Proof.
unfold body_Sc_wrt_T;
default_simp;
let β1 := fresh "x" in
pick_fresh β1;
specialize_all β1;
Sc_lc_exists_tac;
eauto 7 with lngen.
Qed.

#[export] Hint Resolve lc_body_Sc_wrt_T : lngen.

Lemma lc_body_Tm_wrt_T :
forall t1 T1,
  body_Tm_wrt_T t1 ->
  lc_T T1 ->
  lc_Tm (open_Tm_wrt_T t1 T1).
Proof.
unfold body_Tm_wrt_T;
default_simp;
let β1 := fresh "x" in
pick_fresh β1;
specialize_all β1;
Tm_lc_exists_tac;
eauto 7 with lngen.
Qed.

#[export] Hint Resolve lc_body_Tm_wrt_T : lngen.

Lemma lc_body_Tm_wrt_Tm :
forall t1 t2,
  body_Tm_wrt_Tm t1 ->
  lc_Tm t2 ->
  lc_Tm (open_Tm_wrt_Tm t1 t2).
Proof.
unfold body_Tm_wrt_Tm;
default_simp;
let tx1 := fresh "x" in
pick_fresh tx1;
specialize_all tx1;
Tm_lc_exists_tac;
eauto 7 with lngen.
Qed.

#[export] Hint Resolve lc_body_Tm_wrt_Tm : lngen.

Lemma lc_body_e__Lam_1 :
forall e1,
  lc_Ex (e__Lam e1) ->
  body_Ex_wrt_Ex e1.
Proof.
default_simp.
Qed.

#[export] Hint Resolve lc_body_e__Lam_1 : lngen.

Lemma lc_body_e__Let_2 :
forall e1 e2,
  lc_Ex (e__Let e1 e2) ->
  body_Ex_wrt_Ex e2.
Proof.
default_simp.
Qed.

#[export] Hint Resolve lc_body_e__Let_2 : lngen.

Lemma lc_body_S__Forall_1 :
forall σ1,
  lc_Sc (S__Forall σ1) ->
  body_Sc_wrt_T σ1.
Proof.
default_simp.
Qed.

#[export] Hint Resolve lc_body_S__Forall_1 : lngen.

Lemma lc_body_t__Lam_2 :
forall σ1 t1,
  lc_Tm (t__Lam σ1 t1) ->
  body_Tm_wrt_Tm t1.
Proof.
default_simp.
Qed.

#[export] Hint Resolve lc_body_t__Lam_2 : lngen.

Lemma lc_body_t__Tlam_1 :
forall t1,
  lc_Tm (t__Tlam t1) ->
  body_Tm_wrt_T t1.
Proof.
default_simp.
Qed.

#[export] Hint Resolve lc_body_t__Tlam_1 : lngen.

Lemma lc_body_t__Let_3 :
forall σ1 t1 t2,
  lc_Tm (t__Let σ1 t1 t2) ->
  body_Tm_wrt_Tm t2.
Proof.
default_simp.
Qed.

#[export] Hint Resolve lc_body_t__Let_3 : lngen.

(*hidden lems removed*)

Lemma lc_Ex_unique :
forall e1 (proof2 proof3 : lc_Ex e1), proof2 = proof3.
Proof.
pose proof lc_Ex_unique_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve lc_Ex_unique : lngen.

(*hidden lems removed*)

Lemma lc_T_unique :
forall T1 (proof2 proof3 : lc_T T1), proof2 = proof3.
Proof.
pose proof lc_T_unique_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve lc_T_unique : lngen.

(*hidden lems removed*)

Lemma lc_Sc_unique :
forall Sc1 (proof2 proof3 : lc_Sc Sc1), proof2 = proof3.
Proof.
pose proof lc_Sc_unique_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve lc_Sc_unique : lngen.

(*hidden lems removed*)

Lemma lc_Tm_unique :
forall t1 (proof2 proof3 : lc_Tm t1), proof2 = proof3.
Proof.
pose proof lc_Tm_unique_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve lc_Tm_unique : lngen.

(*hidden lems removed*)

Lemma lc_Ex_of_lc_set_Ex :
forall e1, lc_set_Ex e1 -> lc_Ex e1.
Proof.
pose proof lc_Ex_of_lc_set_Ex_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve lc_Ex_of_lc_set_Ex : lngen.

(*hidden lems removed*)

Lemma lc_T_of_lc_set_T :
forall T1, lc_set_T T1 -> lc_T T1.
Proof.
pose proof lc_T_of_lc_set_T_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve lc_T_of_lc_set_T : lngen.

(*hidden lems removed*)

Lemma lc_Sc_of_lc_set_Sc :
forall Sc1, lc_set_Sc Sc1 -> lc_Sc Sc1.
Proof.
pose proof lc_Sc_of_lc_set_Sc_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve lc_Sc_of_lc_set_Sc : lngen.

(*hidden lems removed*)

Lemma lc_Tm_of_lc_set_Tm :
forall t1, lc_set_Tm t1 -> lc_Tm t1.
Proof.
pose proof lc_Tm_of_lc_set_Tm_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve lc_Tm_of_lc_set_Tm : lngen.

(*hidden lems removed*)

Lemma lc_set_Ex_of_lc_Ex :
forall e1,
  lc_Ex e1 ->
  lc_set_Ex e1.
Proof.
intros e1; intros;
pose proof (lc_set_Ex_of_lc_Ex_size_mutual (size_Ex e1));
intuition eauto.
Qed.

#[export] Hint Resolve lc_set_Ex_of_lc_Ex : lngen.

(*hidden lems removed*)

Lemma lc_set_T_of_lc_T :
forall T1,
  lc_T T1 ->
  lc_set_T T1.
Proof.
intros T1; intros;
pose proof (lc_set_T_of_lc_T_size_mutual (size_T T1));
intuition eauto.
Qed.

#[export] Hint Resolve lc_set_T_of_lc_T : lngen.

(*hidden lems removed*)

Lemma lc_set_Sc_of_lc_Sc :
forall Sc1,
  lc_Sc Sc1 ->
  lc_set_Sc Sc1.
Proof.
intros Sc1; intros;
pose proof (lc_set_Sc_of_lc_Sc_size_mutual (size_Sc Sc1));
intuition eauto.
Qed.

#[export] Hint Resolve lc_set_Sc_of_lc_Sc : lngen.

(*hidden lems removed*)

Lemma lc_set_Tm_of_lc_Tm :
forall t1,
  lc_Tm t1 ->
  lc_set_Tm t1.
Proof.
intros t1; intros;
pose proof (lc_set_Tm_of_lc_Tm_size_mutual (size_Tm t1));
intuition eauto.
Qed.

#[export] Hint Resolve lc_set_Tm_of_lc_Tm : lngen.


(* *********************************************************************** *)
(** * More theorems about [open] and [close] *)

Ltac default_auto ::= auto with lngen; tauto.
Ltac default_autorewrite ::= fail.

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

Lemma close_Ex_wrt_Ex_lc_Ex :
forall e1 x1,
  lc_Ex e1 ->
  x1 ∉ fv_Ex e1 ->
  close_Ex_wrt_Ex x1 e1 = e1.
Proof.
unfold close_Ex_wrt_Ex; default_simp.
Qed.

#[export] Hint Resolve close_Ex_wrt_Ex_lc_Ex : lngen.
#[export] Hint Rewrite close_Ex_wrt_Ex_lc_Ex using solve [auto] : lngen.

Lemma close_T_wrt_T_lc_T :
forall T1 β1,
  lc_T T1 ->
  β1 ∉ fsk T1 ->
  close_T_wrt_T β1 T1 = T1.
Proof.
unfold close_T_wrt_T; default_simp.
Qed.

#[export] Hint Resolve close_T_wrt_T_lc_T : lngen.
#[export] Hint Rewrite close_T_wrt_T_lc_T using solve [auto] : lngen.

Lemma close_Sc_wrt_T_lc_Sc :
forall Sc1 β1,
  lc_Sc Sc1 ->
  β1 ∉ fsk Sc1 ->
  close_Sc_wrt_T β1 Sc1 = Sc1.
Proof.
unfold close_Sc_wrt_T; default_simp.
Qed.

#[export] Hint Resolve close_Sc_wrt_T_lc_Sc : lngen.
#[export] Hint Rewrite close_Sc_wrt_T_lc_Sc using solve [auto] : lngen.

Lemma close_Tm_wrt_T_lc_Tm :
forall t1 β1,
  lc_Tm t1 ->
  β1 ∉ fsk t1 ->
  close_Tm_wrt_T β1 t1 = t1.
Proof.
unfold close_Tm_wrt_T; default_simp.
Qed.

#[export] Hint Resolve close_Tm_wrt_T_lc_Tm : lngen.
#[export] Hint Rewrite close_Tm_wrt_T_lc_Tm using solve [auto] : lngen.

Lemma close_Tm_wrt_Tm_lc_Tm :
forall t1 tx1,
  lc_Tm t1 ->
  tx1 ∉ fv t1 ->
  close_Tm_wrt_Tm tx1 t1 = t1.
Proof.
unfold close_Tm_wrt_Tm; default_simp.
Qed.

#[export] Hint Resolve close_Tm_wrt_Tm_lc_Tm : lngen.
#[export] Hint Rewrite close_Tm_wrt_Tm_lc_Tm using solve [auto] : lngen.

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

Lemma open_Ex_wrt_Ex_lc_Ex :
forall e2 e1,
  lc_Ex e2 ->
  open_Ex_wrt_Ex e2 e1 = e2.
Proof.
unfold open_Ex_wrt_Ex; default_simp.
Qed.

#[export] Hint Resolve open_Ex_wrt_Ex_lc_Ex : lngen.
#[export] Hint Rewrite open_Ex_wrt_Ex_lc_Ex using solve [auto] : lngen.

Lemma open_T_wrt_T_lc_T :
forall T2 T1,
  lc_T T2 ->
  open_T_wrt_T T2 T1 = T2.
Proof.
unfold open_T_wrt_T; default_simp.
Qed.

#[export] Hint Resolve open_T_wrt_T_lc_T : lngen.
#[export] Hint Rewrite open_T_wrt_T_lc_T using solve [auto] : lngen.

Lemma open_Sc_wrt_T_lc_Sc :
forall Sc1 T1,
  lc_Sc Sc1 ->
  open_Sc_wrt_T Sc1 T1 = Sc1.
Proof.
unfold open_Sc_wrt_T; default_simp.
Qed.

#[export] Hint Resolve open_Sc_wrt_T_lc_Sc : lngen.
#[export] Hint Rewrite open_Sc_wrt_T_lc_Sc using solve [auto] : lngen.

Lemma open_Tm_wrt_T_lc_Tm :
forall t1 T1,
  lc_Tm t1 ->
  open_Tm_wrt_T t1 T1 = t1.
Proof.
unfold open_Tm_wrt_T; default_simp.
Qed.

#[export] Hint Resolve open_Tm_wrt_T_lc_Tm : lngen.
#[export] Hint Rewrite open_Tm_wrt_T_lc_Tm using solve [auto] : lngen.

Lemma open_Tm_wrt_Tm_lc_Tm :
forall t2 t1,
  lc_Tm t2 ->
  open_Tm_wrt_Tm t2 t1 = t2.
Proof.
unfold open_Tm_wrt_Tm; default_simp.
Qed.

#[export] Hint Resolve open_Tm_wrt_Tm_lc_Tm : lngen.
#[export] Hint Rewrite open_Tm_wrt_Tm_lc_Tm using solve [auto] : lngen.


(* *********************************************************************** *)
(** * Theorems about [fv] *)

Ltac default_auto ::= auto with set lngen; tauto.
Ltac default_autorewrite ::= autorewrite with lngen.

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

Lemma fv_Ex_close_Ex_wrt_Ex :
forall e1 x1,
  fv_Ex (close_Ex_wrt_Ex x1 e1) [=] remove x1 (fv_Ex e1).
Proof.
unfold close_Ex_wrt_Ex; default_simp.
Qed.

#[export] Hint Resolve fv_Ex_close_Ex_wrt_Ex : lngen.
#[export] Hint Rewrite fv_Ex_close_Ex_wrt_Ex using solve [auto] : lngen.

Lemma fsk_T_close_T_wrt_T :
forall T1 β1,
  fsk (close_T_wrt_T β1 T1) [=] remove β1 (fsk T1).
Proof.
unfold close_T_wrt_T; default_simp.
Qed.

#[export] Hint Resolve fsk_T_close_T_wrt_T : lngen.
#[export] Hint Rewrite fsk_T_close_T_wrt_T using solve [auto] : lngen.

Lemma fsk_Sc_close_Sc_wrt_T :
forall Sc1 β1,
  fsk (close_Sc_wrt_T β1 Sc1) [=] remove β1 (fsk Sc1).
Proof.
unfold close_Sc_wrt_T; default_simp.
Qed.

#[export] Hint Resolve fsk_Sc_close_Sc_wrt_T : lngen.
#[export] Hint Rewrite fsk_Sc_close_Sc_wrt_T using solve [auto] : lngen.

Lemma fsk_Tm_close_Tm_wrt_T :
forall t1 β1,
  fsk (close_Tm_wrt_T β1 t1) [=] remove β1 (fsk t1).
Proof.
unfold close_Tm_wrt_T; default_simp.
Qed.

#[export] Hint Resolve fsk_Tm_close_Tm_wrt_T : lngen.
#[export] Hint Rewrite fsk_Tm_close_Tm_wrt_T using solve [auto] : lngen.

Lemma fsk_Tm_close_Tm_wrt_Tm :
forall t1 tx1,
  fsk (close_Tm_wrt_Tm tx1 t1) [=] fsk t1.
Proof.
unfold close_Tm_wrt_Tm; default_simp.
Qed.

#[export] Hint Resolve fsk_Tm_close_Tm_wrt_Tm : lngen.
#[export] Hint Rewrite fsk_Tm_close_Tm_wrt_Tm using solve [auto] : lngen.

Lemma ftv_Tm_close_Tm_wrt_T :
forall t1 β1,
  fv (close_Tm_wrt_T β1 t1) [=] fv t1.
Proof.
unfold close_Tm_wrt_T; default_simp.
Qed.

#[export] Hint Resolve ftv_Tm_close_Tm_wrt_T : lngen.
#[export] Hint Rewrite ftv_Tm_close_Tm_wrt_T using solve [auto] : lngen.

Lemma ftv_Tm_close_Tm_wrt_Tm :
forall t1 tx1,
  fv (close_Tm_wrt_Tm tx1 t1) [=] remove tx1 (fv t1).
Proof.
unfold close_Tm_wrt_Tm; default_simp.
Qed.

#[export] Hint Resolve ftv_Tm_close_Tm_wrt_Tm : lngen.
#[export] Hint Rewrite ftv_Tm_close_Tm_wrt_Tm using solve [auto] : lngen.

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

Lemma fv_Ex_open_Ex_wrt_Ex_lower :
forall e1 e2,
  fv_Ex e1 [<=] fv_Ex (open_Ex_wrt_Ex e1 e2).
Proof.
unfold open_Ex_wrt_Ex; default_simp.
Qed.

#[export] Hint Resolve fv_Ex_open_Ex_wrt_Ex_lower : lngen.

Lemma fsk_T_open_T_wrt_T_lower :
forall T1 T2,
  fsk T1 [<=] fsk (open_T_wrt_T T1 T2).
Proof.
unfold open_T_wrt_T; default_simp.
Qed.

#[export] Hint Resolve fsk_T_open_T_wrt_T_lower : lngen.

Lemma fsk_Sc_open_Sc_wrt_T_lower :
forall Sc1 T1,
  fsk Sc1 [<=] fsk (open_Sc_wrt_T Sc1 T1).
Proof.
unfold open_Sc_wrt_T; default_simp.
Qed.

#[export] Hint Resolve fsk_Sc_open_Sc_wrt_T_lower : lngen.

Lemma fsk_Tm_open_Tm_wrt_T_lower :
forall t1 T1,
  fsk t1 [<=] fsk (open_Tm_wrt_T t1 T1).
Proof.
unfold open_Tm_wrt_T; default_simp.
Qed.

#[export] Hint Resolve fsk_Tm_open_Tm_wrt_T_lower : lngen.

Lemma fsk_Tm_open_Tm_wrt_Tm_lower :
forall t1 t2,
  fsk t1 [<=] fsk (open_Tm_wrt_Tm t1 t2).
Proof.
unfold open_Tm_wrt_Tm; default_simp.
Qed.

#[export] Hint Resolve fsk_Tm_open_Tm_wrt_Tm_lower : lngen.

Lemma ftv_Tm_open_Tm_wrt_T_lower :
forall t1 T1,
  fv t1 [<=] fv (open_Tm_wrt_T t1 T1).
Proof.
unfold open_Tm_wrt_T; default_simp.
Qed.

#[export] Hint Resolve ftv_Tm_open_Tm_wrt_T_lower : lngen.

Lemma ftv_Tm_open_Tm_wrt_Tm_lower :
forall t1 t2,
  fv t1 [<=] fv (open_Tm_wrt_Tm t1 t2).
Proof.
unfold open_Tm_wrt_Tm; default_simp.
Qed.

#[export] Hint Resolve ftv_Tm_open_Tm_wrt_Tm_lower : lngen.

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

Lemma fv_Ex_open_Ex_wrt_Ex_upper :
forall e1 e2,
  fv_Ex (open_Ex_wrt_Ex e1 e2) [<=] fv_Ex e2 `union` fv_Ex e1.
Proof.
unfold open_Ex_wrt_Ex; default_simp.
Qed.

#[export] Hint Resolve fv_Ex_open_Ex_wrt_Ex_upper : lngen.

Lemma fsk_T_open_T_wrt_T_upper :
forall T1 T2,
  fsk (open_T_wrt_T T1 T2) [<=] fsk T2 `union` fsk T1.
Proof.
unfold open_T_wrt_T; default_simp.
Qed.

#[export] Hint Resolve fsk_T_open_T_wrt_T_upper : lngen.

Lemma fsk_Sc_open_Sc_wrt_T_upper :
forall Sc1 T1,
  fsk (open_Sc_wrt_T Sc1 T1) [<=] fsk T1 `union` fsk Sc1.
Proof.
unfold open_Sc_wrt_T; default_simp.
Qed.

#[export] Hint Resolve fsk_Sc_open_Sc_wrt_T_upper : lngen.

Lemma fsk_Tm_open_Tm_wrt_T_upper :
forall t1 T1,
  fsk (open_Tm_wrt_T t1 T1) [<=] fsk T1 `union` fsk t1.
Proof.
unfold open_Tm_wrt_T; default_simp.
Qed.

#[export] Hint Resolve fsk_Tm_open_Tm_wrt_T_upper : lngen.

Lemma fsk_Tm_open_Tm_wrt_Tm_upper :
forall t1 t2,
  fsk (open_Tm_wrt_Tm t1 t2) [<=] fsk t2 `union` fsk t1.
Proof.
unfold open_Tm_wrt_Tm; default_simp.
Qed.

#[export] Hint Resolve fsk_Tm_open_Tm_wrt_Tm_upper : lngen.

Lemma ftv_Tm_open_Tm_wrt_T_upper :
forall t1 T1,
  fv (open_Tm_wrt_T t1 T1) [<=] fv t1.
Proof.
unfold open_Tm_wrt_T; default_simp.
Qed.

#[export] Hint Resolve ftv_Tm_open_Tm_wrt_T_upper : lngen.

Lemma ftv_Tm_open_Tm_wrt_Tm_upper :
forall t1 t2,
  fv (open_Tm_wrt_Tm t1 t2) [<=] fv t2 `union` fv t1.
Proof.
unfold open_Tm_wrt_Tm; default_simp.
Qed.

#[export] Hint Resolve ftv_Tm_open_Tm_wrt_Tm_upper : lngen.

(*hidden lems removed*)

Lemma fv_Ex_subst_var_Ex_fresh :
forall e1 e2 x1,
  x1 ∉ fv_Ex e1 ->
  fv_Ex (subst (X:=Ex) (In:=Ex) e2 x1 e1) [=] fv_Ex e1.
Proof.
pose proof fv_Ex_subst_var_Ex_fresh_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve fv_Ex_subst_var_Ex_fresh : lngen.
#[export] Hint Rewrite fv_Ex_subst_var_Ex_fresh using solve [auto] : lngen.

(*hidden lems removed*)

Lemma fsk_T_subst_skvar_T_fresh :
forall T1 T2 β1,
  β1 ∉ fsk T1 ->
  fsk (subst_skvar_T T2 β1 T1) [=] fsk T1.
Proof.
pose proof fsk_T_subst_skvar_T_fresh_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve fsk_T_subst_skvar_T_fresh : lngen.
#[export] Hint Rewrite fsk_T_subst_skvar_T_fresh using solve [auto] : lngen.

(*hidden lems removed*)

Lemma fsk_Sc_subst_skvar_Sc_fresh :
forall Sc1 T1 β1,
  β1 ∉ fsk Sc1 ->
  fsk (subst_skvar_Sc T1 β1 Sc1) [=] fsk Sc1.
Proof.
pose proof fsk_Sc_subst_skvar_Sc_fresh_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve fsk_Sc_subst_skvar_Sc_fresh : lngen.
#[export] Hint Rewrite fsk_Sc_subst_skvar_Sc_fresh using solve [auto] : lngen.

(*hidden lems removed*)

Lemma fsk_Tm_subst_skvar_Tm_fresh :
forall t1 T1 β1,
  β1 ∉ fsk t1 ->
  fsk (subst_skvar_Tm T1 β1 t1) [=] fsk t1.
Proof.
pose proof fsk_Tm_subst_skvar_Tm_fresh_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve fsk_Tm_subst_skvar_Tm_fresh : lngen.
#[export] Hint Rewrite fsk_Tm_subst_skvar_Tm_fresh using solve [auto] : lngen.

(*hidden lems removed*)

Lemma fsk_Tm_subst_tvar_Tm_fresh :
forall t1 T1 β1,
  fv (subst_skvar_Tm T1 β1 t1) [=] fv t1.
Proof.
pose proof fsk_Tm_subst_tvar_Tm_fresh_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve fsk_Tm_subst_tvar_Tm_fresh : lngen.
#[export] Hint Rewrite fsk_Tm_subst_tvar_Tm_fresh using solve [auto] : lngen.

(*hidden lems removed*)

Lemma ftv_Tm_subst_tvar_Tm_fresh :
forall t1 t2 tx1,
  tx1 ∉ fv t1 ->
  fv (subst (X:=Tm) (In:=Tm) t2 tx1 t1) [=] fv t1.
Proof.
pose proof ftv_Tm_subst_tvar_Tm_fresh_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve ftv_Tm_subst_tvar_Tm_fresh : lngen.
#[export] Hint Rewrite ftv_Tm_subst_tvar_Tm_fresh using solve [auto] : lngen.

(*hidden lems removed*)

Lemma fv_Ex_subst_var_Ex_lower :
forall e1 e2 x1,
  remove x1 (fv_Ex e1) [<=] fv_Ex (subst (X:=Ex) (In:=Ex) e2 x1 e1).
Proof.
pose proof fv_Ex_subst_var_Ex_lower_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve fv_Ex_subst_var_Ex_lower : lngen.

(*hidden lems removed*)

Lemma fsk_T_subst_skvar_T_lower :
forall T1 T2 β1,
  remove β1 (fsk T1) [<=] fsk (subst_skvar_T T2 β1 T1).
Proof.
pose proof fsk_T_subst_skvar_T_lower_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve fsk_T_subst_skvar_T_lower : lngen.

(*hidden lems removed*)

Lemma fsk_Sc_subst_skvar_Sc_lower :
forall Sc1 T1 β1,
  remove β1 (fsk Sc1) [<=] fsk (subst_skvar_Sc T1 β1 Sc1).
Proof.
pose proof fsk_Sc_subst_skvar_Sc_lower_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve fsk_Sc_subst_skvar_Sc_lower : lngen.

(*hidden lems removed*)

Lemma fsk_Tm_subst_skvar_Tm_lower :
forall t1 T1 β1,
  remove β1 (fsk t1) [<=] fsk (subst_skvar_Tm T1 β1 t1).
Proof.
pose proof fsk_Tm_subst_skvar_Tm_lower_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve fsk_Tm_subst_skvar_Tm_lower : lngen.

(*hidden lems removed*)

Lemma fsk_Tm_subst_tvar_Tm_lower :
forall t1 t2 tx1,
  fsk t1 [<=] fsk (subst (X:=Tm) (In:=Tm) t2 tx1 t1).
Proof.
pose proof fsk_Tm_subst_tvar_Tm_lower_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve fsk_Tm_subst_tvar_Tm_lower : lngen.

(*hidden lems removed*)

Lemma ftv_Tm_subst_skvar_Tm_lower :
forall t1 T1 β1,
  fv t1 [<=] fv (subst_skvar_Tm T1 β1 t1).
Proof.
pose proof ftv_Tm_subst_skvar_Tm_lower_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve ftv_Tm_subst_skvar_Tm_lower : lngen.

(*hidden lems removed*)

Lemma ftv_Tm_subst_tvar_Tm_lower :
forall t1 t2 tx1,
  remove tx1 (fv t1) [<=] fv (subst (X:=Tm) (In:=Tm) t2 tx1 t1).
Proof.
pose proof ftv_Tm_subst_tvar_Tm_lower_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve ftv_Tm_subst_tvar_Tm_lower : lngen.

(*hidden lems removed*)

Lemma fv_Ex_subst_var_Ex_notin :
forall e1 e2 x1 x2,
  x2 ∉ fv_Ex e1 ->
  x2 ∉ fv_Ex e2 ->
  x2 ∉ fv_Ex (subst (X:=Ex) (In:=Ex) e2 x1 e1).
Proof.
pose proof fv_Ex_subst_var_Ex_notin_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve fv_Ex_subst_var_Ex_notin : lngen.

(*hidden lems removed*)

Lemma fsk_T_subst_skvar_T_notin :
forall T1 T2 β1 β2,
  β2 ∉ fsk T1 ->
  β2 ∉ fsk T2 ->
  β2 ∉ fsk (subst_skvar_T T2 β1 T1).
Proof.
pose proof fsk_T_subst_skvar_T_notin_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve fsk_T_subst_skvar_T_notin : lngen.

(*hidden lems removed*)

Lemma fsk_Sc_subst_skvar_Sc_notin :
forall Sc1 T1 β1 β2,
  β2 ∉ fsk Sc1 ->
  β2 ∉ fsk T1 ->
  β2 ∉ fsk (subst_skvar_Sc T1 β1 Sc1).
Proof.
pose proof fsk_Sc_subst_skvar_Sc_notin_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve fsk_Sc_subst_skvar_Sc_notin : lngen.

(*hidden lems removed*)

Lemma fsk_Tm_subst_skvar_Tm_notin :
forall t1 T1 β1 β2,
  β2 ∉ fsk t1 ->
  β2 ∉ fsk T1 ->
  β2 ∉ fsk (subst_skvar_Tm T1 β1 t1).
Proof.
pose proof fsk_Tm_subst_skvar_Tm_notin_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve fsk_Tm_subst_skvar_Tm_notin : lngen.

(*hidden lems removed*)

Lemma fsk_Tm_subst_tvar_Tm_notin :
forall t1 t2 tx1 β1,
  β1 ∉ fsk t1 ->
  β1 ∉ fsk t2 ->
  β1 ∉ fsk (subst (X:=Tm) (In:=Tm) t2 tx1 t1).
Proof.
pose proof fsk_Tm_subst_tvar_Tm_notin_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve fsk_Tm_subst_tvar_Tm_notin : lngen.

(*hidden lems removed*)

Lemma ftv_Tm_subst_skvar_Tm_notin :
forall t1 T1 β1 tx1,
  tx1 ∉ fv t1 ->
  tx1 ∉ fv (subst_skvar_Tm T1 β1 t1).
Proof.
pose proof ftv_Tm_subst_skvar_Tm_notin_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve ftv_Tm_subst_skvar_Tm_notin : lngen.

(*hidden lems removed*)

Lemma ftv_Tm_subst_tvar_Tm_notin :
forall t1 t2 tx1 tx2,
  tx2 ∉ fv t1 ->
  tx2 ∉ fv t2 ->
  tx2 ∉ fv (subst (X:=Tm) (In:=Tm) t2 tx1 t1).
Proof.
pose proof ftv_Tm_subst_tvar_Tm_notin_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve ftv_Tm_subst_tvar_Tm_notin : lngen.

(*hidden lems removed*)

Lemma fv_Ex_subst_var_Ex_upper :
forall e1 e2 x1,
  fv_Ex (subst (X:=Ex) (In:=Ex) e2 x1 e1) [<=] fv_Ex e2 `union` remove x1 (fv_Ex e1).
Proof.
pose proof fv_Ex_subst_var_Ex_upper_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve fv_Ex_subst_var_Ex_upper : lngen.

(*hidden lems removed*)

Lemma fsk_T_subst_skvar_T_upper :
forall T1 T2 β1,
  fsk (subst_skvar_T T2 β1 T1) [<=] fsk T2 `union` remove β1 (fsk T1).
Proof.
pose proof fsk_T_subst_skvar_T_upper_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve fsk_T_subst_skvar_T_upper : lngen.

(*hidden lems removed*)

Lemma fsk_Sc_subst_skvar_Sc_upper :
forall Sc1 T1 β1,
  fsk (subst_skvar_Sc T1 β1 Sc1) [<=] fsk T1 `union` remove β1 (fsk Sc1).
Proof.
pose proof fsk_Sc_subst_skvar_Sc_upper_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve fsk_Sc_subst_skvar_Sc_upper : lngen.

(*hidden lems removed*)

Lemma fsk_Tm_subst_skvar_Tm_upper :
forall t1 T1 β1,
  fsk (subst_skvar_Tm T1 β1 t1) [<=] fsk T1 `union` remove β1 (fsk t1).
Proof.
pose proof fsk_Tm_subst_skvar_Tm_upper_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve fsk_Tm_subst_skvar_Tm_upper : lngen.

(*hidden lems removed*)

Lemma fsk_Tm_subst_tvar_Tm_upper :
forall t1 t2 tx1,
  fsk (subst (X:=Tm) (In:=Tm) t2 tx1 t1) [<=] fsk t2 `union` fsk t1.
Proof.
pose proof fsk_Tm_subst_tvar_Tm_upper_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve fsk_Tm_subst_tvar_Tm_upper : lngen.

(*hidden lems removed*)

Lemma ftv_Tm_subst_skvar_Tm_upper :
forall t1 T1 β1,
  fv (subst_skvar_Tm T1 β1 t1) [<=] fv t1.
Proof.
pose proof ftv_Tm_subst_skvar_Tm_upper_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve ftv_Tm_subst_skvar_Tm_upper : lngen.

(*hidden lems removed*)

Lemma ftv_Tm_subst_tvar_Tm_upper :
forall t1 t2 tx1,
  fv (subst (X:=Tm) (In:=Tm) t2 tx1 t1) [<=] fv t2 `union` remove tx1 (fv t1).
Proof.
pose proof ftv_Tm_subst_tvar_Tm_upper_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve ftv_Tm_subst_tvar_Tm_upper : lngen.


(* *********************************************************************** *)
(** * Theorems about [subst] *)

Ltac default_auto ::= auto with lngen brute_force; tauto.
Ltac default_autorewrite ::= autorewrite with lngen.

(*hidden lems removed*)

Lemma subst_var_Ex_close_Ex_wrt_Ex_rec :
forall e2 e1 x1 x2 n1,
  degree_Ex_wrt_Ex n1 e1 ->
  x1 <> x2 ->
  x2 ∉ fv_Ex e1 ->
  subst (X:=Ex) (In:=Ex) e1 x1 (close_Ex_wrt_Ex_rec n1 x2 e2) = close_Ex_wrt_Ex_rec n1 x2 (subst (X:=Ex) (In:=Ex) e1 x1 e2).
Proof.
pose proof subst_var_Ex_close_Ex_wrt_Ex_rec_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve subst_var_Ex_close_Ex_wrt_Ex_rec : lngen.

(*hidden lems removed*)

Lemma subst_skvar_T_close_T_wrt_T_rec :
forall T2 T1 β1 β2 n1,
  degree_T_wrt_T n1 T1 ->
  β1 <> β2 ->
  β2 ∉ fsk T1 ->
  subst_skvar_T T1 β1 (close_T_wrt_T_rec n1 β2 T2) = close_T_wrt_T_rec n1 β2 (subst_skvar_T T1 β1 T2).
Proof.
pose proof subst_skvar_T_close_T_wrt_T_rec_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve subst_skvar_T_close_T_wrt_T_rec : lngen.

(*hidden lems removed*)

Lemma subst_skvar_Sc_close_Sc_wrt_T_rec :
forall Sc1 T1 β1 β2 n1,
  degree_T_wrt_T n1 T1 ->
  β1 <> β2 ->
  β2 ∉ fsk T1 ->
  subst_skvar_Sc T1 β1 (close_Sc_wrt_T_rec n1 β2 Sc1) = close_Sc_wrt_T_rec n1 β2 (subst_skvar_Sc T1 β1 Sc1).
Proof.
pose proof subst_skvar_Sc_close_Sc_wrt_T_rec_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve subst_skvar_Sc_close_Sc_wrt_T_rec : lngen.

(*hidden lems removed*)

Lemma subst_skvar_Tm_close_Tm_wrt_T_rec :
forall t1 T1 β1 β2 n1,
  degree_T_wrt_T n1 T1 ->
  β1 <> β2 ->
  β2 ∉ fsk T1 ->
  subst_skvar_Tm T1 β1 (close_Tm_wrt_T_rec n1 β2 t1) = close_Tm_wrt_T_rec n1 β2 (subst_skvar_Tm T1 β1 t1).
Proof.
pose proof subst_skvar_Tm_close_Tm_wrt_T_rec_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve subst_skvar_Tm_close_Tm_wrt_T_rec : lngen.

(*hidden lems removed*)

Lemma subst_skvar_Tm_close_Tm_wrt_Tm_rec :
forall t1 T1 tx1 β1 n1,
  subst_skvar_Tm T1 tx1 (close_Tm_wrt_Tm_rec n1 β1 t1) = close_Tm_wrt_Tm_rec n1 β1 (subst_skvar_Tm T1 tx1 t1).
Proof.
pose proof subst_skvar_Tm_close_Tm_wrt_Tm_rec_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve subst_skvar_Tm_close_Tm_wrt_Tm_rec : lngen.

(*hidden lems removed*)

Lemma subst_tvar_Tm_close_Tm_wrt_T_rec :
forall t2 t1 β1 tx1 n1,
  degree_Tm_wrt_T n1 t1 ->
  tx1 ∉ fsk t1 ->
  subst (X:=Tm) (In:=Tm) t1 β1 (close_Tm_wrt_T_rec n1 tx1 t2) = close_Tm_wrt_T_rec n1 tx1 (subst (X:=Tm) (In:=Tm) t1 β1 t2).
Proof.
pose proof subst_tvar_Tm_close_Tm_wrt_T_rec_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve subst_tvar_Tm_close_Tm_wrt_T_rec : lngen.

(*hidden lems removed*)

Lemma subst_tvar_Tm_close_Tm_wrt_Tm_rec :
forall t2 t1 tx1 tx2 n1,
  degree_Tm_wrt_Tm n1 t1 ->
  tx1 <> tx2 ->
  tx2 ∉ fv t1 ->
  subst (X:=Tm) (In:=Tm) t1 tx1 (close_Tm_wrt_Tm_rec n1 tx2 t2) = close_Tm_wrt_Tm_rec n1 tx2 (subst (X:=Tm) (In:=Tm) t1 tx1 t2).
Proof.
pose proof subst_tvar_Tm_close_Tm_wrt_Tm_rec_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve subst_tvar_Tm_close_Tm_wrt_Tm_rec : lngen.

Lemma subst_var_Ex_close_Ex_wrt_Ex :
forall e2 e1 x1 x2,
  lc_Ex e1 ->  x1 <> x2 ->
  x2 ∉ fv_Ex e1 ->
  subst (X:=Ex) (In:=Ex) e1 x1 (close_Ex_wrt_Ex x2 e2) = close_Ex_wrt_Ex x2 (subst (X:=Ex) (In:=Ex) e1 x1 e2).
Proof.
unfold close_Ex_wrt_Ex; default_simp.
Qed.

#[export] Hint Resolve subst_var_Ex_close_Ex_wrt_Ex : lngen.

Lemma subst_skvar_T_close_T_wrt_T :
forall T2 T1 β1 β2,
  lc_T T1 ->  β1 <> β2 ->
  β2 ∉ fsk T1 ->
  subst_skvar_T T1 β1 (close_T_wrt_T β2 T2) = close_T_wrt_T β2 (subst_skvar_T T1 β1 T2).
Proof.
unfold close_T_wrt_T; default_simp.
Qed.

#[export] Hint Resolve subst_skvar_T_close_T_wrt_T : lngen.

Lemma subst_skvar_Sc_close_Sc_wrt_T :
forall Sc1 T1 β1 β2,
  lc_T T1 ->  β1 <> β2 ->
  β2 ∉ fsk T1 ->
  subst_skvar_Sc T1 β1 (close_Sc_wrt_T β2 Sc1) = close_Sc_wrt_T β2 (subst_skvar_Sc T1 β1 Sc1).
Proof.
unfold close_Sc_wrt_T; default_simp.
Qed.

#[export] Hint Resolve subst_skvar_Sc_close_Sc_wrt_T : lngen.

Lemma subst_skvar_Tm_close_Tm_wrt_T :
forall t1 T1 β1 β2,
  lc_T T1 ->  β1 <> β2 ->
  β2 ∉ fsk T1 ->
  subst_skvar_Tm T1 β1 (close_Tm_wrt_T β2 t1) = close_Tm_wrt_T β2 (subst_skvar_Tm T1 β1 t1).
Proof.
unfold close_Tm_wrt_T; default_simp.
Qed.

#[export] Hint Resolve subst_skvar_Tm_close_Tm_wrt_T : lngen.

Lemma subst_skvar_Tm_close_Tm_wrt_Tm :
forall t1 T1 tx1 β1,
  lc_T T1 ->  subst_skvar_Tm T1 tx1 (close_Tm_wrt_Tm β1 t1) = close_Tm_wrt_Tm β1 (subst_skvar_Tm T1 tx1 t1).
Proof.
unfold close_Tm_wrt_Tm; default_simp.
Qed.

#[export] Hint Resolve subst_skvar_Tm_close_Tm_wrt_Tm : lngen.

Lemma subst_tvar_Tm_close_Tm_wrt_T :
forall t2 t1 β1 tx1,
  lc_Tm t1 ->  tx1 ∉ fsk t1 ->
  subst (X:=Tm) (In:=Tm) t1 β1 (close_Tm_wrt_T tx1 t2) = close_Tm_wrt_T tx1 (subst (X:=Tm) (In:=Tm) t1 β1 t2).
Proof.
unfold close_Tm_wrt_T; default_simp.
Qed.

#[export] Hint Resolve subst_tvar_Tm_close_Tm_wrt_T : lngen.

Lemma subst_tvar_Tm_close_Tm_wrt_Tm :
forall t2 t1 tx1 tx2,
  lc_Tm t1 ->  tx1 <> tx2 ->
  tx2 ∉ fv t1 ->
  subst (X:=Tm) (In:=Tm) t1 tx1 (close_Tm_wrt_Tm tx2 t2) = close_Tm_wrt_Tm tx2 (subst (X:=Tm) (In:=Tm) t1 tx1 t2).
Proof.
unfold close_Tm_wrt_Tm; default_simp.
Qed.

#[export] Hint Resolve subst_tvar_Tm_close_Tm_wrt_Tm : lngen.

(*hidden lems removed*)

Lemma subst_var_Ex_degree_Ex_wrt_Ex :
forall e1 e2 x1 n1,
  degree_Ex_wrt_Ex n1 e1 ->
  degree_Ex_wrt_Ex n1 e2 ->
  degree_Ex_wrt_Ex n1 (subst (X:=Ex) (In:=Ex) e2 x1 e1).
Proof.
pose proof subst_var_Ex_degree_Ex_wrt_Ex_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve subst_var_Ex_degree_Ex_wrt_Ex : lngen.

(*hidden lems removed*)

Lemma subst_skvar_T_degree_T_wrt_T :
forall T1 T2 β1 n1,
  degree_T_wrt_T n1 T1 ->
  degree_T_wrt_T n1 T2 ->
  degree_T_wrt_T n1 (subst_skvar_T T2 β1 T1).
Proof.
pose proof subst_skvar_T_degree_T_wrt_T_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve subst_skvar_T_degree_T_wrt_T : lngen.

(*hidden lems removed*)

Lemma subst_skvar_Sc_degree_Sc_wrt_T :
forall Sc1 T1 β1 n1,
  degree_Sc_wrt_T n1 Sc1 ->
  degree_T_wrt_T n1 T1 ->
  degree_Sc_wrt_T n1 (subst_skvar_Sc T1 β1 Sc1).
Proof.
pose proof subst_skvar_Sc_degree_Sc_wrt_T_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve subst_skvar_Sc_degree_Sc_wrt_T : lngen.

(*hidden lems removed*)

Lemma subst_skvar_Tm_degree_Tm_wrt_T :
forall t1 T1 β1 n1,
  degree_Tm_wrt_T n1 t1 ->
  degree_T_wrt_T n1 T1 ->
  degree_Tm_wrt_T n1 (subst_skvar_Tm T1 β1 t1).
Proof.
pose proof subst_skvar_Tm_degree_Tm_wrt_T_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve subst_skvar_Tm_degree_Tm_wrt_T : lngen.

(*hidden lems removed*)

Lemma subst_skvar_Tm_degree_Tm_wrt_Tm :
forall t1 T1 β1 n1,
  degree_Tm_wrt_Tm n1 t1 ->
  degree_Tm_wrt_Tm n1 (subst_skvar_Tm T1 β1 t1).
Proof.
pose proof subst_skvar_Tm_degree_Tm_wrt_Tm_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve subst_skvar_Tm_degree_Tm_wrt_Tm : lngen.

(*hidden lems removed*)

Lemma subst_tvar_Tm_degree_Tm_wrt_T :
forall t1 t2 tx1 n1,
  degree_Tm_wrt_T n1 t1 ->
  degree_Tm_wrt_T n1 t2 ->
  degree_Tm_wrt_T n1 (subst (X:=Tm) (In:=Tm) t2 tx1 t1).
Proof.
pose proof subst_tvar_Tm_degree_Tm_wrt_T_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve subst_tvar_Tm_degree_Tm_wrt_T : lngen.

(*hidden lems removed*)

Lemma subst_tvar_Tm_degree_Tm_wrt_Tm :
forall t1 t2 tx1 n1,
  degree_Tm_wrt_Tm n1 t1 ->
  degree_Tm_wrt_Tm n1 t2 ->
  degree_Tm_wrt_Tm n1 (subst (X:=Tm) (In:=Tm) t2 tx1 t1).
Proof.
pose proof subst_tvar_Tm_degree_Tm_wrt_Tm_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve subst_tvar_Tm_degree_Tm_wrt_Tm : lngen.

(*hidden lems removed*)

Lemma subst_var_Ex_fresh_eq :
forall e2 e1 x1,
  x1 ∉ fv_Ex e2 ->
  subst (X:=Ex) (In:=Ex) e1 x1 e2 = e2.
Proof.
pose proof subst_var_Ex_fresh_eq_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve subst_var_Ex_fresh_eq : lngen.
#[export] Hint Rewrite subst_var_Ex_fresh_eq using solve [auto] : lngen.

(*hidden lems removed*)

Lemma subst_skvar_T_fresh_eq :
forall T2 T1 β1,
  β1 ∉ fsk T2 ->
  subst_skvar_T T1 β1 T2 = T2.
Proof.
pose proof subst_skvar_T_fresh_eq_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve subst_skvar_T_fresh_eq : lngen.
#[export] Hint Rewrite subst_skvar_T_fresh_eq using solve [auto] : lngen.

(*hidden lems removed*)

Lemma subst_skvar_Sc_fresh_eq :
forall Sc1 T1 β1,
  β1 ∉ fsk Sc1 ->
  subst_skvar_Sc T1 β1 Sc1 = Sc1.
Proof.
pose proof subst_skvar_Sc_fresh_eq_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve subst_skvar_Sc_fresh_eq : lngen.
#[export] Hint Rewrite subst_skvar_Sc_fresh_eq using solve [auto] : lngen.

(*hidden lems removed*)

Lemma subst_skvar_Tm_fresh_eq :
forall t1 T1 β1,
  β1 ∉ fsk t1 ->
  subst_skvar_Tm T1 β1 t1 = t1.
Proof.
pose proof subst_skvar_Tm_fresh_eq_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve subst_skvar_Tm_fresh_eq : lngen.
#[export] Hint Rewrite subst_skvar_Tm_fresh_eq using solve [auto] : lngen.

(*hidden lems removed*)

Lemma subst_tvar_Tm_fresh_eq :
forall t2 t1 tx1,
  tx1 ∉ fv t2 ->
  subst (X:=Tm) (In:=Tm) t1 tx1 t2 = t2.
Proof.
pose proof subst_tvar_Tm_fresh_eq_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve subst_tvar_Tm_fresh_eq : lngen.
#[export] Hint Rewrite subst_tvar_Tm_fresh_eq using solve [auto] : lngen.

(*hidden lems removed*)

Lemma subst_var_Ex_fresh_same :
forall e2 e1 x1,
  x1 ∉ fv_Ex e1 ->
  x1 ∉ fv_Ex (subst (X:=Ex) (In:=Ex) e1 x1 e2).
Proof.
pose proof subst_var_Ex_fresh_same_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve subst_var_Ex_fresh_same : lngen.

(*hidden lems removed*)

Lemma subst_skvar_T_fresh_same :
forall T2 T1 β1,
  β1 ∉ fsk T1 ->
  β1 ∉ fsk (subst_skvar_T T1 β1 T2).
Proof.
pose proof subst_skvar_T_fresh_same_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve subst_skvar_T_fresh_same : lngen.

(*hidden lems removed*)

Lemma subst_skvar_Sc_fresh_same :
forall Sc1 T1 β1,
  β1 ∉ fsk T1 ->
  β1 ∉ fsk (subst_skvar_Sc T1 β1 Sc1).
Proof.
pose proof subst_skvar_Sc_fresh_same_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve subst_skvar_Sc_fresh_same : lngen.

(*hidden lems removed*)

Lemma subst_skvar_Tm_fresh_same :
forall t1 T1 β1,
  β1 ∉ fsk T1 ->
  β1 ∉ fsk (subst_skvar_Tm T1 β1 t1).
Proof.
pose proof subst_skvar_Tm_fresh_same_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve subst_skvar_Tm_fresh_same : lngen.

(*hidden lems removed*)

Lemma subst_tvar_Tm_fresh_same :
forall t2 t1 tx1,
  tx1 ∉ fv t1 ->
  tx1 ∉ fv (subst (X:=Tm) (In:=Tm) t1 tx1 t2).
Proof.
pose proof subst_tvar_Tm_fresh_same_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve subst_tvar_Tm_fresh_same : lngen.

(*hidden lems removed*)

Lemma subst_var_Ex_fresh :
forall e2 e1 x1 x2,
  x1 ∉ fv_Ex e2 ->
  x1 ∉ fv_Ex e1 ->
  x1 ∉ fv_Ex (subst (X:=Ex) (In:=Ex) e1 x2 e2).
Proof.
pose proof subst_var_Ex_fresh_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve subst_var_Ex_fresh : lngen.

(*hidden lems removed*)

Lemma subst_skvar_T_fresh :
forall T2 T1 β1 β2,
  β1 ∉ fsk T2 ->
  β1 ∉ fsk T1 ->
  β1 ∉ fsk (subst_skvar_T T1 β2 T2).
Proof.
pose proof subst_skvar_T_fresh_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve subst_skvar_T_fresh : lngen.

(*hidden lems removed*)

Lemma subst_skvar_Sc_fresh :
forall Sc1 T1 β1 β2,
  β1 ∉ fsk Sc1 ->
  β1 ∉ fsk T1 ->
  β1 ∉ fsk (subst_skvar_Sc T1 β2 Sc1).
Proof.
pose proof subst_skvar_Sc_fresh_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve subst_skvar_Sc_fresh : lngen.

(*hidden lems removed*)

Lemma subst_skvar_Tm_fresh :
forall t1 T1 β1 β2,
  β1 ∉ fsk t1 ->
  β1 ∉ fsk T1 ->
  β1 ∉ fsk (subst_skvar_Tm T1 β2 t1).
Proof.
pose proof subst_skvar_Tm_fresh_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve subst_skvar_Tm_fresh : lngen.

(*hidden lems removed*)

Lemma subst_tvar_Tm_fresh :
forall t2 t1 tx1 tx2,
  tx1 ∉ fv t2 ->
  tx1 ∉ fv t1 ->
  tx1 ∉ fv (subst (X:=Tm) (In:=Tm) t1 tx2 t2).
Proof.
pose proof subst_tvar_Tm_fresh_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve subst_tvar_Tm_fresh : lngen.

Lemma subst_var_Ex_lc_Ex :
forall e1 e2 x1,
  lc_Ex e1 ->
  lc_Ex e2 ->
  lc_Ex (subst (X:=Ex) (In:=Ex) e2 x1 e1).
Proof.
default_simp.
Qed.

#[export] Hint Resolve subst_var_Ex_lc_Ex : lngen.

Lemma subst_skvar_T_lc_T :
forall T1 T2 β1,
  lc_T T1 ->
  lc_T T2 ->
  lc_T (subst_skvar_T T2 β1 T1).
Proof.
default_simp.
Qed.

#[export] Hint Resolve subst_skvar_T_lc_T : lngen.

Lemma subst_skvar_Sc_lc_Sc :
forall Sc1 T1 β1,
  lc_Sc Sc1 ->
  lc_T T1 ->
  lc_Sc (subst_skvar_Sc T1 β1 Sc1).
Proof.
default_simp.
Qed.

#[export] Hint Resolve subst_skvar_Sc_lc_Sc : lngen.

Lemma subst_skvar_Tm_lc_Tm :
forall t1 T1 β1,
  lc_Tm t1 ->
  lc_T T1 ->
  lc_Tm (subst_skvar_Tm T1 β1 t1).
Proof.
default_simp.
Qed.

#[export] Hint Resolve subst_skvar_Tm_lc_Tm : lngen.

Lemma subst_tvar_Tm_lc_Tm :
forall t1 t2 tx1,
  lc_Tm t1 ->
  lc_Tm t2 ->
  lc_Tm (subst (X:=Tm) (In:=Tm) t2 tx1 t1).
Proof.
default_simp.
Qed.

#[export] Hint Resolve subst_tvar_Tm_lc_Tm : lngen.

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

Lemma subst_var_Ex_open_Ex_wrt_Ex :
forall e3 e1 e2 x1,
  lc_Ex e1 ->
  subst (X:=Ex) (In:=Ex) e1 x1 (open_Ex_wrt_Ex e3 e2) = open_Ex_wrt_Ex (subst (X:=Ex) (In:=Ex) e1 x1 e3) (subst (X:=Ex) (In:=Ex) e1 x1 e2).
Proof.
unfold open_Ex_wrt_Ex; default_simp.
Qed.

#[export] Hint Resolve subst_var_Ex_open_Ex_wrt_Ex : lngen.

Lemma subst_skvar_T_open_T_wrt_T :
forall T3 T1 T2 β1,
  lc_T T1 ->
  subst_skvar_T T1 β1 (open_T_wrt_T T3 T2) = open_T_wrt_T (subst_skvar_T T1 β1 T3) (subst_skvar_T T1 β1 T2).
Proof.
unfold open_T_wrt_T; default_simp.
Qed.

#[export] Hint Resolve subst_skvar_T_open_T_wrt_T : lngen.

Lemma subst_skvar_Sc_open_Sc_wrt_T :
forall Sc1 T1 T2 β1,
  lc_T T1 ->
  subst_skvar_Sc T1 β1 (open_Sc_wrt_T Sc1 T2) = open_Sc_wrt_T (subst_skvar_Sc T1 β1 Sc1) (subst_skvar_T T1 β1 T2).
Proof.
unfold open_Sc_wrt_T; default_simp.
Qed.

#[export] Hint Resolve subst_skvar_Sc_open_Sc_wrt_T : lngen.

Lemma subst_skvar_Tm_open_Tm_wrt_T :
forall t1 T1 T2 β1,
  lc_T T1 ->
  subst_skvar_Tm T1 β1 (open_Tm_wrt_T t1 T2) = open_Tm_wrt_T (subst_skvar_Tm T1 β1 t1) (subst_skvar_T T1 β1 T2).
Proof.
unfold open_Tm_wrt_T; default_simp.
Qed.

#[export] Hint Resolve subst_skvar_Tm_open_Tm_wrt_T : lngen.

Lemma subst_skvar_Tm_open_Tm_wrt_Tm :
forall t2 T1 t1 β1,
  subst_skvar_Tm T1 β1 (open_Tm_wrt_Tm t2 t1) = open_Tm_wrt_Tm (subst_skvar_Tm T1 β1 t2) (subst_skvar_Tm T1 β1 t1).
Proof.
unfold open_Tm_wrt_Tm; default_simp.
Qed.

#[export] Hint Resolve subst_skvar_Tm_open_Tm_wrt_Tm : lngen.

Lemma subst_tvar_Tm_open_Tm_wrt_T :
forall t2 t1 T1 tx1,
  lc_Tm t1 ->
  subst (X:=Tm) (In:=Tm) t1 tx1 (open_Tm_wrt_T t2 T1) = open_Tm_wrt_T (subst (X:=Tm) (In:=Tm) t1 tx1 t2) T1.
Proof.
unfold open_Tm_wrt_T; default_simp.
Qed.

#[export] Hint Resolve subst_tvar_Tm_open_Tm_wrt_T : lngen.

Lemma subst_tvar_Tm_open_Tm_wrt_Tm :
forall t3 t1 t2 tx1,
  lc_Tm t1 ->
  subst (X:=Tm) (In:=Tm) t1 tx1 (open_Tm_wrt_Tm t3 t2) = open_Tm_wrt_Tm (subst (X:=Tm) (In:=Tm) t1 tx1 t3) (subst (X:=Tm) (In:=Tm) t1 tx1 t2).
Proof.
unfold open_Tm_wrt_Tm; default_simp.
Qed.

#[export] Hint Resolve subst_tvar_Tm_open_Tm_wrt_Tm : lngen.

Lemma subst_var_Ex_open_Ex_wrt_Ex_var :
forall e2 e1 x1 x2,
  x1 <> x2 ->
  lc_Ex e1 ->
  open_Ex_wrt_Ex (subst (X:=Ex) (In:=Ex) e1 x1 e2) (e__Var_f x2) = subst (X:=Ex) (In:=Ex) e1 x1 (open_Ex_wrt_Ex e2 (e__Var_f x2)).
Proof.
intros; rewrite subst_var_Ex_open_Ex_wrt_Ex; default_simp.
Qed.

#[export] Hint Resolve subst_var_Ex_open_Ex_wrt_Ex_var : lngen.

Lemma subst_skvar_T_open_T_wrt_T_var :
forall T2 T1 β1 β2,
  β1 <> β2 ->
  lc_T T1 ->
  open_T_wrt_T (subst_skvar_T T1 β1 T2) (T__Skvar_f β2) = subst_skvar_T T1 β1 (open_T_wrt_T T2 (T__Skvar_f β2)).
Proof.
intros; rewrite subst_skvar_T_open_T_wrt_T; default_simp.
Qed.

#[export] Hint Resolve subst_skvar_T_open_T_wrt_T_var : lngen.

Lemma subst_skvar_Sc_open_Sc_wrt_T_var :
forall Sc1 T1 β1 β2,
  β1 <> β2 ->
  lc_T T1 ->
  open_Sc_wrt_T (subst_skvar_Sc T1 β1 Sc1) (T__Skvar_f β2) = subst_skvar_Sc T1 β1 (open_Sc_wrt_T Sc1 (T__Skvar_f β2)).
Proof.
intros; rewrite subst_skvar_Sc_open_Sc_wrt_T; default_simp.
Qed.

#[export] Hint Resolve subst_skvar_Sc_open_Sc_wrt_T_var : lngen.

Lemma subst_skvar_Tm_open_Tm_wrt_T_var :
forall t1 T1 β1 β2,
  β1 <> β2 ->
  lc_T T1 ->
  open_Tm_wrt_T (subst_skvar_Tm T1 β1 t1) (T__Skvar_f β2) = subst_skvar_Tm T1 β1 (open_Tm_wrt_T t1 (T__Skvar_f β2)).
Proof.
intros; rewrite subst_skvar_Tm_open_Tm_wrt_T; default_simp.
Qed.

#[export] Hint Resolve subst_skvar_Tm_open_Tm_wrt_T_var : lngen.

Lemma subst_skvar_Tm_open_Tm_wrt_Tm_var :
forall t1 T1 β1 tx1,
  open_Tm_wrt_Tm (subst_skvar_Tm T1 β1 t1) (t__Tvar_f tx1) = subst_skvar_Tm T1 β1 (open_Tm_wrt_Tm t1 (t__Tvar_f tx1)).
Proof.
intros; rewrite subst_skvar_Tm_open_Tm_wrt_Tm; default_simp.
Qed.

#[export] Hint Resolve subst_skvar_Tm_open_Tm_wrt_Tm_var : lngen.

Lemma subst_tvar_Tm_open_Tm_wrt_T_var :
forall t2 t1 tx1 β1,
  lc_Tm t1 ->
  open_Tm_wrt_T (subst (X:=Tm) (In:=Tm) t1 tx1 t2) (T__Skvar_f β1) = subst (X:=Tm) (In:=Tm) t1 tx1 (open_Tm_wrt_T t2 (T__Skvar_f β1)).
Proof.
intros; rewrite subst_tvar_Tm_open_Tm_wrt_T; default_simp.
Qed.

#[export] Hint Resolve subst_tvar_Tm_open_Tm_wrt_T_var : lngen.

Lemma subst_tvar_Tm_open_Tm_wrt_Tm_var :
forall t2 t1 tx1 tx2,
  tx1 <> tx2 ->
  lc_Tm t1 ->
  open_Tm_wrt_Tm (subst (X:=Tm) (In:=Tm) t1 tx1 t2) (t__Tvar_f tx2) = subst (X:=Tm) (In:=Tm) t1 tx1 (open_Tm_wrt_Tm t2 (t__Tvar_f tx2)).
Proof.
intros; rewrite subst_tvar_Tm_open_Tm_wrt_Tm; default_simp.
Qed.

#[export] Hint Resolve subst_tvar_Tm_open_Tm_wrt_Tm_var : lngen.

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

Lemma subst_var_Ex_spec :
forall e1 e2 x1,
  subst (X:=Ex) (In:=Ex) e2 x1 e1 = open_Ex_wrt_Ex (close_Ex_wrt_Ex x1 e1) e2.
Proof.
unfold close_Ex_wrt_Ex; unfold open_Ex_wrt_Ex; default_simp.
Qed.

#[export] Hint Resolve subst_var_Ex_spec : lngen.

Lemma subst_skvar_T_spec :
forall T1 T2 β1,
  subst_skvar_T T2 β1 T1 = open_T_wrt_T (close_T_wrt_T β1 T1) T2.
Proof.
unfold close_T_wrt_T; unfold open_T_wrt_T; default_simp.
Qed.

#[export] Hint Resolve subst_skvar_T_spec : lngen.

Lemma subst_skvar_Sc_spec :
forall Sc1 T1 β1,
  subst_skvar_Sc T1 β1 Sc1 = open_Sc_wrt_T (close_Sc_wrt_T β1 Sc1) T1.
Proof.
unfold close_Sc_wrt_T; unfold open_Sc_wrt_T; default_simp.
Qed.

#[export] Hint Resolve subst_skvar_Sc_spec : lngen.

Lemma subst_skvar_Tm_spec :
forall t1 T1 β1,
  subst_skvar_Tm T1 β1 t1 = open_Tm_wrt_T (close_Tm_wrt_T β1 t1) T1.
Proof.
unfold close_Tm_wrt_T; unfold open_Tm_wrt_T; default_simp.
Qed.

#[export] Hint Resolve subst_skvar_Tm_spec : lngen.

Lemma subst_tvar_Tm_spec :
forall t1 t2 tx1,
  subst (X:=Tm) (In:=Tm) t2 tx1 t1 = open_Tm_wrt_Tm (close_Tm_wrt_Tm tx1 t1) t2.
Proof.
unfold close_Tm_wrt_Tm; unfold open_Tm_wrt_Tm; default_simp.
Qed.

#[export] Hint Resolve subst_tvar_Tm_spec : lngen.

(*hidden lems removed*)

Lemma subst_var_Ex_subst_var_Ex :
forall e1 e2 e3 x2 x1,
  x2 ∉ fv_Ex e2 ->
  x2 <> x1 ->
  subst (X:=Ex) (In:=Ex) e2 x1 (subst (X:=Ex) (In:=Ex) e3 x2 e1) = subst (X:=Ex) (In:=Ex) (subst (X:=Ex) (In:=Ex) e2 x1 e3) x2 (subst (X:=Ex) (In:=Ex) e2 x1 e1).
Proof.
pose proof subst_var_Ex_subst_var_Ex_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve subst_var_Ex_subst_var_Ex : lngen.

(*hidden lems removed*)

Lemma subst_skvar_T_subst_skvar_T :
forall T1 T2 T3 β2 β1,
  β2 ∉ fsk T2 ->
  β2 <> β1 ->
  subst_skvar_T T2 β1 (subst_skvar_T T3 β2 T1) = subst_skvar_T (subst_skvar_T T2 β1 T3) β2 (subst_skvar_T T2 β1 T1).
Proof.
pose proof subst_skvar_T_subst_skvar_T_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve subst_skvar_T_subst_skvar_T : lngen.

(*hidden lems removed*)

Lemma subst_skvar_Sc_subst_skvar_Sc :
forall Sc1 T1 T2 β2 β1,
  β2 ∉ fsk T1 ->
  β2 <> β1 ->
  subst_skvar_Sc T1 β1 (subst_skvar_Sc T2 β2 Sc1) = subst_skvar_Sc (subst_skvar_T T1 β1 T2) β2 (subst_skvar_Sc T1 β1 Sc1).
Proof.
pose proof subst_skvar_Sc_subst_skvar_Sc_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve subst_skvar_Sc_subst_skvar_Sc : lngen.

(*hidden lems removed*)

Lemma subst_skvar_Tm_subst_skvar_Tm :
forall t1 T1 T2 β2 β1,
  β2 ∉ fsk T1 ->
  β2 <> β1 ->
  subst_skvar_Tm T1 β1 (subst_skvar_Tm T2 β2 t1) = subst_skvar_Tm (subst_skvar_T T1 β1 T2) β2 (subst_skvar_Tm T1 β1 t1).
Proof.
pose proof subst_skvar_Tm_subst_skvar_Tm_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve subst_skvar_Tm_subst_skvar_Tm : lngen.

(*hidden lems removed*)

Lemma subst_skvar_Tm_subst_tvar_Tm :
forall t1 T1 t2 tx1 β1,
  subst_skvar_Tm T1 β1 (subst (X:=Tm) (In:=Tm) t2 tx1 t1) = subst (X:=Tm) (In:=Tm) (subst_skvar_Tm T1 β1 t2) tx1 (subst_skvar_Tm T1 β1 t1).
Proof.
pose proof subst_skvar_Tm_subst_tvar_Tm_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve subst_skvar_Tm_subst_tvar_Tm : lngen.

(*hidden lems removed*)

Lemma subst_tvar_Tm_subst_skvar_Tm :
forall t1 t2 T1 β1 tx1,
  β1 ∉ fsk t2 ->
  subst (X:=Tm) (In:=Tm) t2 tx1 (subst_skvar_Tm T1 β1 t1) = subst_skvar_Tm T1 β1 (subst (X:=Tm) (In:=Tm) t2 tx1 t1).
Proof.
pose proof subst_tvar_Tm_subst_skvar_Tm_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve subst_tvar_Tm_subst_skvar_Tm : lngen.

(*hidden lems removed*)

Lemma subst_tvar_Tm_subst_tvar_Tm :
forall t1 t2 t3 tx2 tx1,
  tx2 ∉ fv t2 ->
  tx2 <> tx1 ->
  subst (X:=Tm) (In:=Tm) t2 tx1 (subst (X:=Tm) (In:=Tm) t3 tx2 t1) = subst (X:=Tm) (In:=Tm) (subst (X:=Tm) (In:=Tm) t2 tx1 t3) tx2 (subst (X:=Tm) (In:=Tm) t2 tx1 t1).
Proof.
pose proof subst_tvar_Tm_subst_tvar_Tm_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve subst_tvar_Tm_subst_tvar_Tm : lngen.

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

(*hidden lems removed*)

Lemma subst_var_Ex_close_Ex_wrt_Ex_open_Ex_wrt_Ex :
forall e2 e1 x1 x2,
  x2 ∉ fv_Ex e2 ->
  x2 ∉ fv_Ex e1 ->
  x2 <> x1 ->
  lc_Ex e1 ->
  subst (X:=Ex) (In:=Ex) e1 x1 e2 = close_Ex_wrt_Ex x2 (subst (X:=Ex) (In:=Ex) e1 x1 (open_Ex_wrt_Ex e2 (e__Var_f x2))).
Proof.
unfold close_Ex_wrt_Ex; unfold open_Ex_wrt_Ex; default_simp.
Qed.

#[export] Hint Resolve subst_var_Ex_close_Ex_wrt_Ex_open_Ex_wrt_Ex : lngen.

Lemma subst_skvar_T_close_T_wrt_T_open_T_wrt_T :
forall T2 T1 β1 β2,
  β2 ∉ fsk T2 ->
  β2 ∉ fsk T1 ->
  β2 <> β1 ->
  lc_T T1 ->
  subst_skvar_T T1 β1 T2 = close_T_wrt_T β2 (subst_skvar_T T1 β1 (open_T_wrt_T T2 (T__Skvar_f β2))).
Proof.
unfold close_T_wrt_T; unfold open_T_wrt_T; default_simp.
Qed.

#[export] Hint Resolve subst_skvar_T_close_T_wrt_T_open_T_wrt_T : lngen.

Lemma subst_skvar_Sc_close_Sc_wrt_T_open_Sc_wrt_T :
forall Sc1 T1 β1 β2,
  β2 ∉ fsk Sc1 ->
  β2 ∉ fsk T1 ->
  β2 <> β1 ->
  lc_T T1 ->
  subst_skvar_Sc T1 β1 Sc1 = close_Sc_wrt_T β2 (subst_skvar_Sc T1 β1 (open_Sc_wrt_T Sc1 (T__Skvar_f β2))).
Proof.
unfold close_Sc_wrt_T; unfold open_Sc_wrt_T; default_simp.
Qed.

#[export] Hint Resolve subst_skvar_Sc_close_Sc_wrt_T_open_Sc_wrt_T : lngen.

Lemma subst_skvar_Tm_close_Tm_wrt_T_open_Tm_wrt_T :
forall t1 T1 β1 β2,
  β2 ∉ fsk t1 ->
  β2 ∉ fsk T1 ->
  β2 <> β1 ->
  lc_T T1 ->
  subst_skvar_Tm T1 β1 t1 = close_Tm_wrt_T β2 (subst_skvar_Tm T1 β1 (open_Tm_wrt_T t1 (T__Skvar_f β2))).
Proof.
unfold close_Tm_wrt_T; unfold open_Tm_wrt_T; default_simp.
Qed.

#[export] Hint Resolve subst_skvar_Tm_close_Tm_wrt_T_open_Tm_wrt_T : lngen.

Lemma subst_skvar_Tm_close_Tm_wrt_Tm_open_Tm_wrt_Tm :
forall t1 T1 β1 tx1,
  tx1 ∉ fv t1 ->
  lc_T T1 ->
  subst_skvar_Tm T1 β1 t1 = close_Tm_wrt_Tm tx1 (subst_skvar_Tm T1 β1 (open_Tm_wrt_Tm t1 (t__Tvar_f tx1))).
Proof.
unfold close_Tm_wrt_Tm; unfold open_Tm_wrt_Tm; default_simp.
Qed.

#[export] Hint Resolve subst_skvar_Tm_close_Tm_wrt_Tm_open_Tm_wrt_Tm : lngen.

Lemma subst_tvar_Tm_close_Tm_wrt_T_open_Tm_wrt_T :
forall t2 t1 tx1 β1,
  β1 ∉ fsk t2 ->
  β1 ∉ fsk t1 ->
  lc_Tm t1 ->
  subst (X:=Tm) (In:=Tm) t1 tx1 t2 = close_Tm_wrt_T β1 (subst (X:=Tm) (In:=Tm) t1 tx1 (open_Tm_wrt_T t2 (T__Skvar_f β1))).
Proof.
unfold close_Tm_wrt_T; unfold open_Tm_wrt_T; default_simp.
Qed.

#[export] Hint Resolve subst_tvar_Tm_close_Tm_wrt_T_open_Tm_wrt_T : lngen.

Lemma subst_tvar_Tm_close_Tm_wrt_Tm_open_Tm_wrt_Tm :
forall t2 t1 tx1 tx2,
  tx2 ∉ fv t2 ->
  tx2 ∉ fv t1 ->
  tx2 <> tx1 ->
  lc_Tm t1 ->
  subst (X:=Tm) (In:=Tm) t1 tx1 t2 = close_Tm_wrt_Tm tx2 (subst (X:=Tm) (In:=Tm) t1 tx1 (open_Tm_wrt_Tm t2 (t__Tvar_f tx2))).
Proof.
unfold close_Tm_wrt_Tm; unfold open_Tm_wrt_Tm; default_simp.
Qed.

#[export] Hint Resolve subst_tvar_Tm_close_Tm_wrt_Tm_open_Tm_wrt_Tm : lngen.

Lemma subst_var_Ex_e__Lam :
forall x2 e2 e1 x1,
  lc_Ex e1 ->
  x2 ∉ fv_Ex e1 `union` fv_Ex e2 `union` singleton x1 ->
  subst (X:=Ex) (In:=Ex) e1 x1 (e__Lam e2) = e__Lam (close_Ex_wrt_Ex x2 (subst (X:=Ex) (In:=Ex) e1 x1 (open_Ex_wrt_Ex e2 (e__Var_f x2)))).
Proof.
default_simp.
Qed.

#[export] Hint Resolve subst_var_Ex_e__Lam : lngen.

Lemma subst_var_Ex_e__Let :
forall x2 e2 e3 e1 x1,
  lc_Ex e1 ->
  x2 ∉ fv_Ex e1 `union` fv_Ex e3 `union` singleton x1 ->
  subst (X:=Ex) (In:=Ex) e1 x1 (e__Let e2 e3) = e__Let (subst (X:=Ex) (In:=Ex) e1 x1 e2) (close_Ex_wrt_Ex x2 (subst (X:=Ex) (In:=Ex) e1 x1 (open_Ex_wrt_Ex e3 (e__Var_f x2)))).
Proof.
default_simp.
Qed.

#[export] Hint Resolve subst_var_Ex_e__Let : lngen.

Lemma subst_skvar_Sc_S__Forall :
forall α1 σ1 T1 β1,
  lc_T T1 ->
  α1 ∉ fsk T1 `union` fsk σ1 `union` singleton β1 ->
  subst_skvar_Sc T1 β1 (S__Forall σ1) = S__Forall (close_Sc_wrt_T α1 (subst_skvar_Sc T1 β1 (open_Sc_wrt_T σ1 (T__Skvar_f α1)))).
Proof.
default_simp.
Qed.

#[export] Hint Resolve subst_skvar_Sc_S__Forall : lngen.

Lemma subst_skvar_Tm_t__Lam :
forall tx1 σ1 t1 T1 β1,
  lc_T T1 ->
  tx1 ∉ fv t1 ->
  subst_skvar_Tm T1 β1 (t__Lam σ1 t1) = t__Lam (subst_skvar_Sc T1 β1 σ1) (close_Tm_wrt_Tm tx1 (subst_skvar_Tm T1 β1 (open_Tm_wrt_Tm t1 (t__Tvar_f tx1)))).
Proof.
default_simp.
Qed.

#[export] Hint Resolve subst_skvar_Tm_t__Lam : lngen.

Lemma subst_skvar_Tm_t__Tlam :
forall α1 t1 T1 β1,
  lc_T T1 ->
  α1 ∉ fsk T1 `union` fsk t1 `union` singleton β1 ->
  subst_skvar_Tm T1 β1 (t__Tlam t1) = t__Tlam (close_Tm_wrt_T α1 (subst_skvar_Tm T1 β1 (open_Tm_wrt_T t1 (T__Skvar_f α1)))).
Proof.
default_simp.
Qed.

#[export] Hint Resolve subst_skvar_Tm_t__Tlam : lngen.

Lemma subst_skvar_Tm_t__Let :
forall tx1 σ1 t1 t2 T1 β1,
  lc_T T1 ->
  tx1 ∉ fv t2 ->
  subst_skvar_Tm T1 β1 (t__Let σ1 t1 t2) = t__Let (subst_skvar_Sc T1 β1 σ1) (subst_skvar_Tm T1 β1 t1) (close_Tm_wrt_Tm tx1 (subst_skvar_Tm T1 β1 (open_Tm_wrt_Tm t2 (t__Tvar_f tx1)))).
Proof.
default_simp.
Qed.

#[export] Hint Resolve subst_skvar_Tm_t__Let : lngen.

Lemma subst_tvar_Tm_t__Lam :
forall tx2 σ1 t2 t1 tx1,
  lc_Tm t1 ->
  tx2 ∉ fv t1 `union` fv t2 `union` singleton tx1 ->
  subst (X:=Tm) (In:=Tm) t1 tx1 (t__Lam σ1 t2) = t__Lam (σ1) (close_Tm_wrt_Tm tx2 (subst (X:=Tm) (In:=Tm) t1 tx1 (open_Tm_wrt_Tm t2 (t__Tvar_f tx2)))).
Proof.
default_simp.
Qed.

#[export] Hint Resolve subst_tvar_Tm_t__Lam : lngen.

Lemma subst_tvar_Tm_t__Tlam :
forall α1 t2 t1 tx1,
  lc_Tm t1 ->
  α1 ∉ fsk t1 `union` fsk t2 ->
  subst (X:=Tm) (In:=Tm) t1 tx1 (t__Tlam t2) = t__Tlam (close_Tm_wrt_T α1 (subst (X:=Tm) (In:=Tm) t1 tx1 (open_Tm_wrt_T t2 (T__Skvar_f α1)))).
Proof.
default_simp.
Qed.

#[export] Hint Resolve subst_tvar_Tm_t__Tlam : lngen.

Lemma subst_tvar_Tm_t__Let :
forall tx2 σ1 t2 t3 t1 tx1,
  lc_Tm t1 ->
  tx2 ∉ fv t1 `union` fv t3 `union` singleton tx1 ->
  subst (X:=Tm) (In:=Tm) t1 tx1 (t__Let σ1 t2 t3) = t__Let (σ1) (subst (X:=Tm) (In:=Tm) t1 tx1 t2) (close_Tm_wrt_Tm tx2 (subst (X:=Tm) (In:=Tm) t1 tx1 (open_Tm_wrt_Tm t3 (t__Tvar_f tx2)))).
Proof.
default_simp.
Qed.

#[export] Hint Resolve subst_tvar_Tm_t__Let : lngen.

(*hidden lems removed*)

Lemma subst_var_Ex_intro_rec :
forall e1 x1 e2 n1,
  x1 ∉ fv_Ex e1 ->
  open_Ex_wrt_Ex_rec n1 e2 e1 = subst (X:=Ex) (In:=Ex) e2 x1 (open_Ex_wrt_Ex_rec n1 (e__Var_f x1) e1).
Proof.
pose proof subst_var_Ex_intro_rec_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve subst_var_Ex_intro_rec : lngen.
#[export] Hint Rewrite subst_var_Ex_intro_rec using solve [auto] : lngen.

(*hidden lems removed*)

Lemma subst_skvar_T_intro_rec :
forall T1 β1 T2 n1,
  β1 ∉ fsk T1 ->
  open_T_wrt_T_rec n1 T2 T1 = subst_skvar_T T2 β1 (open_T_wrt_T_rec n1 (T__Skvar_f β1) T1).
Proof.
pose proof subst_skvar_T_intro_rec_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve subst_skvar_T_intro_rec : lngen.
#[export] Hint Rewrite subst_skvar_T_intro_rec using solve [auto] : lngen.

(*hidden lems removed*)

Lemma subst_skvar_Sc_intro_rec :
forall Sc1 β1 T1 n1,
  β1 ∉ fsk Sc1 ->
  open_Sc_wrt_T_rec n1 T1 Sc1 = subst_skvar_Sc T1 β1 (open_Sc_wrt_T_rec n1 (T__Skvar_f β1) Sc1).
Proof.
pose proof subst_skvar_Sc_intro_rec_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve subst_skvar_Sc_intro_rec : lngen.
#[export] Hint Rewrite subst_skvar_Sc_intro_rec using solve [auto] : lngen.

(*hidden lems removed*)

Lemma subst_skvar_Tm_intro_rec :
forall t1 β1 T1 n1,
  β1 ∉ fsk t1 ->
  open_Tm_wrt_T_rec n1 T1 t1 = subst_skvar_Tm T1 β1 (open_Tm_wrt_T_rec n1 (T__Skvar_f β1) t1).
Proof.
pose proof subst_skvar_Tm_intro_rec_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve subst_skvar_Tm_intro_rec : lngen.
#[export] Hint Rewrite subst_skvar_Tm_intro_rec using solve [auto] : lngen.

(*hidden lems removed*)

Lemma subst_tvar_Tm_intro_rec :
forall t1 tx1 t2 n1,
  tx1 ∉ fv t1 ->
  open_Tm_wrt_Tm_rec n1 t2 t1 = subst (X:=Tm) (In:=Tm) t2 tx1 (open_Tm_wrt_Tm_rec n1 (t__Tvar_f tx1) t1).
Proof.
pose proof subst_tvar_Tm_intro_rec_mutual as H; intuition eauto.
Qed.

#[export] Hint Resolve subst_tvar_Tm_intro_rec : lngen.
#[export] Hint Rewrite subst_tvar_Tm_intro_rec using solve [auto] : lngen.

Lemma subst_var_Ex_intro :
forall x1 e1 e2,
  x1 ∉ fv_Ex e1 ->
  open_Ex_wrt_Ex e1 e2 = subst (X:=Ex) (In:=Ex) e2 x1 (open_Ex_wrt_Ex e1 (e__Var_f x1)).
Proof.
unfold open_Ex_wrt_Ex; default_simp.
Qed.

#[export] Hint Resolve subst_var_Ex_intro : lngen.

Lemma subst_skvar_T_intro :
forall β1 T1 T2,
  β1 ∉ fsk T1 ->
  open_T_wrt_T T1 T2 = subst_skvar_T T2 β1 (open_T_wrt_T T1 (T__Skvar_f β1)).
Proof.
unfold open_T_wrt_T; default_simp.
Qed.

#[export] Hint Resolve subst_skvar_T_intro : lngen.

Lemma subst_skvar_Sc_intro :
forall β1 Sc1 T1,
  β1 ∉ fsk Sc1 ->
  open_Sc_wrt_T Sc1 T1 = subst_skvar_Sc T1 β1 (open_Sc_wrt_T Sc1 (T__Skvar_f β1)).
Proof.
unfold open_Sc_wrt_T; default_simp.
Qed.

#[export] Hint Resolve subst_skvar_Sc_intro : lngen.

Lemma subst_skvar_Tm_intro :
forall β1 t1 T1,
  β1 ∉ fsk t1 ->
  open_Tm_wrt_T t1 T1 = subst_skvar_Tm T1 β1 (open_Tm_wrt_T t1 (T__Skvar_f β1)).
Proof.
unfold open_Tm_wrt_T; default_simp.
Qed.

#[export] Hint Resolve subst_skvar_Tm_intro : lngen.

Lemma subst_tvar_Tm_intro :
forall tx1 t1 t2,
  tx1 ∉ fv t1 ->
  open_Tm_wrt_Tm t1 t2 = subst (X:=Tm) (In:=Tm) t2 tx1 (open_Tm_wrt_Tm t1 (t__Tvar_f tx1)).
Proof.
unfold open_Tm_wrt_Tm; default_simp.
Qed.

#[export] Hint Resolve subst_tvar_Tm_intro : lngen.


(* *********************************************************************** *)
(** * "Restore" tactics *)

Ltac default_auto ::= auto; tauto.
Ltac default_autorewrite ::= fail.

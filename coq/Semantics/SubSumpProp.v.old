Set Warnings "-notation-overridden,-intuition-auto-with-star".

Require Import Preamble.
Require Import Defs.HdmLems.

Require Import Defs.E.
Require Import Defs.ERels.
Require Import Defs.FrA.
Require Import Defs.Foralls.
Require Import Defs.Lc.
Require Import Defs.List.
Require Import Defs.OpenClose.
Require Import Defs.Sub.
Require Import Defs.Subx.
Require Import Defs.Subst.
Require Import Defs.SubSump.
Require Import Defs.SubSump.
Require Import Defs.TmTy.
Require Import Defs.WfE.

Require Import Semantics.EquivRel.
Require Import Semantics.LogRel.
Require Import Semantics.LogRelEProps.
Require Import Semantics.FundProp.
Require Import Semantics.FundProp.CompatTLam.
Require Import Semantics.FundProp.CompatTApp.

(*** Equiv symm *)
(** Rho flip *)
Definition R_flip (R:ğ“¡) : ğ“¡ := fun t1 t2 => R t2 t1.

#[derive(equations=no)] Equations rho_flip : rho -> rho :=
  rho_flip [] := [];
  rho_flip ((Ï„1, Ï„2, R, Î±)::Ï) := ((Ï„2, Ï„1, R_flip R, Î±) :: (rho_flip Ï)).

Ltac rho_ind Ï := induction Ï as [|[[[?Ï„1 ?Ï„2] ?R] ?Î±] Ï ?IH].

Fact rho_flip_Ï€1 : forall Ï,
  Ï€1 (rho_flip Ï) = Ï€2 Ï.
Proof. introv. rho_ind Ï. crush. simpl+. crush. Qed.
Fact rho_flip_Ï€2 : forall Ï,
  Ï€2 (rho_flip Ï) = Ï€1 Ï.
Proof. introv. rho_ind Ï. crush. simpl+. crush. Qed.
#[export] Hint Rewrite rho_flip_Ï€1 rho_flip_Ï€2 : core.

Fact rho_flip_involutive : forall Ï,
    rho_flip (rho_flip Ï) = Ï.
Proof. introv. rho_ind Ï. crush. simpl+. crush. Qed.

Fact dom_rho_flip : forall Ï,
    dom_rho (rho_flip Ï) = dom_rho Ï.
Proof. introv. rho_ind Ï. crush. simpl+. crush. Qed.

(** gamma flip *)
#[derive(equations=no)] Equations gamma_flip : gamma -> gamma :=
  gamma_flip [] := [];
  gamma_flip ((t1, t2, x)::Ï) := ((t2, t1, x) :: (gamma_flip Ï)).

Ltac gamma_ind Î³ := induction Î³ as [|[[?t1 ?t2] ?Î±] Î³ ?IH].

Fact gamma_flip_Ï€1 : forall Î³,
  Ï€1 (gamma_flip Î³) = Ï€2 Î³.
Proof. introv. gamma_ind Î³. crush. simpl+. crush. Qed.
Fact gamma_flip_Ï€2 : forall Î³,
  Ï€2 (gamma_flip Î³) = Ï€1 Î³.
Proof. introv. gamma_ind Î³. crush. simpl+. crush. Qed.
#[export] Hint Rewrite gamma_flip_Ï€1 gamma_flip_Ï€2 : core.

Fact dom_gamma_flip : forall Î³,
    dom_gamma (gamma_flip Î³) = dom_gamma Î³.
Proof. introv. gamma_ind Î³. crush. simpl+. crush. Qed.

(** lems *)
Lemma rho_elem_valid_symm: forall (Ï„2 Ï„1 : T) (R : ğ“¡),
    rho_elem_valid (Ï„2, Ï„1, R)
  -> rho_elem_valid (Ï„1, Ï„2, flip R).
Proof.
  intros. unfolds. splits. 1,2:crush.
  unfold flip. unfold Rel. crush.
Qed.

Lemma closed_vals_symm: forall (Ïƒ : Sc) (v1 v2 : Tm) (Ï : rho),
    closed_vals Ïƒ Ï v1 v2
  -> closed_vals Ïƒ (rho_flip Ï) v2 v1.
Proof. intros. unfold closed_vals in *. splits; simpl+; crush. Qed.

Lemma logrel_val_symm : forall Ïƒ v1 v2 Ï,
    â¦…v1 Ã— v2â¦† âˆˆ ğ’±âŸ¦ÏƒâŸ§ Ï
  -> â¦…v2 Ã— v1â¦† âˆˆ ğ’±âŸ¦ÏƒâŸ§ (rho_flip Ï).
Proof.
  intro Ïƒ. forall_ind Ïƒ. induction Ï„. all:introv EQ; simp' in *; destruct EQ as [CV EQ].
  all: split; auto using closed_vals_symm.
  - clear - EQ. rho_ind Ï. crush. simpl+ in *. if_dec; try unfold R_flip; crush.
  - crush.
  - crush.
  - destruct EQ as [t1 [t2 [EQ1 [E2 EQ]]]]. subst.
    exists t2 t1. splits. 1,2:simpl+; crush.
    intros v2' v1' VAL1. specializes EQ v1' v2'.
    specializes EQ. eapply IHÏ„1 in VAL1. applys_eq VAL1. symmetry. apply rho_flip_involutive.
    destruct EQ as [TMTY1 [TMTY2 [v1 [v2 [OP1 [OP2 VAL2]]]]]].
    splits. 1,2:simpl+; eassumption. exists v2 v1.
    splits. 1,2:eassumption. eapply IHÏ„2 in VAL2. applys_eq VAL2.
  - destruct EQ as [t1 [t2 [EQ1 [E2 EQ]]]]. exists t2 t1. splits. 1,2:crush.
    intros Ï„2 Ï„1 R. specializes EQ Ï„1 Ï„2 (flip R).
    destruct EQ as [L EQ]. exists L.
    intros Î± NIL__Î± RV. specializes EQ Î±. specializes EQ. fsetdec. auto using rho_elem_valid_symm.
    destruct EQ as [TMTY1 [TMTY2 [v1' [v2' [OP1 [OP2 VAL]]]]]]. splits. 1,2:simpl+; eassumption.
    exists v2' v1'. splits. 1,2:eassumption. apply IHn in VAL. 2:simpl+; reflexivity.
    applys_eq VAL.
Qed.

Lemma LogrelE_flip : forall Ïˆ Ï Î³,
    â¦…Ï, Î³â¦† âˆˆ â¦…ğ’Ÿ, ğ’¢â¦†âŸ¦ÏˆâŸ§
  -> â¦…rho_flip Ï, gamma_flip Î³â¦† âˆˆ â¦…ğ’Ÿ, ğ’¢â¦†âŸ¦ÏˆâŸ§.
Proof.
  induction Ïˆ. 2:induction a. all:introv IN; simp' in *; simpl+ in *.
  - crush.
  - destruct IN as [Ï„1 [Ï„2 [R [Ï' [EQ [RV [NIL IN]]]]]]]. subst.
    exists. splits. simpl+. reflexivity. apply rho_elem_valid_symm. eassumption.
    rewrite dom_rho_flip. fsetdec. eauto.
  - destruct IN as [v1 [v2 [Î³' [EQ [VAL [NIL IN']]]]]]. subst.
    exists. splits. simpl+. reflexivity. auto using logrel_val_symm.
    rewrite dom_gamma_flip. fsetdec. eauto.
Qed.

(** Prop *)
Lemma EquivRel_symm : forall Ïˆ t1 t2 Ïƒ,
    Ïˆ âŠ¢tâ‰ˆ t1 â‰ˆ t2 â–¸ Ïƒ
  -> Ïˆ âŠ¢tâ‰ˆ t2 â‰ˆ t1 â–¸ Ïƒ.
Proof.
  introv [TMTY1 [TMTY2 EQ]]. splits. 1,2:eassumption.
  introv IN. specializes EQ (rho_flip Ï) (gamma_flip Î³). specializes EQ. auto using LogrelE_flip.
  simpl+ in *. destruct EQ as [CLTMTY1 [CLTMTY2 [v1 [v2 [OP1 [OP2 EQ]]]]]].
  splits. 1,2:eauto using TmTy_close1, TmTy_close2.
  exists. splits. eassumption. eassumption. applys_eq logrel_val_symm. 2:eassumption.
  symmetry. apply rho_flip_involutive.
Qed.

(*** Logrel trans *)
(** Rho trans *)
Definition R_trans (R1 R2:ğ“¡) : ğ“¡ := fun t1 t3 => exists t2, R1 t1 t2 /\ R2 t2 t3.
Definition R_id : ğ“¡ := fun t t' => t = t'.
Definition R_id' : ğ“¡ := fun t t' => t = t' /\ forall Ï„, â€¢ âŠ¢wfÏ„ Ï„ -> â€¢ âŠ¢t t â–¸ S__T Ï„.
Definition R_id'' (Ï„:T) : ğ“¡ := fun t t' => t = t' /\ â€¢ âŠ¢t t â–¸ S__T Ï„.

Require Import Coq.Logic.FunctionalExtensionality.
Lemma R_trans_R_id : forall (R:ğ“¡), forall t1 t2, (R_trans R R_id) t1 t2 <-> R t1 t2.
Proof.
  introv. unfold R_id. unfold R_trans. split; intro.
  - destruct H. destruct H. crush.
  - exists t2. crush.
Qed.

Lemma R_trans_R_id' : forall (R:ğ“¡), (R_trans R R_id) = R.
Proof.
  introv. apply functional_extensionality. intro.
  apply functional_extensionality. intro.
  unfold R_trans. unfold R_id.
Admitted.

(* #[derive(equations=no)] Equations rho_trans : rho -> rho -> option rho := *)
(*   rho_trans [] [] := Some []; *)
(*   rho_trans ((Ï„1, _, R__l, Î±__l)::Ï__l) ((_, Ï„3, R__r, Î±__r)::Ï__r) := *)
(*       if (eq_skvar Î±__l Î±__r) *)
(*       then option_map (fun Ï__zip => (Ï„1, Ï„3, (R_trans R__l R__r), Î±__l) :: Ï__zip) (rho_trans Ï__l Ï__r) *)
(*       else None; *)
(*   rho_trans _ _ := None. *)
#[derive(equations=no)] Equations rho_trans : rho -> rho -> rho :=
  rho_trans [] _  := [];
  rho_trans _  [] := [];
  rho_trans ((Ï„1, _, R__l, Î±__l)::Ï__l) ((_, Ï„3, R__r, Î±__r)::Ï__r) :=
      if (eq_skvar Î±__l Î±__r)
      then (Ï„1, Ï„3, (R_trans R__l R__r), Î±__l) :: rho_trans Ï__l Ï__r
      else [].

#[derive(equations=no)] Equations rho_id : rho -> rho :=
  rho_id [] := [];
  rho_id ((_, Ï„2, _, Î±) :: Ï) := ((Ï„2, Ï„2, R_id, Î±) :: rho_id Ï).
#[derive(equations=no)] Equations rho_id' : rho -> rho :=
  rho_id' [] := [];
  rho_id' ((_, Ï„2, _, Î±) :: Ï) := ((Ï„2, Ï„2, R_id', Î±) :: rho_id' Ï).
#[derive(equations=no)] Equations rho_id'' : rho -> rho :=
  rho_id'' [] := [];
  rho_id'' ((_, Ï„2, _, Î±) :: Ï) := ((Ï„2, Ï„2, R_id'' Ï„2, Î±) :: rho_id'' Ï).

Lemma rho_trans_id : forall Ï, rho_trans Ï (rho_id Ï) = Ï.
Proof.
  intros. ind_rho Ï. crush. simpl+.
  destruct (eq_skvar Î± Î±). 2:congruence. rewrite IHÏ. simpl+.
  rewrite R_trans_R_id'. crush.
Qed.

(* #[derive(equations=no)] Equations gamma_trans : gamma -> gamma -> option gamma := *)
(*   gamma_trans [] [] := Some []; *)
(*   gamma_trans ((t1, _, Î±__l)::Ï__l) ((_, t3, Î±__r)::Ï__r) := *)
(*       if (eq_skvar Î±__l Î±__r) *)
(*       then option_map (fun Ï__zip => (t1, t3, Î±__l) :: Ï__zip) (gamma_trans Ï__l Ï__r) *)
(*       else None; *)
(*   gamma_trans _ _ := None. *)
#[derive(equations=no)] Equations gamma_trans : gamma -> gamma -> gamma :=
  gamma_trans [] _  := [];
  gamma_trans _  [] := [];
  gamma_trans ((t1, _, Î±__l)::Î³__l) ((_, t3, Î±__r)::Î³__r) :=
      if (eq_skvar Î±__l Î±__r)
      then (t1, t3, Î±__l) :: (gamma_trans Î³__l Î³__r)
      else [].

#[derive(equations=no)] Equations gamma_id : gamma -> gamma :=
  gamma_id [] := [];
  gamma_id ((_, t2, Î±) :: Î³) := ((t2, t2, Î±) :: gamma_id Î³).

Lemma gamma_trans_id : forall Î³, gamma_trans Î³ (gamma_id Î³) = Î³.
Proof. introv. ind_gamma Î³. crush. simpl+. if_taut. Qed.

(* Axiom rho_trans : rho -> rho -> rho. *)
(* Axiom gamma_trans : gamma -> gamma -> gamma. *)

Axiom rho_trans_Ï€1 : forall Ï1 Ï2, Ï€1 (rho_trans Ï1 Ï2) = Ï€1 Ï1.
Axiom rho_trans_Ï€2 : forall Ï1 Ï2, Ï€2 (rho_trans Ï1 Ï2) = Ï€2 Ï2.
#[local] Hint Rewrite rho_trans_Ï€1 rho_trans_Ï€2 : core.

Axiom gamma_trans_Ï€1 : forall Î³1 Î³2, Ï€1 (gamma_trans Î³1 Î³2) = Ï€1 Î³1.
Axiom gamma_trans_Ï€2 : forall Î³1 Î³2, Ï€2 (gamma_trans Î³1 Î³2) = Ï€2 Î³2.
#[local] Hint Rewrite gamma_trans_Ï€1 gamma_trans_Ï€2 : core.


Lemma closed_vals_trans: forall (Ïƒ : Sc) (v1 v2 v2' v3: Tm) (Ï1 Ï2 : rho),
    closed_vals Ïƒ Ï1 v1 v2
  -> closed_vals Ïƒ Ï2 v2' v3
  -> closed_vals Ïƒ (rho_trans Ï1 Ï2) v1 v3.
Proof.
  introv [?IV [?IV [?TMTY ?TMTTY]]] [?IV [?IV [?TMTY ?TMTTY]]].
  splits. 1,2:eassumption. simpl+. eassumption. simpl+. eassumption.
Qed.

Axiom rho_id_Ï€1 : forall Ï, Ï€1 (rho_id Ï) = Ï€2 Ï.
Axiom rho_id_Ï€2 : forall Ï, Ï€2 (rho_id Ï) = Ï€2 Ï.
Axiom rho_id'_Ï€1 : forall Ï, Ï€1 (rho_id' Ï) = Ï€2 Ï.
Axiom rho_id'_Ï€2 : forall Ï, Ï€2 (rho_id' Ï) = Ï€2 Ï.
Axiom rho_id''_Ï€1 : forall Ï, Ï€1 (rho_id'' Ï) = Ï€2 Ï.
Axiom rho_id''_Ï€2 : forall Ï, Ï€2 (rho_id'' Ï) = Ï€2 Ï.
#[local] Hint Rewrite rho_id_Ï€1 rho_id_Ï€2 rho_id'_Ï€1 rho_id'_Ï€2 rho_id''_Ï€1 rho_id''_Ï€2 : core.

Axiom gamma_id_Ï€1 : forall Î³, Ï€1 (gamma_id Î³) = Ï€2 Î³.
Axiom gamma_id_Ï€2 : forall Î³, Ï€2 (gamma_id Î³) = Ï€2 Î³.
#[local] Hint Rewrite gamma_id_Ï€1 gamma_id_Ï€2 : core.

(* Lemma logrel_val_id : forall Ïƒ v1 v2 Ï, *)
(*     â¦…v1 Ã— v2â¦† âˆˆ ğ’±âŸ¦ÏƒâŸ§ (rho_id Ï) *)
(*   -> v2 = v1. *)
(* Proof. *)
(*   intro Ïƒ. forall_ind Ïƒ. induction Ï„. *)
(*   all:introv EQ; simp' in *; try destruct EQ as [CV EQ]. *)
(*   - crush. *)
(*   - clear CV. rho_ind Ï; simpl+ in EQ. crush. *)
(*     if_taut. crush. *)
(*   - crush. *)
(*   - crush. *)
(*   - simpl+ in EQ. *)
(*     destruct EQ as [t1 [t2 [?EQ [?EQ EQ]]]]. subst. fequals. *)
(* Abort. *)

Lemma closed_vals_trans' : forall (Ïƒ : Sc) (v1 v2 v2' v3: Tm) (Ï : rho),
    closed_vals Ïƒ Ï v1 v2
  -> closed_vals Ïƒ (rho_id'' Ï) v2' v3
  -> closed_vals Ïƒ Ï v1 v3.
Admitted.

Lemma closed_vals_id'' : forall (Ïƒ : Sc) (v1 v2 : Tm) (Ï : rho),
    closed_vals Ïƒ Ï v1 v2
  -> closed_vals Ïƒ (rho_id'' Ï) v2 v2.
Admitted.

Lemma logrel_rho_Rel : forall Ï„1 Ï„2 R Î± Ï Ïˆ,
    (Ï„1, Ï„2, R, Î±) :: Ï âˆˆ ğ’ŸâŸ¦ÏˆâŸ§
  -> Rel R Ï„1 Ï„2
  /\ exists Ïˆ', Ï âˆˆ ğ’ŸâŸ¦Ïˆ'âŸ§.
Proof.
  introv [Î³ IN]. gen Î³. induction Ïˆ; intros; try induction a; simp' in IN.
  - crush.
  - destruct IN as [Ï„1' [Ï„2' [R' [Ï' [EQ [RV [NIR IN]]]]]]]. inverts EQ.
    split. jauto. exists. eassumption.
  - destruct IN as [v1 [v2 [Î³' [EQ [VAL [NIG IN]]]]]]. subst. eauto.
Qed.

Fact dom_rho_id' : forall Ï, dom_rho (rho_id' Ï) âŠ† dom_rho Ï. Admitted.
Fact dom_rho_id'' : forall Ï, dom_rho (rho_id'' Ï) âŠ† dom_rho Ï. Admitted.
Fact dom_gamma_id : forall Î³, dom_gamma (gamma_id Î³) âŠ† dom_gamma Î³. Admitted.

Lemma logrel_val_id : forall Ïƒ v1 v2 Ï,
    â¦…v1 Ã— v2â¦† âˆˆ ğ’±âŸ¦ÏƒâŸ§ Ï
  -> (exists Ïˆ, Ï âˆˆ ğ’ŸâŸ¦ÏˆâŸ§)
  -> â¦…v2 Ã— v2â¦† âˆˆ ğ’±âŸ¦ÏƒâŸ§ rho_id'' Ï.
Proof.
  intro Ïƒ. forall_ind Ïƒ. induction Ï„.
  all:introv EQ IN; simp' in *; destruct EQ as [CV EQ].
  all: split; eauto using closed_vals_id''.
  - clear CV. ind_rho Ï. crush.
    destruct IN as [Ïˆ IN]. apply logrel_rho_Rel in IN. destruct IN as [H__R IN].
    simpl+ in *. if_taut. unfold R_id''.
    unfold Rel in H__R. specializes H__R. eassumption. jauto.
    specializes IHÏ IN. crush. crush.
  - crush.
  - crush.
  - destruct EQ as [t1 [t2 [?EQ [?EQ VAL]]]]. subst. exists. splits. 1,2:simpl+; reflexivity.
    intros v1' v2' VAL'. destruct IN as [Ïˆ [Î³ IN]].
    admit.
    (** Probleem: we krijgen hier â¦…v1' Ã— v2'â¦† âˆˆ ğ’±âŸ¦S__T Ï„1âŸ§ rho_id'' Ï binnen maar moeten â¦…v1' Ã— v2'â¦† âˆˆ ğ’±âŸ¦S__T Ï„1âŸ§ Ï produceren *)
  - destruct EQ as [t1 [t2 [EQ1 [EQ2 EQ]]]]. subst. exists. splits. 1,2:reflexivity.
    intros Ï„1 Ï„2 R. specializes EQ Ï„1 Ï„2 R. destruct EQ as [L EQ]. exists L.
    introÎ±. intro RV. specializes EQ NIL__Î± RV. destruct EQ as [TMTY1 [TMTY2 [v1 [v2 [OP1 [OP2 VAL]]]]]].
    (** euh hier weet ik het ook niet *)
    splits.
Admitted.


Lemma logrel_e_id : forall Ïˆ Ï Î³,
    â¦…Ï, Î³â¦† âˆˆ â¦…ğ’Ÿ, ğ’¢â¦†âŸ¦ÏˆâŸ§
  -> â¦…rho_id'' Ï, gamma_id Î³â¦† âˆˆ â¦…ğ’Ÿ, ğ’¢â¦†âŸ¦ÏˆâŸ§.
Proof.
  induction Ïˆ. 2:ind_a a. all:introv IN; simp' in *.
  - crush.
  - destruct IN as [Ï„1 [Ï„2 [R [Ï' [EQ [RV [NIL__Î± IN]]]]]]].
    exists. splits. subst. simpl+. crush. splits. 1,2:jauto. unfold R_id''. unfold Rel. intros. crush.
    rewrite dom_rho_id''. fsetdec. eauto.
  - destruct IN as [v1 [v2 [Î³' [EQ [VAL [NIL__x IN]]]]]].
    exists. splits. subst. crush.
    eauto using logrel_val_id.  rewrite dom_gamma_id. assumption. eauto.
Qed.

Lemma logrel_val_trans : forall Ïƒ v1 v2 v3 Ï,
    â¦…v1 Ã— v2â¦† âˆˆ ğ’±âŸ¦ÏƒâŸ§ Ï
  -> â¦…v2 Ã— v3â¦† âˆˆ ğ’±âŸ¦ÏƒâŸ§ (rho_id'' Ï)
  -> (exists Ïˆ, Ï âˆˆ ğ’ŸâŸ¦ÏˆâŸ§)
  -> â¦…v1 Ã— v3â¦† âˆˆ ğ’±âŸ¦ÏƒâŸ§ Ï.
Proof.
  intro Ïƒ. forall_ind Ïƒ. induction Ï„.
  all:introv EQ1 EQ2 IN; simp' in *; destruct EQ1 as [CV1 EQ1]; destruct EQ2 as [CV2 EQ2].
  all: split; eauto using closed_vals_trans'.
  - clear CV1 CV2. ind_rho Ï. simpl+ in *. crush.
    simpl+ in *. if_dec.
    + unfold R_id'' in EQ2. subst. crush.
    + destruct IN as [Ïˆ [Î³ IN]].
      forwards: logrel_rho_Rel. exists. eassumption.
      eapply IHÏ. crush. crush. crush.
  - crush.
  - crush.
  - simpl+ in EQ1. destruct EQ1 as [t1  [t2 [?EQ [?EQ EQ1]]]].
    simpl+ in EQ2. destruct EQ2 as [t2' [t3 [?EQ [?EQ EQ2]]]].
    destruct IN as [Ïˆ [Î³ IN]].
    subst. inverts EQ3.
    exists. splits. 1,2:reflexivity. intros v1 v2 VAL.
    specializes EQ1 v1 v2. specializes EQ1. eassumption.
      destruct EQ1 as [?TMTY [?TMTY [v1' [v2' [?OP [?OP VAL1]]]]]].
    specializes EQ2 v2 v2. specializes EQ2. eapply logrel_val_id. eassumption. exists. eassumption.
      destruct EQ2 as [?TMTY [?TMTY [v2'' [v3' [?OP [?OP VAL2]]]]]].
      forwards: t_cl_deterministic OP1 OP0. jauto. jauto. subst.
    splits. eassumption. eassumption.
    exists. splits. eassumption. eassumption. eauto.
  - simpl in EQ1. destruct EQ1 as [t1 [t2 [?EQ [?EQ EQ1]]]].
    simpl in EQ2. destruct EQ2 as [t2' [t3 [?EQ [?EQ EQ2]]]].
    subst. inverts EQ3.
    exists. splits. 1,2:reflexivity. intros Ï„1 Ï„2 R.
    specializes EQ1 Ï„1 Ï„2 R. destruct EQ1 as [L1 EQ1].
    specializes EQ2 Ï„2 Ï„2 (R_id'' Ï„2). destruct EQ2 as [L2 EQ2].
    exists (L1 âˆª L2 âˆª dom_rho Ï). intros Î± NIL__Î± RV.
    specializes EQ1 Î±. specializes EQ1. fsetdec. jauto.
      destruct EQ1 as [?TMTY [?TMTY [v1 [v2 [?OP [?OP VAL1]]]]]].
    specializes EQ2 Î±. specializes EQ2. fsetdec. splits; jauto. unfold R_id''. unfold Rel. crush.
      destruct EQ2 as [?TMTY [?TMTY [v2' [v3 [?OP [?OP VAL2]]]]]].
      forwards: t_cl_deterministic OP1 OP0. jauto. jauto. subst.
    splits. eassumption. applys_eq TMTY2. simpl+. reflexivity.
    exists v1 v3. splits. eassumption. eassumption. eapply IHn. simpl+. crush. eassumption. eassumption.
    destruct IN as [Ïˆ [Î³ IN]].
    exists (Ïˆ ::a Î± :: []) Î³. simp'. exists. splits. reflexivity. eassumption. fsetdec. simp'.
Qed.

Lemma EquivRel_trans : forall Ïˆ t1 t2 t3 Ïƒ,
    Ïˆ âŠ¢tâ‰ˆ t1 â‰ˆ t2 â–¸ Ïƒ
  -> Ïˆ âŠ¢tâ‰ˆ t2 â‰ˆ t3 â–¸ Ïƒ
  -> Ïˆ âŠ¢tâ‰ˆ t1 â‰ˆ t3 â–¸ Ïƒ.
Proof.
  introv EQ1 EQ2.
  destruct EQ1 as [TMTY1 [TMTY2 EQ1]]. destruct EQ2 as [_ [TMTY3 EQ2]]. splits. eassumption. eassumption. introv IN.
  (* rewrite <- (rho_trans_id Ï). rewrite <- (gamma_trans_id Î³). simpl+. *)
  specializes EQ1 Ï Î³. specializes EQ1. eassumption.
  specializes EQ2 (rho_id'' Ï) (gamma_id Î³). specializes EQ2. auto using logrel_e_id.
  destruct EQ1 as [CLTMTY1 [CLTMTY2 [v1 [v2 [OP1 [OP2 VAL1]]]]]].
  destruct EQ2 as [CLTMTY2' [CLTMTY3 [v2' [v3 [OP2' [OP3 VAL2]]]]]]. simpl+ in *.
  simpl+. splits. 1,2:simpl+; eassumption.
  exists v1 v3. splits. 1,2: eassumption.
  forwards: t_cl_deterministic OP2 OP2'. jauto. jauto. subst.
  eauto using logrel_val_trans.
Qed.

(*** Lemmas *)
Lemma SubSumpTm_rewrite_equiv : forall Ïƒ t__in' Ïˆ t__in t__out Ï„,
    SubSumpTm Ïˆ t__in Ïƒ t__out Ï„
  -> Ïˆ âŠ¢tâ‰ˆ t__in â‰ˆ t__in' â–¸ Ïƒ
  -> exists t__out',
      SubSumpTm Ïˆ t__in' Ïƒ t__out' Ï„
    /\ Ïˆ âŠ¢tâ‰ˆ t__out' â‰ˆ t__out â–¸ (S__T Ï„).
Proof.
  introv SS EQ. gen t__in'. induction SS; intros. exists. split. econstructor. eauto using EquivRel_symm.
  specializes IHSS. eapply CompatTApp. eassumption. eassumption.
  destruct IHSS as [t__out' [SS' EQ']].
  exists. split. econstructor. eassumption. eassumption. eassumption.
Qed.

Lemma Equivrel_Reduce_TLam : forall Ïˆ t Ï„ Ïƒ,
    Ïˆ âŠ¢t t__TApp (t__TLam t) Ï„ â–¸ Ïƒ
  -> Ïˆ âŠ¢tâ‰ˆ t__TApp (t__TLam t) Ï„ â‰ˆ open_Tm_wrt_T t Ï„ â–¸ Ïƒ.
Proof.
  introv TMTY1.
  assert (TMTY2: Ïˆ âŠ¢t open_Tm_wrt_T t0 Ï„ â–¸ Ïƒ).
  inverts TMTY1. inverts TMTY.
  forwards [Î± NIL__Î±]: atom_fresh (L âˆª E_skvars Ïˆ âˆª fv__Î±(t0) âˆª fv__Î±(Ïƒ0)). specializes TMTY0 Î±. specializes TMTY0. fsetdec.
  eapply (TmTy_subst_skvar_binding_E_head Ï„) in TMTY0. 2:eassumption. 2:fsetdec. applys_eq TMTY0.
  rewrite subst_skvar_Tm_open_Tm_wrt_T. 2:crush. simpl+. if_taut. subst_notin.
  rewrite subst_skvar_Sc_open_Sc_wrt_T. 2:crush. simpl+. if_taut. subst_notin.
  (**)
  intros. splits. 1,2:assumption. intros. splits. 1,2:eauto using TmTy_close1, TmTy_close2.
  (**)
  forwards [_ [_ FP]]: FundamentalProperty TMTY2. specializes FP H.
  destruct FP as [_ [_ [v1 [v2 [OP1 [OP2 VAL]]]]]].
  (**)
  exists v1 v2. splits. 2,3:assumption.
  econstructor. simpl+. econstructor. applys_eq OP1.
  rewrite Subx_app_open_Tm_wrt_T. 2:eauto.
  rewrite Sub_app_open_Tm_wrt_T. 2:eauto. reflexivity.
Qed.

Lemma subst_skvar_Sc_Sub_app_notin_or_eq : forall Î± Ï„1 Ï„2 Î¸1 Î¸2 (Ïƒ:Sc),
    {Ï„1 â‰” Î±}âŸ¦Î¸1 â–¹ ÏƒâŸ§ = {Ï„2 â‰” Î±}âŸ¦Î¸2 â–¹ ÏƒâŸ§
  -> Î± âˆ‰ dom_Sub Î¸1
  -> Î± âˆ‰ dom_Sub Î¸2
  -> Î± âˆ‰ fv__Î±(Ïƒ) \/ Ï„1 = Ï„2.
Proof.
  introv EQ NID1 NID2. induction Ïƒ. induction Ï„.
  all:simpl+ in EQ; inverts EQ.
  - left. simpl+. fsetdec.
  - destruct (Î±0 == Î±).
    + right. subst.
      rewrite Sub_app_T_notindom in H0. 2:simpl+; fsetdec.
      rewrite Sub_app_T_notindom in H0. 2:simpl+; fsetdec.
      simpl+ in H0. if_taut.
    + left. simpl+. fsetdec.
  - left. simpl+. fsetdec.
  - left. simpl+. fsetdec.
  - specializes IHÏ„1. simpl+. fequals. destruct IHÏ„1. 2:jauto.
    specializes IHÏ„2. simpl+. fequals. destruct IHÏ„2. 2:jauto.
    left. simpl+. fsetdec.
  - simpl+. crush.
Qed.

Lemma Sub_app_T_subst_skvar_T : forall Ï„ Î± (Î¸:Sub) (Ï„':T),
    Î± âˆ‰ skvars_codom_Sub Î¸ âˆª dom_Sub Î¸
  -> fv__Î±(Ï„) âˆ dom_Sub Î¸
  -> {Ï„ â‰” Î±}âŸ¦Î¸ â–¹ Ï„'âŸ§ = âŸ¦Î¸ â–¹ {Ï„ â‰” Î±} Ï„'âŸ§.
Proof.
  intros. forwards: Sub_app_Sc_subst_skvar_Sc Ï„ Î± Î¸ (S__T Ï„'). fsetdec. disj_union. assumption. simpl+. fsetdec.
  simpl+ in H1. crush.
Qed.

Axiom Sub_unique : Sub -> Prop.

Fact wf_Sub_cons : forall Î± Ï„ Ïˆ Î¸,
    Ïˆ âŠ¢Î¸ Î¸
  -> Ïˆ âŠ¢wfÏ„ Ï„
  -> Ïˆ âŠ¢Î¸ (Ï„, Î±) :: Î¸.
Proof. introv WFS WFT. norm. apply wf_Sub_app. split. unfolds. intros. simpl+ in H. T_facts.simpl_singleton. crush. crush. Qed.


Lemma SubSump_Sub : forall a Ïˆ Ï„1 Ï„2,
    SubSump Ïˆ (âˆ€ aâ¬ª S__T Ï„1) Ï„2
  -> FrA a (E_A_skvars Ïˆ)
  -> exists Î¸,
      Sub_to_A Î¸ = a
    /\ Ïˆ âŠ¢Î¸ Î¸
    /\ âŸ¦Î¸ â–¹ Ï„1âŸ§ = Ï„2.
Proof.
  intro a. ind_a a; simpl+; introv SS FR; inverts SS.
  - exists ([]:Sub). crush.
  - inverts FR. inverts H.  simpl+ in H0.
    rewrite <- subst_skvar_Sc_spec in SS0.
    rewrite subst_skvar_Sc_close_Sc_wrt_A in SS0. 2:eauto. 2:eauto.
    2:rewrite WfT_sk; try eassumption; symmetry; disj_sub.
    specializes IHa SS0. destruct IHa as [Î¸ [SWF [EQ1 EQ2]]]. split. eassumption. disj_sub.
    subst. exists ((Ï„0, Î±) :: Î¸). simpl+. splits.
    + crush.
    + auto using wf_Sub_cons.
    + dist. apply Sub_app_T_subst_skvar_T.
      * apply notin_a_notin_varl in H3. rewrite varl_Sub_to_A_dom in H3.
        rewrite wf_Sub_codom. 2:eassumption. apply notin_union_iff.
        in_disj. fsetdec.
      * rewrite varl_Sub_to_A_dom in H0. rewrite WfT_sk. 2:eassumption. symmetry. disj_sub.
Qed.

Lemma Sub_to_A_codom : forall Î¸1 Î¸2,
    Sub_to_A Î¸1 = Sub_to_A Î¸2
  -> dom_Sub Î¸1 = dom_Sub Î¸2.
Proof.
  (* intros. do 2 rewrite <- varl_Sub_to_A_dom. rewrite H. *)
  (** why do we have to induct, I cannot rewrite with the equality?? *)
  intro Î¸1. ind_Sub Î¸1; intros; destruct Î¸2; simpl+ in H; inverts H. crush. simpl+. erewrite IHÎ¸1. 2:eassumption. crush.
Qed.

(*** Actual prop *)
Lemma SubSump'_SubSumpTm' : forall Ïˆ Ïƒ1 Ïƒ2,
    SubSump' Ïˆ Ïƒ1 Ïƒ2
  -> forall t1, exists t2, SubSumpTm' Ïˆ t1 Ïƒ1 t2 Ïƒ2.
Proof.
  introv SS. induction SS. induction SS.
  all:intro t1.
  - exists. crush.
  - specializes IHSS (t__TApp t1 Ï„1). destruct IHSS as [t2 SST]. inverts SST.
    eauto.
  - forwards [Î± NIL__Î±]: atom_fresh (L âˆª E_skvars Ïˆ âˆª fv__Î±(t1) âˆª fv__Î±(Ïƒ1) âˆª fv__Î±(Ïƒ2)).
    specializes H Î±. specializes H. fsetdec.
    destruct H as [t2 SST]. exists. applys SST'__R {{Î±}}. intros Î² NIL__Î².
    eapply (SubSumpTm'_rename_skvar Î± Î²) in SST. applys_eq SST; symmetry.
    + simpl+. fequals. apply rename_skvar_E_notin. fsetdec.
    + clear - NIL__Î±. subst_notin.
    + clear - NIL__Î±. subst_notin.
    + rewrite subst_skvar_Tm_spec. reflexivity.
    + rewrite subst_skvar_Sc_open_Sc_wrt_T. 2:crush. simpl+. if_taut. fequals.
      clear - NIL__Î±. subst_notin.
Qed.

Ltac checked_admit := admit.
Lemma SubSumpTm'_Forall_A_equiv_Lambda_A : forall a2 a1 Ïˆ t1 Ï„ Î¸,
    SubSump' Ïˆ (âˆ€ a1â¬ª (S__T Ï„)) (âˆ€ a2â¬ª âŸ¦Î¸ â–¹ (S__T Ï„)âŸ§)
  -> Sub_to_A Î¸ = a1
  -> Ïˆ âŠ¢t (Î› (Sub_to_A Î¸)â¬ª t1) â–¸ (âˆ€ (Sub_to_A Î¸)â¬ª (S__T Ï„))
  -> a1 ### E_A_skvars Ïˆ
  -> Ïˆ âŠ¢Î¸ Î¸
  -> dom_Sub Î¸ âˆ skvars_codom_Sub Î¸
  -> fv__Î±(Ï„) âŠ† dom_Sub Î¸
  -> varl a2 âˆ dom_Sub Î¸
  -> exists t2,
      SubSumpTm' Ïˆ (Î› (Sub_to_A Î¸)â¬ª t1) (âˆ€ (Sub_to_A Î¸)â¬ª (S__T Ï„)) t2 (âˆ€ a2â¬ª âŸ¦Î¸ â–¹ (S__T Ï„)âŸ§)
    /\ Ïˆ âŠ¢tâ‰ˆ Î› a2â¬ª âŸ¦Î¸ â–¹ t1âŸ§ â‰ˆ t2 â–¸ (âˆ€ a2â¬ª âŸ¦Î¸ â–¹ (S__T Ï„)âŸ§).
Proof.
  intro a2. ind_a a2.
  introv SS EQ__Î¸. inverts SS. simpl+.
  gen Î¸ Ï„ t1. ind_a a1; introv EQ__Î¸ SS TMTY FR WFS DISJ__dom SUB__Ï„ DISJ__a2; destruct Î¸ as [|[Ï„__Î² Î²] Î¸]; simpl+ in EQ__Î¸; inverts EQ__Î¸.
  - simpl+ in *. exists. eauto using FundamentalProperty.
  - admit.
  - introv SS EQ__Î¸ TMTY FR WFS DISJ__Î¸ SUB__Ï„ DISJ__a2. inverts SS.
    forwards [Î² NIL__Î²]: atom_fresh L.
    specializes SS0 Î². specializes SS0. fsetdec. rewrite <- subst_skvar_Sc_spec in SS0.
    rewrite subst_skvar_Sc_close_Sc_wrt_A in SS0. 2:crush. 2,3:checked_admit.
    simpl+ in SS0. rewrite rename_skvar_Sub_Sub_app_T' in SS0. 2,3:checked_admit.
    (**)
    forwards [t2 [SST EQUIV]]: IHa2 (Î› Sub_to_A Î¸ â¬ª t1) SS0.
      admit.
      admit.
      admit.
      admit.
      admit.
      admit.
      admit.
    (**)
    exists. splits.
    + simpl+. applys SST'__R L. intros Î²' NIL__Î²'. admit.
    + admit.
Abort.




  (* - introv SS TMTY__in DISJ FRA. inverts SS. rename t0 into t. *)
  (*   simpl+. applys CompatTLam (L âˆª {{Î±}}). *)
  (*   intros Î² NIL__Î². *)
  (*   rewrite <- subst_skvar_Sc_spec in *. *)
  (*   rewrite <- subst_skvar_Tm_spec in *. *)
  (*   rewrite subst_skvar_Tm_close_Tm_wrt_A. 2,3,4:admit. *)
  (*   rewrite rename_skvar_Sub_Sub_app_Tm'. 2:admit. 2:admit. *)
  (*   (**) *)
  (*   rewrite subst_skvar_Sc_close_Sc_wrt_A. 2,3,4:admit. *)
  (*   simpl+. *)
  (*   rewrite rename_skvar_Sub_Sub_app_T'. 2:admit. 2:admit. *)
  (*   (**) *)
  (*   eapply IHa2. *)
  (*   + specializes SS0 Î². specializes SS0. fsetdec. *)
  (*     applys_eq SS0. *)
  (*     * fequals. apply rename_skvar_Sub_Sub_to_A_notin. admit. *)
  (*     * fequals. apply rename_skvar_Sub_Sub_to_A_notin. admit. *)
  (*     * rewrite <- subst_skvar_Sc_spec. rewrite subst_skvar_Sc_close_Sc_wrt_A. 2,3,4:admit. *)
  (*       simpl+. rewrite rename_skvar_Sub_Sub_app_T'. 2:admit. 2:admit. reflexivity. *)
  (*   + admit. *)
  (*   + admit. *)
  (*   + admit. *)


  (* - assert (Sub_to_A Î¸ = Sub_to_A Î¸). reflexivity. specializes IHa1 H. clear H. *)
  (*   inverts SS. rename SS0 into SS. rewrite <- subst_skvar_Sc_spec in SS. simpl+ in DISJ__dom. *)
  (*   (** Freshness and stuff *) *)
  (*   assert (NIL__Î±: Î± âˆ‰ dom_Sub Î¸ âˆª skvars_codom_Sub Î¸ âˆª E_A_skvars Ïˆ âˆª varl (Sub_to_A Î¸)). *)
  (*   { inverts FR. rename H into ND. rename H0 into DISJ. simpl+ in DISJ. *)
  (*     assert (Î± âˆ‰ dom_Sub Î¸). *)
  (*       inverts ND. apply notin_a_notin_varl in H1. rewrite varl_Sub_to_A_dom in H1. fsetdec. *)
  (*     assert (Î± âˆ‰ skvars_codom_Sub Î¸). clear - DISJ__dom. *)
  (*       applys in_disj1 {{Î±}}. eapply atoms_facts.disjoint_Subset. eassumption. fsetdec. fsetdec. fsetdec. *)
  (*     assert (Î± âˆ‰ E_A_skvars Ïˆ). in_disj. *)
  (*     (* assert (Î± âˆ‰ fv__Î±(Ï„)). rewrite WfT_sk. admit. admit. *) *)
  (*     rewrite varl_Sub_to_A_dom. fsetdec. *)
  (*   } *)
  (*   assert (WFT__Î²: Ïˆ âŠ¢wfÏ„ Ï„__Î²). eapply WFS. simpl+. fsetdec. *)
  (*   assert (DISJ: E_A_skvars Ïˆ âˆª fv__Î±(Ï„1) âˆª fv__Î±(Ï„__Î²) âˆ dom_Sub Î¸). *)
  (*   { inverts FR. rename H into ND. rename H0 into DISJ. simpl+ in DISJ. symmetry. *)
  (*     rewrite WfT_sk. 2:eassumption. rewrite WfT_sk. 2:eassumption. clear - DISJ. disj_sub. } *)
  (*   (** Commutativity *) *)
  (*   assert (COMM0: âˆ€ Sub_to_A Î¸ â¬ª S__T ({Ï„1 â‰” Î±}Ï„) = {Ï„1 â‰” Î±}(âˆ€ Sub_to_A Î¸ â¬ª S__T Ï„)). *)
  (*     rewrite subst_skvar_Sc_close_Sc_wrt_A. reflexivity. eauto. fsetdec. *)
  (*     rewrite varl_Sub_to_A_dom. clear - DISJ; disj_sub. *)
  (*   assert (EQ__Ï„: Î± âˆ‰ fv__Î±(Ï„) \/ Ï„1 = Ï„__Î²). *)
  (*   { forwards [Î¸' [EQ1 [WF__Î¸' EQ2]]]: SubSump_Sub. rewrite COMM0. eassumption. eauto. *)
  (*     forwards DOM: Sub_to_A_codom EQ1. *)
  (*     forwards: subst_skvar_Sc_Sub_app_notin_or_eq Î¸' Î¸ (S__T Ï„). 4:applys_eq H. *)
  (*     - simpl+. fequals. applys_eq EQ2. rewrite subst_skvar_T_Sub_app_T. reflexivity. rewrite DOM. *)
  (*       rewrite wf_Sub_codom. 2:eassumption. fsetdec. rewrites WfT_sk. 2:eassumption. *)
  (*       rewrite DOM. clear - DISJ; disj_sub. *)
  (*     - rewrite DOM. fsetdec. *)
  (*     - fsetdec. *)
  (*   } *)
  (*   assert (COMM1: âˆ€ Sub_to_A Î¸ â¬ª S__T ({Ï„__Î² â‰” Î±}Ï„) = {Ï„1 â‰” Î±}(âˆ€ Sub_to_A Î¸ â¬ª S__T Ï„)). *)
  (*     rewrite subst_skvar_Sc_close_Sc_wrt_A. 2:eauto. 2:fsetdec. 2:clear - DISJ; disj_sub. *)
  (*     destruct EQ__Ï„. *)
  (*     subst_notin'. 2:fsetdec. subst_notin'. simpl+. fsetdec. *)
  (*     subst. reflexivity. *)
  (*   assert (COMM2: âˆ€ Sub_to_A Î¸ â¬ª S__T ({Ï„__Î² â‰” Î±}Ï„) = {Ï„__Î² â‰” Î±}(âˆ€ Sub_to_A Î¸ â¬ª S__T Ï„)). *)
  (*     rewrite subst_skvar_Sc_close_Sc_wrt_A. 2:eauto. 2:fsetdec. 2:clear - DISJ; disj_sub. reflexivity. *)
  (*   assert (COMM3: âŸ¦Î¸ â–¹ {Ï„__Î² â‰” Î±}Ï„âŸ§ = âŸ¦(Ï„__Î², Î±) :: Î¸ â–¹ Ï„âŸ§). *)
  (*     dist. rewrite subst_skvar_T_Sub_app_T. reflexivity. fsetdec. clear - DISJ; disj_sub. *)
  (*   assert (COMM4: âŸ¦Î¸ â–¹ {Ï„__Î² â‰” Î±}t1âŸ§ = âŸ¦(Ï„__Î², Î±) :: Î¸ â–¹ t1âŸ§). *)
  (*     dist. rewrite subst_skvar_Tm_Sub_app_Tm. reflexivity. fsetdec. clear - DISJ; disj_sub. *)
  (*   assert (COMM5: (Î› Sub_to_A Î¸ â¬ª {Ï„__Î² â‰” Î±}t1) = {Ï„__Î² â‰” Î±}(Î› Sub_to_A Î¸ â¬ª t1)). *)
  (*     rewrite subst_skvar_Tm_close_Tm_wrt_A. 2:eauto. 2:fsetdec. 2:clear - DISJ; disj_sub. *)
  (*     reflexivity. *)
  (*   (*actual proof*) *)
  (*   assert (TMTY__IH: Ïˆ âŠ¢t Î› Sub_to_A Î¸ â¬ª {Ï„__Î² â‰” Î±}t1 â–¸ (âˆ€ Sub_to_A Î¸ â¬ª S__T ({Ï„__Î² â‰” Î±}Ï„))). *)
  (*     simpl+ in TMTY. rewrite COMM5. rewrite COMM2. eapply TmTy_TLam_subst. eassumption. auto. *)
  (*   assert (TMTY__rewr: Ïˆ âŠ¢t t__TApp (t__TLam (close_Tm_wrt_T Î± (Î› Sub_to_A Î¸ â¬ª t1))) Ï„__Î² â–¸ (âˆ€ Sub_to_A Î¸ â¬ª S__T ({Ï„__Î² â‰” Î±}Ï„))). *)
  (*     simpl+ in TMTY. rewrite COMM2. rewrite subst_skvar_Sc_spec. econstructor. eassumption. eassumption. *)
  (*   specializes IHa1 ({Ï„__Î² â‰” Î±}Ï„) ({Ï„__Î² â‰” Î±}t1). applys_eq SS. assumption. assumption. *)
  (*   destruct IHa1 as [t2 [SS__IH EQUIV]]. assumption. eauto. eauto. clear - DISJ__dom. disj_sub. inverts SS__IH. rename SS0 into SS__IH. *)
  (*   forwards [t2' [SS__IH' EQUIV']]: SubSumpTm_rewrite_equiv (t__TApp (t__TLam (close_Tm_wrt_T Î± (Î› Sub_to_A Î¸ â¬ª t1))) Ï„__Î²) SS__IH. *)
  (*     eapply EquivRel_symm. applys_eq Equivrel_Reduce_TLam. *)
  (*     rewrite <- subst_skvar_Tm_spec. assumption. assumption. *)
  (*   exists. splits. simpl+. *)
  (*     econstructor. econstructor. apply WFT__Î². applys_eq SS__IH'. *)
  (*     rewrite <- subst_skvar_Sc_spec. crush. crush. *)
  (*     eapply EquivRel_trans. applys_eq EQUIV. clear - COMM3. crush. crush. *)
  (*     eapply EquivRel_symm. applys_eq EQUIV'. clear - COMM3. crush. *)


Abort.

Lemma SubSumpTm'_Forall_A_equiv_Lambda_A : forall a2 Ïˆ t Ï„ t' Î¸,
      SubSumpTm' Ïˆ (Î› (Sub_to_A Î¸)â¬ª t) (âˆ€ (Sub_to_A Î¸)â¬ª (S__T Ï„)) t' (âˆ€ a2â¬ª âŸ¦Î¸ â–¹ (S__T Ï„)âŸ§)
    -> Ïˆ âŠ¢t (Î› (Sub_to_A Î¸)â¬ª t) â–¸ (âˆ€ (Sub_to_A Î¸)â¬ª (S__T Ï„))
    -> dom_Sub Î¸ âˆ varl a2
    -> (Sub_to_A Î¸) ### E_skvars Ïˆ
    -> Ïˆ âŠ¢tâ‰ˆ Î› a2â¬ª âŸ¦Î¸ â–¹ tâŸ§ â‰ˆ t' â–¸ (âˆ€ a2â¬ª âŸ¦Î¸ â–¹ (S__T Ï„)âŸ§).
Proof.
  intro a2. ind_a a2.
  introv SS TMTY__in DISJ FRA. inverts SS. clear DISJ. simpl+.
  gen Ïˆ t0 Ï„ t'. ind_Sub Î¸; intros; inverts SS0.
  - simpl+. apply FundamentalProperty. assumption.
  - simpl+ in SS. simpl+ in FRA.
    apply FrA_cons in FRA. destruct FRA as [FRA NIL__Î±']. rewrite varl_Sub_to_A_dom in NIL__Î±'.
    assert (NIL__Î±: Î± âˆ‰ E_skvars Ïˆ âˆª dom_Sub Î¸ âˆª varl (Sub_to_A Î¸)).
      rewrite varl_Sub_to_A_dom. fsetdec.
      clear NIL__Î±'.
    assert (fv__Î±(t0) âŠ† dom_Sub Î¸). admit.
    rewrite <- subst_skvar_Sc_spec in SS.
    assert (H__IN:  Î± âˆ‰ fv__Î±(Ï„0) \/ Ï„1 = Ï„). admit.
    (* { forwards [Î¸' [EQ SS']]: SubSumpTm_Sub_Ï„. applys_eq SS. admit. *)
    (*   rewrite <- subst_skvar_Sc_spec. rewrite subst_skvar_Sc_close_Sc_wrt_A. 2:eauto. 2:fsetdec. 2:admit. reflexivity. *)
    (*   rewrite <- subst_skvar_T_Sub_app_T in SS'. 2,3:admit. *)
    (*   forwards: subst_skvar_Sc_Sub_app_notin_or_eq Ï„1 Ï„ (S__T Ï„0). simpl+. fequals. apply SS'. *)
    (*   admit. admit. eassumption. *)
    (* } *)
    destruct H__IN as [NIT|EQ].
    + simpl+.
      specializes IHÎ¸ Ïˆ ({Ï„1 â‰” Î±}t0) ({Ï„1 â‰” Î±}Ï„0). specializes IHÎ¸. admit.
      forwards [t'' [SS' EQ]]: SubSumpTm_rewrite_equiv ({Ï„1 â‰” Î±}(Î› Sub_to_A Î¸ â¬ª t0)) SS.
        applys_eq Equivrel_Reduce_TLam.
        rewrite <- subst_skvar_Tm_spec. reflexivity.
        simpl+ in TMTY__in. rewrite subst_skvar_Sc_spec. econstructor. eassumption. eassumption.
        applys_eq SS'.
        rewrite subst_skvar_Tm_close_Tm_wrt_A. 2:eauto. 2,3:admit. reflexivity.
        rewrite subst_skvar_Sc_close_Sc_wrt_A. 2:eauto. 2,3:admit. reflexivity.
        admit. admit.
      applys_eq IHÎ¸. admit. admit.
    + subst.
      assert (DISJ: fv__Î±(Ï„) âˆ varl (Sub_to_A Î¸)).
        inverts FRA. rewrite WfT_sk. 2:eassumption. symmetry. disj_sub.
      forwards [t'' [SS' EQ]]: SubSumpTm_rewrite_equiv ({Ï„ â‰” Î±}(Î› Sub_to_A Î¸ â¬ª t0)) SS.
        applys_eq Equivrel_Reduce_TLam.
        rewrite <- subst_skvar_Tm_spec. reflexivity.
        simpl+ in TMTY__in. rewrite subst_skvar_Sc_spec. econstructor. eassumption. eassumption.
      specializes IHÎ¸ Ïˆ ({Ï„ â‰” Î±}t0) ({Ï„ â‰” Î±}Ï„0). specializes IHÎ¸.
        dist in TMTY__in. applys_eq TmTy_TLam_subst. 3:eassumption.
        rewrite subst_skvar_Tm_close_Tm_wrt_A; eauto.
        rewrite subst_skvar_Sc_close_Sc_wrt_A; eauto.
        assumption.
        applys_eq SS'.
        rewrite subst_skvar_Tm_close_Tm_wrt_A. 2:eauto. 2,3:admit. reflexivity.
        rewrite subst_skvar_Sc_close_Sc_wrt_A. 2:eauto. 2,3:admit. reflexivity.
        dist. rewrite subst_skvar_T_Sub_app_T. 2,3:admit. crush.
      eapply EquivRel_trans. applys_eq IHÎ¸. 3:applys_eq EQ.
        fequals. dist. rewrite subst_skvar_T_Sub_app_T. 2,3:admit. crush.
        dist. rewrite subst_skvar_Tm_Sub_app_Tm. 2,3:admit. crush.
  - introv SS TMTY__in DISJ FRA. inverts SS. rename t0 into t.
    simpl+. applys CompatTLam (L âˆª {{Î±}}).
    intros Î² NIL__Î².
    rewrite <- subst_skvar_Sc_spec in *.
    rewrite <- subst_skvar_Tm_spec in *.
    rewrite subst_skvar_Tm_close_Tm_wrt_A. 2,3,4:admit.
    rewrite rename_skvar_Sub_Sub_app_Tm'. 2:admit. 2:admit.
    (**)
    rewrite subst_skvar_Sc_close_Sc_wrt_A. 2,3,4:admit.
    simpl+.
    rewrite rename_skvar_Sub_Sub_app_T'. 2:admit. 2:admit.
    (**)
    eapply IHa2.
    + specializes SS0 Î². specializes SS0. fsetdec.
      applys_eq SS0.
      * fequals. apply rename_skvar_Sub_Sub_to_A_notin. admit.
      * fequals. apply rename_skvar_Sub_Sub_to_A_notin. admit.
      * rewrite <- subst_skvar_Sc_spec. rewrite subst_skvar_Sc_close_Sc_wrt_A. 2,3,4:admit.
        simpl+. rewrite rename_skvar_Sub_Sub_app_T'. 2:admit. 2:admit. reflexivity.
    + admit.
    + admit.
    + admit.
Abort.


Lemma SubSumpTm_whatever : forall Ïˆ t Ïƒ t' Ï„',
    SubSumpTm Ïˆ t Ïƒ t' Ï„'
  -> Ïˆ âŠ¢t t â–¸ Ïƒ
  -> Ïˆ âŠ¢t t' â–¸ (S__T Ï„').
Proof.
  introv SST TMTY. induction SST. assumption.
  applys_eq IHSST. econstructor. eassumption. eassumption.
Qed.

Check fold_right.
Check fold_right (fun (Ï„:T) (t:Tm) => t__TApp t Ï„).

Definition apply_t_list : Tm -> list T -> Tm := fold_right (fun (Ï„:T) (t:Tm) => t__TApp t Ï„).

Lemma apply_t_list_app : forall t Ï„s1 Ï„s2,
    apply_t_list t (Ï„s1 ++ Ï„s2) = apply_t_list (apply_t_list t Ï„s2) Ï„s1.
Proof. induction Ï„s1; crush. Qed.
#[local] Hint Rewrite apply_t_list_app : core.

Lemma SubSumpTm_app_t_list : forall Ïˆ t Ïƒ t' Ï„',
    SubSumpTm Ïˆ t Ïƒ t' Ï„'
  -> exists (Ï„s : list T),
      t' = apply_t_list t Ï„s.
Proof.
  introv SST. induction SST. exists ([]:list T). crush.
  destruct IHSST as [Ï„s EQ]. subst. exists (Ï„s ++ [Ï„1]). simpl+. crush.
Qed.


Lemma SubSumpTm'_Forall_A_equiv_Lambda_A : forall a2 Ïˆ t Ï„ t' Î¸,
      SubSumpTm' Ïˆ (Î› (Sub_to_A Î¸)â¬ª t) (âˆ€ (Sub_to_A Î¸)â¬ª (S__T Ï„)) t' (âˆ€ a2â¬ª âŸ¦Î¸ â–¹ (S__T Ï„)âŸ§)
    -> Ïˆ âŠ¢t (Î› (Sub_to_A Î¸)â¬ª t) â–¸ (âˆ€ (Sub_to_A Î¸)â¬ª (S__T Ï„))
    -> dom_Sub Î¸ âˆ varl a2
    -> (Sub_to_A Î¸) ### E_skvars Ïˆ
    -> Ïˆ âŠ¢tâ‰ˆ Î› a2â¬ª âŸ¦Î¸ â–¹ tâŸ§ â‰ˆ t' â–¸ (âˆ€ a2â¬ª âŸ¦Î¸ â–¹ (S__T Ï„)âŸ§).
Proof.
  intro a2. ind_a a2. 2:admit.
  introv SS TMTY__in DISJ FRA. inverts SS. clear DISJ FRA TMTY__in. simpl+.
  remember (Sub_to_A Î¸) as a1. rename t0 into t1. rename t' into t2.
  gen Î¸ Ï„ t1. induction a1; intros. admit. destruct Î¸ as [|[Ï„__Î² Î²] Î¸]; simpl+ in Heqa1; inverts Heqa1.
  specializes IHa1 Î¸. assert (Sub_to_A Î¸ = Sub_to_A Î¸). reflexivity. specializes IHa1 H. clear H. remember (Sub_to_A Î¸) as a1.
  (* forwards [Ï„s EQ]: SubSumpTm_app_t_list. apply SS0. *)

  inverts SS0. rewrite <- subst_skvar_Sc_spec in SS.

  assert (Î² âˆ‰ fv__Î±(Ï„)). admit.

  (** OK hier is het probleem. Als Î² niet in Ï„ voorkomt, dan is de keuze voor Ï„__Î² dus arbitrair. Maar, omdat Î¸ in de conclusie voorkomt, en voor termen niet arbitrair is, hebben we een probleem. *)
Abort.






Lemma SubSump'_SubSumpTm' : forall Ïˆ Ïƒ1 Ïƒ2,
    SubSump' Ïˆ Ïƒ1 Ïƒ2
  -> forall t1, exists t2, SubSumpTm' Ïˆ t1 Ïƒ1 t2 Ïƒ2.

Lemma SubSump'_SubSumpTm' : forall Ïˆ Ïƒ1 Ïƒ2,
    SubSump' Ïˆ Ïƒ1 Ïƒ2
  -> forall t1, exists t2, SubSumpTm' Ïˆ t1 Ïƒ1 t2 Ïƒ2.
Proof.
  introv SS. induction SS. induction SS.
  all:intro t1.
  - exists. crush.
  - specializes IHSS (t__TApp t1 Ï„1). destruct IHSS as [t2 SST]. inverts SST.
    eauto.
  - forwards [Î± NIL__Î±]: atom_fresh (L âˆª E_skvars Ïˆ âˆª fv__Î±(t1) âˆª fv__Î±(Ïƒ1) âˆª fv__Î±(Ïƒ2)).
    specializes H Î±. specializes H. fsetdec.
    destruct H as [t2 SST]. exists. applys SST'__R {{Î±}}. intros Î² NIL__Î².
    eapply (SubSumpTm'_rename_skvar Î± Î²) in SST. applys_eq SST; symmetry.
    + simpl+. fequals. apply rename_skvar_E_notin. fsetdec.
    + clear - NIL__Î±. subst_notin.
    + clear - NIL__Î±. subst_notin.
    + rewrite subst_skvar_Tm_spec. reflexivity.
    + rewrite subst_skvar_Sc_open_Sc_wrt_T. 2:crush. simpl+. if_taut. fequals.
      clear - NIL__Î±. subst_notin.
Qed.

Lemma SubSump'_Forall_A_equiv_Lambda_A : forall a2 Ïˆ t Ï„ Î¸,
      SubSump' Ïˆ (âˆ€ (Sub_to_A Î¸)â¬ª (S__T Ï„)) (âˆ€ a2â¬ª âŸ¦Î¸ â–¹ (S__T Ï„)âŸ§)
    -> Ïˆ âŠ¢t (Î› (Sub_to_A Î¸)â¬ª t) â–¸ (âˆ€ (Sub_to_A Î¸)â¬ª (S__T Ï„))
    -> dom_Sub Î¸ âˆ varl a2
    -> (Sub_to_A Î¸) ### E_skvars Ïˆ
    -> exists t', SubSumpTm' Ïˆ (Î› (Sub_to_A Î¸)â¬ª t) (âˆ€ (Sub_to_A Î¸)â¬ª (S__T Ï„)) t' (âˆ€ a2â¬ª âŸ¦Î¸ â–¹ (S__T Ï„)âŸ§)
          /\ Ïˆ âŠ¢tâ‰ˆ Î› a2â¬ª âŸ¦Î¸ â–¹ tâŸ§ â‰ˆ t' â–¸ (âˆ€ a2â¬ª âŸ¦Î¸ â–¹ (S__T Ï„)âŸ§).
Proof.
  introv SS TMTY DISJ FRA.
  forwards [t' SST]: SubSump'_SubSumpTm' (Î› Sub_to_A Î¸ â¬ª t0). eassumption.
  exists t'. split. assumption. eauto using SubSumpTm'_Forall_A_equiv_Lambda_A.
Qed.

Set Warnings "-notation-overridden,-intuition-auto-with-star".

Require Import Preamble.
Require Import Defs.HdmLems.

Require Import Defs.Lc.
Require Import Defs.Sub.
Require Import Defs.Subx.
Require Import Defs.TmTy.

Require Import Semantics.ClosedVals.
Require Import Semantics.gammaDef.
Require Import Semantics.EquivRel.
Require Import Semantics.LogRel.
Require Import Semantics.LogRelEProps.
Require Import Semantics.logrel_val_props.
Require Import Semantics.Opsem.
Require Import Semantics.rhoDef.

Lemma CompatLam__commhelper : forall Œ∏ Œ∏__x t1 t2 x,
    lc(t2)
  -> x ‚àâ (fv__x(‚ü¶Œ∏__x ‚ñπ__x t1‚üß) ‚à™ dom_Subx Œ∏__x)
  -> fv__Œ±(t2) ‚àê dom_Sub Œ∏
  -> lc__x(Œ∏__x)
  -> open_Tm_wrt_Tm ‚ü¶Œ∏ ‚ñπ ‚ü¶Œ∏__x ‚ñπ__x t1‚üß‚üß t2 = ‚ü¶Œ∏ ‚ñπ {t2 ‚âî__x x}‚ü¶Œ∏__x ‚ñπ__x open_Tm_wrt_Tm t1 (t__Var_f x)‚üß‚üß.
Proof.
  introv LC NIS LCX DISJ.
  rewrite Subx_app_open_Tm_wrt_Tm. 2:assumption. 2:symmetry; simpl+; fsetdec.
  rewrite subst_tvar_Tm_open_Tm_wrt_Tm. 2:assumption.
  rewrite subst_tvar_Tm_notin. 2:fsetdec. simpl+. if_taut.
  setoid_rewrite Sub_app_Tm_notindom at 3. reflexivity. assumption.
Qed.

(* Module tvars_codom_Subx_alg <: List_to_Set_alg Atom AtomSetImpl. *)
(*   Definition elt := (Tm * atom)%type. *)
(*   Definition f : elt -> atoms := (ftv_Tm ‚àò fst). *)
(* End tvars_codom_Subx_alg. *)
(* #[export] Hint Unfold tvars_codom_Subx_alg.elt tvars_codom_Subx_alg.f : algs. *)

(* Module Export Tvars_codom_Subx := List_to_Set Atom AtomSetImpl tvars_codom_Subx_alg. *)
(* Notation tvars_codom_Subx := Tvars_codom_Subx.List_to_Set. *)

(* Lemma Subx_app_t_subst_tvar_t : forall (Œ∏:Subx) t__in x t, *)
(*     x ‚àâ tvars_codom_Subx Œ∏ *)
(*   -> fv__x(t__in) ‚à™ {{x}} ‚àê dom_Subx Œ∏ *)
(*   -> {t__in ‚âî__x x}‚ü¶Œ∏ ‚ñπ__x t‚üß = ‚ü¶Œ∏ ‚ñπ__x {t__in ‚âî__x x} t‚üß. *)
(* Proof. *)
(*   introv NICD DISJ. ind_Subx Œ∏. crush. dist. rewrite <- IHŒ∏. *)
(*   - rewrite subst_tvar_Tm_subst_tvar_Tm. *)
(*     + fequals. apply subst_tvar_Tm_notin. simpl+ in NICD. fsetdec. *)
(*     + simpl+ in DISJ. clear - DISJ. fsetdec+. *)
(*     + simpl+ in DISJ. intro. subst. eapply (in_disj x). eassumption. all:clfsetdec. *)
(*   - simpl+ in NICD. fsetdec. *)
(*   - simpl+ in DISJ. disj_sub. *)
(* Qed. *)

(* Lemma CompatLam__commhelper' : forall Œ∏ Œ∏__x t1 t2 x, *)
(*   (*   lc(t2) *) *)
(*   (* -> x ‚àâ (fv__x(‚ü¶Œ∏__x ‚ñπ__x t1‚üß) ‚à™ dom_Subx Œ∏__x) *) *)
(*   (* -> fv__Œ±(t2) ‚àê dom_Sub Œ∏ *) *)
(*   (* -> lc__x(Œ∏__x) *) *)
(*   (* -> *) *)
(*     open_Tm_wrt_Tm ‚ü¶Œ∏ ‚ñπ ‚ü¶Œ∏__x ‚ñπ__x t1‚üß‚üß t2 = ‚ü¶Œ∏ ‚ñπ {t2 ‚âî__x x}‚ü¶Œ∏__x ‚ñπ__x open_Tm_wrt_Tm t1 (t__Var_f x)‚üß‚üß. *)
(* Proof. *)
(*   introv. *)
(*   rewrite Subx_app_t_subst_tvar_t. 2,3:admit. *)
(*   rewrite subst_tvar_Tm_open_Tm_wrt_Tm. 2:admit. simpl+. if_taut. *)
(* Abort. *)

Lemma CompatLam : forall L œà t œÑ t' œÑ',
    (forall x, x ‚àâ L -> œà ::x x :- S__T œÑ  ‚ä¢t‚âà (open_Tm_wrt_Tm t (t__Var_f x)) ‚âà (open_Tm_wrt_Tm t' (t__Var_f x)) ‚ñ∏ S__T œÑ')
  -> œà ‚ä¢wfœÑ œÑ
  -> œà ‚ä¢t‚âà t__Lam œÑ t ‚âà t__Lam œÑ t' ‚ñ∏ S__T (T__Fun œÑ œÑ').
Proof.
  introv IH WFT.
  forwards TmTy1: TmTy__Abs L. eassumption. intros. forwards [TmTy [_ _]]: IH H. eassumption.
  forwards TmTy2: TmTy__Abs L. eassumption. intros. forwards [_ [TmTy _]]: IH H. eassumption.
  splits. 1,2:eassumption. introv IN.
  eapply TmTy_close1 in TmTy1. 2:eassumption.
  eapply TmTy_close2 in TmTy2. 2:eassumption.
  simpl+ in TmTy1. simpl+ in TmTy2.
  apply logrel_val_exp. simp'. splits. splits; simpl+; eauto.
  do 2 eexists. splits. 1,2:simpl+; reflexivity. intros v1 v2 VAL.
  forwards [x NIL__x]: atom_fresh (L ‚à™ fv__x(‚ü¶œÄ1 Œ≥ ‚ñπ__x t0‚üß) ‚à™ fv__x(‚ü¶œÄ2 Œ≥ ‚ñπ__x t'‚üß) ‚à™ dom_Subx (œÄ1 Œ≥) ‚à™ dom_Subx (œÄ2 Œ≥)).
  specializes IH x. specializes IH. fsetdec. destruct IH as [_ [_ IH]].
  specializes IH œÅ ((v1, v2, x) :: Œ≥). specializes IH. simp'. do 3 eexists. splits.
  reflexivity. assumption. rewrite <- proj1_dom_gamma_Sub. simpl+. fsetdec. assumption.
  destruct IH as [TmTy1' [TmTy2' [v3 [v4 [OP1 [OP2 VAL']]]]]]. splits.
  (* - applys_eq TmTy1'. simpl+. eapply CompatLam__commhelper. eauto. fsetdec. fv_empty. eauto. *)
  - applys_eq TmTy1'. simpl+. eapply CompatLam__commhelper; eauto with slow.
  - applys_eq TmTy2'. simpl+. eapply CompatLam__commhelper; eauto with slow.
  - exists v3 v4. splits.
    + applys_eq OP1. simpl+. eapply CompatLam__commhelper; eauto with slow.
    + applys_eq OP2. simpl+. eapply CompatLam__commhelper; eauto with slow.
    + simpl+ in VAL'. jauto.
Qed.

(* Lemma CompatLam__commhelper_helper : forall Œ∏ Œ∏__x t1 t2 x, *)
(*   -> x ‚àâ (fv__x(‚ü¶Œ∏__x ‚ñπ__x t1‚üß) ‚à™ dom_Subx Œ∏__x) *)
(*   -> open_Tm_wrt_Tm ‚ü¶Œ∏ ‚ñπ ‚ü¶Œ∏__x ‚ñπ__x t1‚üß‚üß t2 = ‚ü¶Œ∏ ‚ñπ {t2 ‚âî__x x}‚ü¶Œ∏__x ‚ñπ__x open_Tm_wrt_Tm t1 (t__Var_f x)‚üß‚üß. *)
(* Proof. *)
(*   introv LC NIS LCX DISJ. *)
(*   rewrite Subx_app_open_Tm_wrt_Tm. 2:assumption. 2:symmetry; simpl+; fsetdec. *)
(*   rewrite subst_tvar_Tm_open_Tm_wrt_Tm. 2:assumption. *)
(*   rewrite subst_tvar_Tm_notin. 2:fsetdec. simpl+. if_taut. *)
(*   setoid_rewrite Sub_app_Tm_notindom at 3. reflexivity. assumption. *)
(* Qed. *)

Module tvars_codom_Subx_alg <: List_to_Set_alg Atom AtomSetImpl.
  Definition elt := (Tm * atom)%type.
  Definition f : elt -> atoms := (ftv_Tm ‚àò fst).
End tvars_codom_Subx_alg.
#[export] Hint Unfold tvars_codom_Subx_alg.elt tvars_codom_Subx_alg.f : algs.

Module Export Tvars_codom_Subx := List_to_Set Atom AtomSetImpl tvars_codom_Subx_alg.
Notation tvars_codom_Subx := Tvars_codom_Subx.List_to_Set.

Fact Subx_app_Tm_fv : forall (Œ∏:Subx) (t:Tm),
    fv__x(‚ü¶Œ∏ ‚ñπ__x t‚üß) ‚äÜ (fv__x(t) ‚àñ (dom_Subx Œ∏)) ‚à™ tvars_codom_Subx Œ∏.
Proof.
  introv. ind_Subx Œ∏. simpl+. crush. simpl+ in *. dist.
  rewrite ftv_Tm_subst_tvar_Tm_upper. rewrite IHŒ∏. fsetdec.
Qed.

Module tvars_codom_gamma_alg <: List_to_Set_alg Atom AtomSetImpl.
  Definition elt := ((Tm * Tm) * atom)%type.
  Definition f : elt -> atoms := (fun p => (ftv_Tm ‚àò fst ‚àò fst) p ‚à™ (ftv_Tm ‚àò snd ‚àò fst) p).
End tvars_codom_gamma_alg.
#[export] Hint Unfold tvars_codom_gamma_alg.elt tvars_codom_gamma_alg.f : algs.

Module Export Tvars_codom_gamma := List_to_Set Atom AtomSetImpl tvars_codom_gamma_alg.
Notation tvars_codom_gamma := Tvars_codom_gamma.List_to_Set.

Fact proj1_tvars_codom_gamma_Subx : forall Œ≥, tvars_codom_Subx (œÄ1 Œ≥) ‚äÜ tvars_codom_gamma Œ≥.
Proof. intros. ind_gamma Œ≥; simpl+; crush. Qed.
Fact proj2_tvars_codom_gamma_Subx : forall Œ≥, tvars_codom_Subx (œÄ2 Œ≥) ‚äÜ tvars_codom_gamma Œ≥.
Proof. intros. ind_gamma Œ≥; simpl+; crush. Qed.

Lemma logrel_E_tvars_codom_gamma : forall œÅ Œ≥ œà,
    ‚¶ÖœÅ, Œ≥‚¶Ü ‚àà ‚¶Öùíü, ùí¢‚¶Ü‚ü¶œà‚üß
  -> tvars_codom_gamma Œ≥ ‚â° empty.
Proof.
  introv IN. gen œÅ Œ≥. induction œà. 2:induction a. all:intros; simp' in IN.
  - inverts IN. simpl+. crush.
  - simpl+. destr_logrel_val IN. simpl+ in IHa. rewrite IHa. fsetdec. eauto.
  - simpl+. destr_logrel_val IN. simpl+. fv_empty. specializes IHœà. eassumption. fsetdec.
Qed.

Corollary TmTy_rename_var' : forall œà x y œÑ t œÑ',
    œà ::x x :- S__T œÑ ‚ä¢t open_Tm_wrt_Tm t (t__Var_f x) ‚ñ∏ S__T œÑ'
  -> œà ::x y :- S__T œÑ ‚ä¢t open_Tm_wrt_Tm t (t__Var_f y) ‚ñ∏ S__T œÑ'.
Admitted.

Lemma CompatLam' : forall œà t t' œÑ œÑ' x,
    œà ::x x :- S__T œÑ  ‚ä¢t‚âà (open_Tm_wrt_Tm t (t__Var_f x)) ‚âà (open_Tm_wrt_Tm t' (t__Var_f x)) ‚ñ∏ S__T œÑ'
  -> x ‚àâ E_names œà ‚à™ fv__x(t) ‚à™ fv__x(t')
  -> œà ‚ä¢wfœÑ œÑ
  -> œà ‚ä¢t‚âà t__Lam œÑ t ‚âà t__Lam œÑ t' ‚ñ∏ S__T (T__Fun œÑ œÑ').
Proof.
  introv IH NIL__x WFT.
  forwards TmTy1: TmTy__Abs empty. eassumption. intros. forwards [TmTy [_ _]]: IH. eapply TmTy_rename_var'. eassumption.
  forwards TmTy2: TmTy__Abs empty. eassumption. intros. forwards [_ [TmTy  _]]: IH. eapply TmTy_rename_var'. eassumption.
  splits. 1,2:eassumption. introv IN.
  eapply TmTy_close1 in TmTy1. 2:eassumption.
  eapply TmTy_close2 in TmTy2. 2:eassumption.
  simpl+ in TmTy1. simpl+ in TmTy2.
  apply logrel_val_exp. simp'. splits. splits; simpl+; eauto.
  do 2 eexists. splits. 1,2:simpl+; reflexivity. intros v1 v2 VAL.
  (* forwards [x NIL__x]: atom_fresh (fv__x(‚ü¶œÄ1 Œ≥ ‚ñπ__x t0‚üß) ‚à™ fv__x(‚ü¶œÄ2 Œ≥ ‚ñπ__x t'‚üß) ‚à™ dom_Subx (œÄ1 Œ≥) ‚à™ dom_Subx (œÄ2 Œ≥)). *)
  specializes IH. destruct IH as [_ [_ IH]].
  specializes IH œÅ ((v1, v2, x) :: Œ≥). specializes IH. simp'. do 3 eexists. splits.
  reflexivity. assumption. rewrite logrel_E_dom_gamma. 2:eauto. fsetdec. assumption.
  destruct IH as [TmTy1' [TmTy2' [v3 [v4 [OP1 [OP2 VAL']]]]]]. splits.
  - applys_eq TmTy1'. simpl+. eapply CompatLam__commhelper; eauto with slow.
    rewrite Subx_app_Tm_fv. rewrite proj1_dom_gamma_Sub. rewrite logrel_E_dom_gamma. 2:eauto.
    rewrite proj1_tvars_codom_gamma_Subx. rewrite logrel_E_tvars_codom_gamma. 2:eauto. fsetdec.
  - applys_eq TmTy2'. simpl+. eapply CompatLam__commhelper; eauto with slow.
    rewrite Subx_app_Tm_fv. rewrite proj2_dom_gamma_Sub. rewrite logrel_E_dom_gamma. 2:eauto.
    rewrite proj2_tvars_codom_gamma_Subx. rewrite logrel_E_tvars_codom_gamma. 2:eauto. fsetdec.
  - exists v3 v4. splits.
    + applys_eq OP1. simpl+. eapply CompatLam__commhelper; eauto with slow.
      rewrite Subx_app_Tm_fv. rewrite proj1_dom_gamma_Sub. rewrite logrel_E_dom_gamma. 2:eauto.
      rewrite proj1_tvars_codom_gamma_Subx. rewrite logrel_E_tvars_codom_gamma. 2:eauto. fsetdec.
    + applys_eq OP2. simpl+. eapply CompatLam__commhelper; eauto with slow.
      rewrite Subx_app_Tm_fv. rewrite proj2_dom_gamma_Sub. rewrite logrel_E_dom_gamma. 2:eauto.
      rewrite proj2_tvars_codom_gamma_Subx. rewrite logrel_E_tvars_codom_gamma. 2:eauto. fsetdec.
    + simpl+ in VAL'. jauto.
Qed.

Lemma CompatLam'' : forall œà t t' œÑ œÑ' x,
    œà ::x x :- S__T œÑ  ‚ä¢t‚âà (open_Tm_wrt_Tm t (t__Var_f x)) ‚âà (open_Tm_wrt_Tm t' (t__Var_f x)) ‚ñ∏ S__T œÑ'
  -> x ‚àâ E_names œà ‚à™ fv__x(t) ‚à™ fv__x(t')
  -> œà ‚ä¢wfœÑ œÑ
  -> œà ‚ä¢t‚âà t__Lam œÑ t ‚âà t__Lam œÑ t' ‚ñ∏ S__T (T__Fun œÑ œÑ').
Proof.
  introv IH NIL__x WFT.
  forwards TmTy1: TmTy__Abs empty. eassumption. intros. forwards [TmTy [_ _]]: IH. eapply TmTy_rename_var'. eassumption.
  forwards TmTy2: TmTy__Abs empty. eassumption. intros. forwards [_ [TmTy  _]]: IH. eapply TmTy_rename_var'. eassumption.
  splits. 1,2:eassumption. introv IN.
  eapply TmTy_close1 in TmTy1. 2:eassumption.
  eapply TmTy_close2 in TmTy2. 2:eassumption.
  simpl+ in TmTy1. simpl+ in TmTy2.
  apply logrel_val_exp. simp'. splits. splits; simpl+; eauto.
  do 2 eexists. splits. 1,2:simpl+; reflexivity. intros v1 v2 VAL.
  (* forwards [x NIL__x]: atom_fresh (fv__x(‚ü¶œÄ1 Œ≥ ‚ñπ__x t0‚üß) ‚à™ fv__x(‚ü¶œÄ2 Œ≥ ‚ñπ__x t'‚üß) ‚à™ dom_Subx (œÄ1 Œ≥) ‚à™ dom_Subx (œÄ2 Œ≥)). *)
  specializes IH. destruct IH as [_ [_ IH]].
  specializes IH œÅ ((v1, v2, x) :: Œ≥). specializes IH. simp'. do 3 eexists. splits.
  reflexivity. assumption. rewrite logrel_E_dom_gamma. 2:eauto. fsetdec. assumption.
  destruct IH as [TmTy1' [TmTy2' [v3 [v4 [OP1 [OP2 VAL']]]]]]. splits.
  - applys_eq TmTy1'. simpl+. eapply CompatLam__commhelper; eauto with slow.
    rewrite Subx_app_Tm_fv. rewrite proj1_dom_gamma_Sub. rewrite logrel_E_dom_gamma. 2:eauto.
    rewrite proj1_tvars_codom_gamma_Subx. rewrite logrel_E_tvars_codom_gamma. 2:eauto. fsetdec.
  - applys_eq TmTy2'. simpl+. eapply CompatLam__commhelper; eauto with slow.
    rewrite Subx_app_Tm_fv. rewrite proj2_dom_gamma_Sub. rewrite logrel_E_dom_gamma. 2:eauto.
    rewrite proj2_tvars_codom_gamma_Subx. rewrite logrel_E_tvars_codom_gamma. 2:eauto. fsetdec.
  - exists v3 v4. splits.
    + applys_eq OP1. simpl+. eapply CompatLam__commhelper; eauto with slow.
      rewrite Subx_app_Tm_fv. rewrite proj1_dom_gamma_Sub. rewrite logrel_E_dom_gamma. 2:eauto.
      rewrite proj1_tvars_codom_gamma_Subx. rewrite logrel_E_tvars_codom_gamma. 2:eauto. fsetdec.
    + applys_eq OP2. simpl+. eapply CompatLam__commhelper; eauto with slow.
      rewrite Subx_app_Tm_fv. rewrite proj2_dom_gamma_Sub. rewrite logrel_E_dom_gamma. 2:eauto.
      rewrite proj2_tvars_codom_gamma_Subx. rewrite logrel_E_tvars_codom_gamma. 2:eauto. fsetdec.
    + simpl+ in VAL'. jauto.
Qed.

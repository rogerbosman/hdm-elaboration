Set Warnings "-notation-overridden,-intuition-auto-with-star".

Require Import Preamble.
Require Import Defs.HdmLems.

Require Import Defs.Foralls.
Require Import Defs.Lc.
Require Import Defs.Sub.
Require Import Defs.Subx.
Require Import Defs.TmTy.

Require Import Semantics.ClosedVals.
Require Import Semantics.gammaDef.
Require Import Semantics.LogRel.
Require Import Semantics.logrel_val_props.
Require Import Semantics.Opsem.
Require Import Semantics.rho.

(*** Lemmas *)
Fact comp_closed_vals_sk_helper : forall Î± Î² Ï,
    Î² âˆ‰ ({{Î±}} âˆª skvars_codom_rho Ï)
  -> Î² âˆ‰ (fv__Î±(âŸ¦Ï€1 Ï â–¹ T__Var_f Î±âŸ§) âˆª fv__Î±(âŸ¦Ï€2 Ï â–¹ T__Var_f Î±âŸ§)).
Proof.
  introv NIL. do 2 rewrite Sub_app_T_fsk'. simpl+.
  forwards: proj1_skvars_codom_rho_Sub Ï.
  forwards: proj2_skvars_codom_rho_Sub Ï.
  fsetdec.
Qed.

Lemma open_Sc_wrt_T_rec_open_Sc_wrt_T_rec : forall Î± Ï„ n m Ïƒ,
    n >= m
  -> lc(Ï„)
  -> open_Sc_wrt_T_rec m (T__Var_f Î±) (open_Sc_wrt_T_rec (S n) Ï„ Ïƒ) = open_Sc_wrt_T_rec n Ï„ (open_Sc_wrt_T_rec m (T__Var_f Î±) Ïƒ).
Proof.
  intros. gen n m.
  induction Ïƒ; intros. induction Ï„0. 2,3,4,5,6:crush.
  simpl+. fequals. lt_eq_dec; simpl+; lt_eq_dec; crush.
Qed.

Lemma closed_vals_swap_rho : forall v1 v2 Ïƒ Ï__l Ï__r Ï„__Î±1 Ï„__Î±2 R__Î± Î± Ï„__Î²1 Ï„__Î²2 R__Î² Î²,
    Î± <> Î²
  -> Î± âˆ‰ fv__Î±(Ï„__Î²1) âˆª fv__Î±(Ï„__Î²2)
  -> Î² âˆ‰ fv__Î±(Ï„__Î±1) âˆª fv__Î±(Ï„__Î±2)
  -> closed_vals Ïƒ (Ï__l ++ (Ï„__Î±1, Ï„__Î±2, R__Î±, Î±) :: (Ï„__Î²1, Ï„__Î²2, R__Î², Î²) :: Ï__r) v1 v2
  -> closed_vals Ïƒ (Ï__l ++ (Ï„__Î²1, Ï„__Î²2, R__Î², Î²) :: (Ï„__Î±1, Ï„__Î±2, R__Î±, Î±) :: Ï__r) v1 v2.
Proof.
  introv NEQ NI1 NI2 [IV1 [IV2 [TMTY1 TMTY2]]]. splits. 1,2:assumption.
  - applys_eq TMTY1. dist.
    rewrite subst_skvar_Sc_subst_skvar_Sc. 2,3:fsetdec.
    rewrite subst_skvar_T_notin. reflexivity. fsetdec.
  - applys_eq TMTY2. dist.
    rewrite subst_skvar_Sc_subst_skvar_Sc. 2,3:fsetdec.
    rewrite subst_skvar_T_notin. reflexivity. fsetdec.
Qed.

Lemma logrel_val_swap_rho : forall Ïƒ v1 v2 Ï__l Ï__r Ï„__Î±1 Ï„__Î±2 R__Î± Î± Ï„__Î²1 Ï„__Î²2 R__Î² Î²,
    Î± <> Î²
  -> Î± âˆ‰ fv__Î±(Ï„__Î²1) âˆª fv__Î±(Ï„__Î²2)
  -> Î² âˆ‰ fv__Î±(Ï„__Î±1) âˆª fv__Î±(Ï„__Î±2)
  -> â¦…v1 Ã— v2â¦† âˆˆ ğ’±âŸ¦ÏƒâŸ§ (Ï__l ++ (Ï„__Î±1, Ï„__Î±2, R__Î±, Î±) :: (Ï„__Î²1, Ï„__Î²2, R__Î², Î²) :: Ï__r)
  -> â¦…v1 Ã— v2â¦† âˆˆ ğ’±âŸ¦ÏƒâŸ§ (Ï__l ++ (Ï„__Î²1, Ï„__Î²2, R__Î², Î²) :: (Ï„__Î±1, Ï„__Î±2, R__Î±, Î±) :: Ï__r).
Proof.
  introv NEQ NI1 NI2 VAL. gen Ï__l v1 v2.
  forwards [n H]: calc_foralls Ïƒ. gen Ïƒ. induction n; intros; rename H into H__foralls.
  destruct Ïƒ; [clear H__foralls | inverts H__foralls]. gen v1 v2 Ï„__Î±1 Ï„__Î±2 R__Î± Î± Ï„__Î²1 Ï„__Î²2 R__Î² Î².
  induction Ï„; intros; simp' in *; destruct VAL as [CV VAL]; split; try eauto using closed_vals_swap_rho.
  - clear - NEQ VAL. ind_rho Ï__l. simpl+ in *. if_dec; crush. simpl+ in *. if_dec; crush.
  - destruct VAL as [t1 [t2 [EQ1 [EQ2 VAL]]]]. exists t1 t2. splits.
    + applys_eq EQ1. fequals. dist. rewrite subst_skvar_T_subst_skvar_T. 2,3:fsetdec.
      rewrite (subst_skvar_T_notin Ï„__Î²1 Î²). 2:fsetdec. reflexivity.
    + applys_eq EQ2. fequals. dist. rewrite subst_skvar_T_subst_skvar_T. 2,3:fsetdec.
      rewrite (subst_skvar_T_notin Ï„__Î²2 Î²). 2:fsetdec. reflexivity.
    + intros v1' v2' VAL'. apply IHÏ„1 in VAL'. 2:fsetdec. 2:crush. 2:fsetdec. specializes VAL v1' v2' VAL'.
      destruct VAL as [TMTY1 [TMTY2 [v1'' [v2'' [OP1 [OP2 VAL]]]]]]. splits.
      * applys_eq TMTY1. fequals. dist. rewrite subst_skvar_T_subst_skvar_T. 2,3:fsetdec.
        rewrite (subst_skvar_T_notin Ï„__Î²1 Î²). 2:fsetdec. reflexivity.
      * applys_eq TMTY2. fequals. dist. rewrite subst_skvar_T_subst_skvar_T. 2,3:fsetdec.
        rewrite (subst_skvar_T_notin Ï„__Î²2 Î²). 2:fsetdec. reflexivity.
      * exists v1'' v2''. splits. 1,2:assumption.
        apply IHÏ„2 in VAL. eassumption. fsetdec. crush. fsetdec.
  - destruct Ïƒ. simpl+ in H__foralls. all:inverts H__foralls.
    simp' in *. destruct VAL as [CV [t1 [t2 [EQ1 [EQ2 VAL]]]]]. split. auto using closed_vals_swap_rho.
    exists t1 t2. splits. 1,2:assumption.
    intros Ï„1 Ï„2 R. specializes VAL Ï„1 Ï„2 R.
    destruct VAL as [L VAL]. exists L.
    intros Î±' NIL__Î±' RV. specializes VAL Î±' NIL__Î±' RV. destruct VAL as [TMTY1 [TMTY2 [v1' [v2' [OP1 [OP2 VAL]]]]]].
    splits.
    + applys_eq TMTY1. dist. rewrite subst_skvar_Sc_subst_skvar_Sc. 2,3:fsetdec.
      rewrite subst_skvar_T_notin. 2:fsetdec. reflexivity.
    + applys_eq TMTY2. dist. rewrite subst_skvar_Sc_subst_skvar_Sc. 2,3:fsetdec.
      rewrite subst_skvar_T_notin. 2:fsetdec. reflexivity.
    + exists v1' v2'. splits. 1,2:assumption.
      forwards: IHn (open_Sc_wrt_T Ïƒ (T__Var_f Î±')) ((Ï„1, Ï„2, R, Î±') :: Ï__l). simpl+. crush. applys_eq VAL.
      eassumption.
Qed.

Corollary logrel_val_swap_rho' : forall Ïƒ v1 v2 Ï Ï„__Î±1 Ï„__Î±2 R__Î± Î± Ï„__Î²1 Ï„__Î²2 R__Î² Î²,
    Î± <> Î²
  -> Î± âˆ‰ fv__Î±(Ï„__Î²1) âˆª fv__Î±(Ï„__Î²2)
  -> Î² âˆ‰ fv__Î±(Ï„__Î±1) âˆª fv__Î±(Ï„__Î±2)
  -> â¦…v1 Ã— v2â¦† âˆˆ ğ’±âŸ¦ÏƒâŸ§ ((Ï„__Î±1, Ï„__Î±2, R__Î±, Î±) :: (Ï„__Î²1, Ï„__Î²2, R__Î², Î²) :: Ï)
  -> â¦…v1 Ã— v2â¦† âˆˆ ğ’±âŸ¦ÏƒâŸ§ ((Ï„__Î²1, Ï„__Î²2, R__Î², Î²) :: (Ï„__Î±1, Ï„__Î±2, R__Î±, Î±) :: Ï).
Proof. introv NEQ NI1 NI2 VAL. forwards: logrel_val_swap_rho ([]:rho). 4:applys_eq VAL. all:crush. Qed.

Lemma closed_vals_swap_R : forall Ïƒ Ï__l Ï__r (R2 R1:ğ“¡) v1 v2 Ï„1 Ï„2 Î±,
    closed_vals Ïƒ (Ï__l ++ (Ï„1, Ï„2, R1, Î±) :: Ï__r) v1 v2
  -> closed_vals Ïƒ (Ï__l ++ (Ï„1, Ï„2, R2, Î±) :: Ï__r) v1 v2.
Proof.
  introv [IV1 [IV2 [TMTY1 TMTY2]]]. dist in *. splits. 1,2:assumption.
  - dist. assumption.
  - dist. assumption.
Qed.

Lemma logrel_val_swap_R : forall Ïƒ Ï__l Ï__r (R2 R1:ğ“¡) v1 v2 Ï„1 Ï„2 Î±,
    (forall v1 v2, R1 v1 v2 <-> R2 v1 v2)
  -> â¦…v1 Ã— v2â¦† âˆˆ ğ’±âŸ¦ÏƒâŸ§ (Ï__l ++ (Ï„1, Ï„2, R1, Î±) :: Ï__r)
  -> â¦…v1 Ã— v2â¦† âˆˆ ğ’±âŸ¦ÏƒâŸ§ (Ï__l ++ (Ï„1, Ï„2, R2, Î±) :: Ï__r).
Proof.
  intro Ïƒ. forall_ind Ïƒ. induction Ï„; introv RIFF VAL; simp' in *; split; destruct VAL as [CV VAL]; try eauto using closed_vals_swap_R.
  - clear - VAL RIFF. ind_rho Ï__l. simpl+ in *. if_dec. apply RIFF. assumption. assumption.
    simpl+ in *. if_dec. assumption. apply IHÏ__l. eassumption.
  - destruct VAL as [t1 [t2 [EQ1 [EQ2 VAL]]]]. exists t1 t2. splits.
    + dist. dist in EQ1. assumption.
    + dist. dist in EQ2. assumption.
    + intros v1' v2' VAL'. eapply IHÏ„1 in VAL'. specializes VAL v1' v2' VAL'.
      destruct VAL as [TMTY1 [TMTY2 [v1'' [v2'' [OP1 [OP2 VAL]]]]]]. splits.
      * dist. dist in TMTY1. eassumption.
      * dist. dist in TMTY2. eassumption.
      * exists v1'' v2''. splits; eauto.
      * crush.
  - introv RIFF VAL. simp' in *. destruct VAL as [CV [t1 [t2 [EQ1 [EQ2 VAL]]]]].
    split. eauto using closed_vals_swap_R. exists t1 t2. splits. 1,2:assumption.
    intros Ï„1' Ï„2' R. specializes VAL Ï„1' Ï„2' R.
    destruct VAL as [L VAL]. exists L.
    intros Î² NIL__Î² RV. specializes VAL Î² NIL__Î² RV.
    destruct VAL as [TMTY1 [TMTY2 [v1' [v2' [OP1 [OP2 VAL]]]]]]. splits.
    + dist. dist in TMTY1. assumption.
    + dist. dist in TMTY2. assumption.
    + exists v1' v2'. splits. 1,2:assumption.
      forwards: IHn ((Ï„1', Ï„2', R, Î²) :: Ï__l) R2 R1.
      3:applys_eq VAL. simpl+. crush. crush. assumption.
Qed.

Corollary logrel_val_swap_R' : forall (R2 R1:ğ“¡) Ïƒ Ï v1 v2 Ï„1 Ï„2 Î±,
    (forall v1 v2, R1 v1 v2 <-> R2 v1 v2)
  -> â¦…v1 Ã— v2â¦† âˆˆ ğ’±âŸ¦ÏƒâŸ§ ((Ï„1, Ï„2, R1, Î±) :: Ï)
  -> â¦…v1 Ã— v2â¦† âˆˆ ğ’±âŸ¦ÏƒâŸ§ ((Ï„1, Ï„2, R2, Î±) :: Ï).
Proof. introv RIFF VAL. forwards: logrel_val_swap_R ([]:rho) R2 R1. crush. applys_eq VAL. applys_eq H. Qed.

(*** Compositionality *)
Lemma Compositionality__closedvals : forall Ïƒ n Î± Ï„ Ï v1 v2,
    Î± âˆ‰ skvars_codom_Sub (Ï€1 Ï) âˆª skvars_codom_Sub (Ï€2 Ï) âˆª dom_Sub (Ï€1 Ï) âˆª dom_Sub (Ï€2 Ï) âˆª fv__Î±(Ïƒ)
  -> fv__Î±(âŸ¦Ï€1 Ï â–¹ Ï„âŸ§) â‰¡ (âˆ…)
  -> fv__Î±(âŸ¦Ï€2 Ï â–¹ Ï„âŸ§) â‰¡ (âˆ…)
  -> lc(Ï)
  -> lc_T âŸ¦Ï€1 Ï â–¹ Ï„âŸ§
  -> lc_T âŸ¦Ï€2 Ï â–¹ Ï„âŸ§
  -> closed_vals (open_Sc_wrt_T_rec n (T__Var_f Î±) Ïƒ) ((âŸ¦Ï€1 Ï â–¹ Ï„âŸ§, âŸ¦Ï€2 Ï â–¹ Ï„âŸ§, logrel_val (S__T Ï„) Ï, Î±) :: Ï) v1 v2
  <-> closed_vals (open_Sc_wrt_T_rec n Ï„ Ïƒ) Ï v1 v2.
Proof.
  introv NI__Î± EQ1 EQ2 LC LC1 LC2. split; introv [IV1 [IV2 [TMTY1 TMTY2]]]; splits; try assumption.
  - applys_eq TMTY1. dist. rewrite Sub_app_Sc_subst_skvar_Sc. 2:fsetdec. 2:rewrite EQ1; simpl+; fsetdec.
    rewrite subst_skvar_Sc_open_Sc_wrt_T_rec. 2:assumption. simpl+. if_taut.
    rewrite Sub_app_Sc_open_Sc_wrt_T_rec. 2:eauto.
    rewrite Sub_app_Sc_open_Sc_wrt_T_rec. 2:eauto.
    fequals. symmetry. Sub_notin'. rewrite EQ1. crush. subst_notin'. reflexivity. fsetdec.
  - applys_eq TMTY2. dist. rewrite Sub_app_Sc_subst_skvar_Sc. 2:fsetdec. 2:rewrite EQ2; simpl+; fsetdec.
    rewrite subst_skvar_Sc_open_Sc_wrt_T_rec. 2:assumption. simpl+. if_taut.
    rewrite Sub_app_Sc_open_Sc_wrt_T_rec. 2:eauto.
    rewrite Sub_app_Sc_open_Sc_wrt_T_rec. 2:eauto.
    fequals. symmetry. Sub_notin'. rewrite EQ2. crush. subst_notin'. reflexivity. fsetdec.
  - applys_eq TMTY1. symmetry. dist. rewrite Sub_app_Sc_subst_skvar_Sc. 2:fsetdec. 2:rewrite EQ1; simpl+; fsetdec.
    rewrite subst_skvar_Sc_open_Sc_wrt_T_rec. 2:assumption. simpl+. if_taut.
    rewrite Sub_app_Sc_open_Sc_wrt_T_rec. 2:eauto.
    rewrite Sub_app_Sc_open_Sc_wrt_T_rec. 2:eauto.
    fequals. symmetry. Sub_notin'. rewrite EQ1. crush. subst_notin'. reflexivity. fsetdec.
  - applys_eq TMTY2. symmetry. dist. rewrite Sub_app_Sc_subst_skvar_Sc. 2:fsetdec. 2:rewrite EQ2; simpl+; fsetdec.
    rewrite subst_skvar_Sc_open_Sc_wrt_T_rec. 2:assumption. simpl+. if_taut.
    rewrite Sub_app_Sc_open_Sc_wrt_T_rec. 2:eauto.
    rewrite Sub_app_Sc_open_Sc_wrt_T_rec. 2:eauto.
    fequals. symmetry. Sub_notin'. rewrite EQ2. crush. subst_notin'. reflexivity. fsetdec.
Qed.

Corollary Compositionality__closedvals' : forall Ïƒ n Î± Ï„ Ï v1 v2,
    Î± âˆ‰ (fv__Î±(Ïƒ) âˆª dom_rho Ï)
  -> skvars_codom_rho Ï â‰¡ (âˆ…)
  -> lc(Ï)
  -> (â€¢ âŠ¢wfÏ„ âŸ¦Ï€1 Ï â–¹ Ï„âŸ§)
  -> (â€¢ âŠ¢wfÏ„ âŸ¦Ï€2 Ï â–¹ Ï„âŸ§)
  -> closed_vals (open_Sc_wrt_T_rec n (T__Var_f Î±) Ïƒ) ((âŸ¦Ï€1 Ï â–¹ Ï„âŸ§, âŸ¦Ï€2 Ï â–¹ Ï„âŸ§, logrel_val (S__T Ï„) Ï, Î±) :: Ï) v1 v2
  <-> closed_vals (open_Sc_wrt_T_rec n Ï„ Ïƒ) Ï v1 v2.
Proof.
  intros. apply Compositionality__closedvals. rewrite proj1_skvars_codom_rho_Sub. rewrite proj2_skvars_codom_rho_Sub.
  split_rho. fsetdec. fv_empty. reflexivity. fv_empty. reflexivity.
  assumption. eauto. eauto.
Qed.

Lemma Compositionality : forall v1 v2 Ïƒ Î± Ï Ï„,
    Î± âˆ‰ (fv__Î±(Ïƒ) âˆª dom_rho Ï)
  -> lc((âŸ¦Ï€1 Ï â–¹ Ï„âŸ§, âŸ¦Ï€2 Ï â–¹ Ï„âŸ§, logrel_val (S__T Ï„) Ï, Î±) :: Ï)
  -> lc(Ï„)
  -> (â€¢ âŠ¢wfÏ„ âŸ¦Ï€1 Ï â–¹ Ï„âŸ§)
  -> (â€¢ âŠ¢wfÏ„ âŸ¦Ï€2 Ï â–¹ Ï„âŸ§)
  -> skvars_codom_rho Ï â‰¡ (âˆ…)
  -> â¦…v1 Ã— v2â¦† âˆˆ ğ’±âŸ¦open_Sc_wrt_T Ïƒ (T__Var_f Î±)âŸ§ ((âŸ¦Ï€1 Ï â–¹ Ï„âŸ§, âŸ¦Ï€2 Ï â–¹ Ï„âŸ§, logrel_val (S__T Ï„) Ï, Î±) :: Ï) <-> â¦…v1 Ã— v2â¦† âˆˆ ğ’±âŸ¦open_Sc_wrt_T Ïƒ Ï„âŸ§ Ï.
Proof.
  introv NIS LC LC__Ï„ WFT1 WFT2 EMP. unfold open_Sc_wrt_T. generalize 0. gen v1 v2. apply cons_rho_lc in LC. destruct LC as [LC1 [LC2 LC]]. gen Ï.
  forall_ind Ïƒ; intros. clear LC__Ï„. gen v1 v2. induction Ï„0; intros.

  - simpl+. lt_eq_dec. 1,3:simp'; crush. split; intro VAL; simp' in VAL.
    + simpl+ in VAL. if_taut. jauto.
    + simp'. simpl+. if_taut. split. 2:jauto.
      asserts_rewrite (S__T Ï„ = open_Sc_wrt_T_rec 0 Ï„ (S__T (T__Var_b 0))) in VAL. reflexivity.
      forwards CV: props_logrel_val. eassumption.
      rewrite <- Compositionality__closedvals' in CV; try eauto. applys_eq CV.

  - simpl+. split; intro VAL.
    + simp' in *. destruct VAL as [VALS VAL]. splits.
      eapply closed_vals_weakening_compositionality. 2:eassumption. eapply comp_closed_vals_sk_helper. simpl+ in NIS. fsetdec.
      simpl+ in *. if_dec. fsetdec. eassumption.
    (** Same as last case *)
    + simp' in *. destruct VAL as [VALS VAL]. splits.
      eapply closed_vals_weakening_compositionality. 2:eassumption. eapply comp_closed_vals_sk_helper. simpl+ in NIS. fsetdec.
      simpl+ in *. if_dec. fsetdec. eassumption.

  - simpl+. simp'. split; intros [CV EQ]; split; destruct EQ; inverts H; crush; crush.

  - simpl+. simp'. split; intros [CV EQ]; split; destruct EQ; inverts H; crush; crush.

  - (** Conditions for subst_skvar_T_Sub_app_T_open_T_wrt_T*)
    assert (Î± âˆ‰ skvars_codom_rho Ï). clear - NIS EMP. fsetdec.
    (** Now proof of case *)
    split; intro VAL.
    + simpl+ in *. simp' in VAL. destruct VAL as [VALS [t1 [t2 [EQ1 [EQ2 VAL]]]]]. simp'. splits.
      forwards> CV: (Compositionality__closedvals' (S__T (T__Fun Ï„0_1 Ï„0_2))). 6:applys_eq VALS. 1,2,3,4,5:eauto.
      applys_eq CV.
      exists t1 t2. splits.
      * applys_eq EQ1. dist. fequals. eauto using subst_skvar_T_Sub_app_T_open_T_wrt_T_rec.
      * applys_eq EQ2. dist. fequals. eauto using subst_skvar_T_Sub_app_T_open_T_wrt_T_rec.
      * intros v1' v2' VAL'. specializes VAL v1' v2'. specializes VAL.
        apply IHÏ„0_1(* apply IHlc_T1 *); try eassumption. fsetdec. destruct VAL as [ClTmTy1 [ClTmTy2 [v1'' [v2'' [OP1 [OP2 VAL]]]]]].
        splits.
        -- applys_eq ClTmTy1. fequals. simpl+. dist. eauto using subst_skvar_T_Sub_app_T_open_T_wrt_T_rec.
        -- applys_eq ClTmTy2. fequals. simpl+. dist. eauto using subst_skvar_T_Sub_app_T_open_T_wrt_T_rec.
        -- exists v1'' v2''. splits. eassumption. eassumption. apply IHÏ„0_2(* apply IHlc_T2 *); try eassumption. fsetdec.
    (** Repeat of previous with added symmetry *)
    + simpl+ in *. simp' in VAL. destruct VAL as [VALS [t1 [t2 [EQ1 [EQ2 VAL]]]]]. simp'. splits.
      forwards< CV: (Compositionality__closedvals' (S__T (T__Fun Ï„0_1 Ï„0_2))). 6:applys_eq VALS. 1,2,3,4,5:eauto.
      applys_eq CV.
      exists t1 t2. splits.
      * applys_eq EQ1. dist. fequals. symmetry. eauto using subst_skvar_T_Sub_app_T_open_T_wrt_T_rec.
      * applys_eq EQ2. dist. fequals. symmetry. eauto using subst_skvar_T_Sub_app_T_open_T_wrt_T_rec.
      * intros v1' v2' VAL'. specializes VAL v1' v2'. specializes VAL.
        apply IHÏ„0_1(* apply IHlc_T1 *); try eassumption. fsetdec. destruct VAL as [ClTmTy1 [ClTmTy2 [v1'' [v2'' [OP1 [OP2 VAL]]]]]].
        splits.
        -- applys_eq ClTmTy1. fequals. simpl+. dist. symmetry. eauto using subst_skvar_T_Sub_app_T_open_T_wrt_T_rec.
        -- applys_eq ClTmTy2. fequals. simpl+. dist. symmetry. eauto using subst_skvar_T_Sub_app_T_open_T_wrt_T_rec.
        -- exists v1'' v2''. splits. eassumption. eassumption. apply IHÏ„0_2(* apply IHlc_T2 *); try eassumption. fsetdec.

  - simpl+. simp' in *. split; intros [CV [t1 [t2 [EQ1 [EQ2 VAL]]]]]; subst.
    + split. forwards>: Compositionality__closedvals'. 6:instantiate (11 := S__Forall Ïƒ__Forall); applys_eq CV. 1,2,3,4,5:eauto. eassumption.
      exists t1 t2. splits; try reflexivity.
      intros Ï„1 Ï„2 R. specializes VAL Ï„1 Ï„2 R. destruct VAL as [L VAL]. exists (L âˆª {{Î±}} âˆª fv__Î±(âŸ¦Ï€1 Ï â–¹ Ï„âŸ§) âˆª fv__Î±(âŸ¦Ï€2 Ï â–¹ Ï„âŸ§)).
      intros Î² NIL__Î². specializes VAL Î². intro RV. specializes VAL. fsetdec. assumption. destruct VAL as [TMTY1 [TMTY2 [v1 [v2 [OP1 [OP2 VAL]]]]]].
      unfold open_Sc_wrt_T in VAL. rewrite open_Sc_wrt_T_rec_open_Sc_wrt_T_rec in VAL. 2:crush. 2:crush.
      forwards IH': IHn (open_Sc_wrt_T_rec 0 (T__Var_f Î²) Ïƒ__Forall) ((Ï„1, Ï„2, R, Î²) :: Ï) v1 v2 n.
        simpl+. crush. rewrite fsk_Sc_open_Sc_wrt_T_rec_upper. simpl+.
        simpl+ in NIS. simpl+. clear - NIS NIL__Î². fsetdec. dist. apply subst_skvar_T_lc_T; eauto. apply subst_skvar_T_lc_T; eauto.
        eauto using rho_lc_cons_valid. dist. subst_notin'. assumption. fv_empty. dist. subst_notin'. assumption. fv_empty.
        simpl+. fv_empty. simpl+. eassumption.
      forwards VAL': logrel_val_swap_rho' VAL. clear - NIL__Î². fsetdec. clear - NIL__Î². fsetdec. fv_empty.
      apply (logrel_val_swap_R' (logrel_val (S__T Ï„) ((Ï„1, Ï„2, R, Î²) :: Ï))) in VAL'. 2:eauto using logrel_val_weakening_compositionality.
      forwards>: IH'. applys_eq VAL'. fequals. fequals. dist. clear - NIL__Î². subst_notin. dist. clear - NIL__Î². subst_notin.
      split_rho. splits.
      * applys_eq TMTY1. dist. fequals. rewrite (Sub_app_Sc_subst_skvar_Sc âŸ¦Ï€1 Ï â–¹ Ï„âŸ§).
          2:apply proj1_skvars_codom_rho_Sub_hint; fsetdec.
          2:fv_empty'; [simpl+; fsetdec|eauto].
        rewrite subst_skvar_Sc_open_Sc_wrt_T. 2:eauto. simpl+. if_dec. clear - NIL__Î². fsetdec.
        rewrite subst_skvar_Sc_open_Sc_wrt_T_rec. 2:auto. simpl+. if_taut. subst_notin'. 2:fsetdec.
        rewrite Sub_app_Sc_open_Sc_wrt_T. 2:eauto. rewrite Sub_app_Sc_open_Sc_wrt_T. 2:eauto. fequals.
        rewrite Sub_app_Sc_open_Sc_wrt_T_rec. 2:eauto. rewrite Sub_app_Sc_open_Sc_wrt_T_rec. 2:eauto. fequals.
        symmetry. Sub_notin'. fv_empty.
      * applys_eq TMTY2. dist. fequals. rewrite (Sub_app_Sc_subst_skvar_Sc âŸ¦Ï€2 Ï â–¹ Ï„âŸ§).
          2:apply proj2_skvars_codom_rho_Sub_hint; fsetdec.
          2:fv_empty'; [simpl+; fsetdec|eauto].
        rewrite subst_skvar_Sc_open_Sc_wrt_T. 2:eauto. simpl+. if_dec. clear - NIL__Î². fsetdec.
        rewrite subst_skvar_Sc_open_Sc_wrt_T_rec. 2:auto. simpl+. if_taut. subst_notin'. 2:fsetdec.
        rewrite Sub_app_Sc_open_Sc_wrt_T. 2:eauto. rewrite Sub_app_Sc_open_Sc_wrt_T. 2:eauto. fequals.
        rewrite Sub_app_Sc_open_Sc_wrt_T_rec. 2:eauto. rewrite Sub_app_Sc_open_Sc_wrt_T_rec. 2:eauto. fequals.
        symmetry. Sub_notin'. fv_empty.
      * do 2 eexists. splits. eassumption. eassumption. unfold open_Sc_wrt_T. rewrite open_Sc_wrt_T_rec_open_Sc_wrt_T_rec. eassumption. crush. eauto.
    + split. forwards<: Compositionality__closedvals'. 6:instantiate (4 := S__Forall Ïƒ__Forall); applys_eq CV. 1,2,3,4,5: eauto. eassumption.
      exists t1 t2. splits; try reflexivity.
      intros Ï„1 Ï„2 R. specializes VAL Ï„1 Ï„2 R. destruct VAL as [L VAL]. exists (L âˆª {{Î±}} âˆª fv__Î±(âŸ¦Ï€1 Ï â–¹ Ï„âŸ§) âˆª fv__Î±(âŸ¦Ï€2 Ï â–¹ Ï„âŸ§)).
      intros Î² NIL__Î². specializes VAL Î². intro RV. specializes VAL. fsetdec. assumption. destruct VAL as [TMTY1 [TMTY2 [v1 [v2 [OP1 [OP2 VAL]]]]]].
      unfold open_Sc_wrt_T in VAL. rewrite open_Sc_wrt_T_rec_open_Sc_wrt_T_rec in VAL. 2:crush. 2:crush.
      forwards IH': IHn (open_Sc_wrt_T_rec 0 (T__Var_f Î²) Ïƒ__Forall) ((Ï„1, Ï„2, R, Î²) :: Ï) v1 v2 n.
        simpl+. crush. rewrite fsk_Sc_open_Sc_wrt_T_rec_upper. simpl+.
        simpl+ in NIS. simpl+. clear - NIS NIL__Î². fsetdec. dist. apply subst_skvar_T_lc_T; eauto. apply subst_skvar_T_lc_T; eauto.
        eauto using rho_lc_cons_valid. dist. subst_notin'. assumption. fv_empty. dist. subst_notin'. assumption. fv_empty.
        simpl+. fv_empty. simpl+. eassumption.
      forwards<: IH'. applys_eq VAL.
      apply (logrel_val_swap_R' (logrel_val (S__T Ï„) Ï)) in H. 2:symmetry; eauto using logrel_val_weakening_compositionality.
      forwards VAL': logrel_val_swap_rho' H. clear - NIL__Î². fsetdec. fv_empty. simpl+.
        dist. subst_notin'. 2:fsetdec. dist. subst_notin'. 2:fsetdec. fsetdec.
      split_rho. splits.
      * applys_eq TMTY1. dist. fequals. rewrite (Sub_app_Sc_subst_skvar_Sc âŸ¦Ï€1 Ï â–¹ Ï„âŸ§).
          2:apply proj1_skvars_codom_rho_Sub_hint; fsetdec.
          2:fv_empty'; [simpl+; fsetdec|eauto].
        rewrite subst_skvar_Sc_open_Sc_wrt_T. 2:eauto. simpl+. if_dec. clear - NIL__Î². fsetdec.
        rewrite subst_skvar_Sc_open_Sc_wrt_T_rec. 2:auto. simpl+. if_taut. subst_notin'. 2:fsetdec.
        rewrite Sub_app_Sc_open_Sc_wrt_T. 2:eauto. rewrite Sub_app_Sc_open_Sc_wrt_T. 2:eauto. fequals.
        rewrite Sub_app_Sc_open_Sc_wrt_T_rec. 2:eauto. rewrite Sub_app_Sc_open_Sc_wrt_T_rec. 2:eauto. fequals.
        Sub_notin'. fv_empty.
      * applys_eq TMTY2. dist. fequals. rewrite (Sub_app_Sc_subst_skvar_Sc âŸ¦Ï€2 Ï â–¹ Ï„âŸ§).
          2:apply proj2_skvars_codom_rho_Sub_hint; fsetdec.
          2:fv_empty'; [simpl+; fsetdec|eauto].
        rewrite subst_skvar_Sc_open_Sc_wrt_T. 2:eauto. simpl+. if_dec. clear - NIL__Î². fsetdec.
        rewrite subst_skvar_Sc_open_Sc_wrt_T_rec. 2:auto. simpl+. if_taut. subst_notin'. 2:fsetdec.
        rewrite Sub_app_Sc_open_Sc_wrt_T. 2:eauto. rewrite Sub_app_Sc_open_Sc_wrt_T. 2:eauto. fequals.
        rewrite Sub_app_Sc_open_Sc_wrt_T_rec. 2:eauto. rewrite Sub_app_Sc_open_Sc_wrt_T_rec. 2:eauto. fequals.
        Sub_notin'. fv_empty.
      * do 2 eexists. splits. eassumption. eassumption. unfold open_Sc_wrt_T. rewrite open_Sc_wrt_T_rec_open_Sc_wrt_T_rec.
        applys_eq VAL'. dist. fequals. subst_notin'. 2:fsetdec. subst_notin'. fsetdec. crush. crush.
Qed.
